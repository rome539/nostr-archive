<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.4/dexie.min.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr Notes Archive</title>
   <script type="module">
  import * as NostrTools from 'https://cdn.jsdelivr.net/npm/nostr-tools@2.7.1/+esm';
  window.NostrTools = NostrTools;
</script>
    <style>
        /* CSS Variables for Theme Colors */
:root {
    /* Default Theme */
    --primary-color: #3498db;
    --primary-hover: #2980b9;
    --secondary-color: #7fb3d3;  /* ADD THIS */
    --success-color: #27ae60;
    --danger-color: #e74c3c;
    --purple-color: #9b59b6;
    --background-color: #f5f5f5;
    --card-background: white;
    --text-color: #333;
    --text-muted: #666;
    --border-color: #ddd;
}

/* Nostr Purple – stronger + primary=purple */
[data-theme="nostr-purple"] {
  --primary-color: #7c3aed;      /* purple used by non-reply cards */
  --primary-hover: #6d28d9;
  --secondary-color: #a78bfa;  /* ADD THIS */
  --secondary-hover: #d97706;
  --success-color: #059669;
  --danger-color: #dc2626;
  --purple-color: #7c3aed;       /* replies & accents */
  --background-color: #f3e8ff;
  --card-background: #f3e8ff;
  --text-color: #3b0764;
  --text-muted: #6d28d9;
  --border-color: #c084fc;
}


/* INTENSE Dark Nostr */
[data-theme="dark-nostr"] {
  --primary-color: #8b5cf6;      /* vivid purple */
  --primary-hover: #7c3aed;      /* deeper hover */
  --secondary-color: #a78bfa;    
  --secondary-hover: #d97706;
  --success-color: #22c55e;
  --danger-color:  #ef4444;
  --purple-color:  #a78bfa;      /* soft lavender for replies */
  --background-color: #070712;   /* near-black */
  --card-background: #0f1020;    /* darker cards */
  --text-color: #e6edf7;         /* bright but not pure white */
  --text-muted: #8b82aa; 
  --border-color: #232742;       /* strong edge */
}

/* Dark theme input fixes - higher specificity */
[data-theme="dark-nostr"] #search-input::placeholder,
[data-theme="dark-nostr"] #keyword-input::placeholder,
[data-theme="dark-nostr"] #new-archive-name::placeholder {
    color: #cbd5e1 !important;
}

[data-theme="dark-nostr"] #search-input,
[data-theme="dark-nostr"] #keyword-input,
[data-theme="dark-nostr"] #new-archive-name {
    border-color: #64748b;
    color: #e2e8f0;
}

/* INTENSE Bitcoin Gold */
[data-theme="bitcoin-gold"] {
  --primary-color: #f7931a;      /* official Bitcoin orange */
  --primary-hover: #c76a00;      /* deeper hover shade */
  --secondary-color: #6b4e16;    /* coin bronze */
  --secondary-hover: #4a3410;
  --success-color: #2e8b57;      /* strong green */
  --danger-color: #b22222;       /* vivid red */
  --purple-color: #9b59b6;       /* royal purple accent */
  --background-color: #1a1208;   /* dark brown/black backdrop */
  --card-background: #2b1b0b;    /* warm dark card tone */
  --text-color: #fef3c7;         /* pale gold text */
  --text-muted: #d97706;         /* amber-muted for secondary text */
  --border-color: rgba(247, 147, 26, 0.5); /* semi-transparent Bitcoin orange */
}

/* neon-green Neon Green Theme */
[data-theme="neon-green"] {
  --primary-color: #00ff00;
  --primary-hover: #33ff33;
  --secondary-color: #00ff00;
  --secondary-hover: #33ff33;
  --success-color: #00ff00;
  --danger-color: #ff3333;
  --purple-color: #00ff00;
  --background-color: #000000;
  --card-background: #0a0a0a;
  --text-color: #00ff00;
  --text-muted: #00ff00;
  --border-color: #00aa00;

  /* NEW soft tokens for toned surfaces */
  --accent: #00ff00;
  --accent-border: #00aa00;
  --accent-weak: color-mix(in srgb, var(--accent) 18%, #000);
  --accent-weak-2: color-mix(in srgb, var(--accent) 10%, #000);
}

/* Hide emojis for neon-green theme only - MORE SPECIFIC */
[data-theme="neon-green"] .emoji,
[data-theme="neon-green"] button .emoji,
[data-theme="neon-green"] .tag-filter .emoji {
    display: none !important;
}

/* But keep them visible in other themes */
.emoji {
    display: inline !important;
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

     body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--background-color);
    color: var(--text-color);
    line-height: 1.6;
    font-size: 15px; /* Slightly larger base font */
}

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

     .header h1 {
    font-size: 2.8em;
    margin-bottom: 15px;
    color: var(--primary-color);
    font-weight: 600;
    letter-spacing: -0.02em;
}

        .connection-box {
    background: var(--card-background);
    padding: 40px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    max-width: 500px;
    margin: 0 auto;
}

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }

      .form-group input {
    width: 100%;
    padding: 12px;
    border: 2px solid var(--border-color);
    border-radius: 5px;
    font-size: 14px;
    font-family: monospace;
    background: var(--card-background);
    color: var(--text-color);
}

.form-group input:focus {
    border-color: var(--primary-color);
    outline: none;
}

   /* Loading and transition improvements */
.btn {
    background: var(--primary-color);
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 15px;
    font-weight: 500;
    width: 100%;
    margin-bottom: 12px;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
}

.btn.loading::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
    0% { left: -100%; }
    100% { left: 100%; }
}

.fade-in {
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.slide-up {
    animation: slideUp 0.2s ease-out;
}

/* Toast notifications */
.toast {
    position: fixed;
    top: 20px;
    right: 20px;
    background: var(--card-background);
    color: var(--text-color);
    padding: 16px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border-left: 4px solid var(--success-color);
    z-index: 1001;
    transform: translateX(400px);
    transition: transform 0.3s ease;
}

.toast.show {
    transform: translateX(0);
}

.toast.error {
    border-left-color: var(--danger-color);
}

.toast.warning {
    border-left-color: #f39c12;
}

@keyframes slideUp {
    from { transform: translateY(5px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}


.btn:hover {
    background: var(--primary-hover);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .btn-small {
    padding: 8px 14px;
    font-size: 13px;
    width: auto;
    margin: 0 4px;
    font-weight: 500;
}

.btn-secondary {
    background: var(--text-muted);
    color: white;
}

.btn-secondary:hover {
    background: var(--text-color);
}



        .btn-tiny {
            padding: 2px 6px;
            font-size: 11px;
            min-width: auto;
            width: auto;
            margin: 0;
        }

 /* Better delete button styling for all themes */
.btn-delete {
    background: var(--danger-color) !important;
    color: white !important;
    border: none !important;
    width: 24px !important;
    height: 24px !important;
    border-radius: 50% !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    font-size: 14px !important;
    font-weight: bold !important;
    line-height: 1 !important;
}

/* Neon-green delete button */
[data-theme="neon-green"] .btn-delete {
    background: var(--accent) !important;
    color: #000 !important;
    box-shadow: 0 0 6px rgba(0, 255, 0, 0.4) !important;
}

        .btn-delete:hover {
            background: #c0392b;
        }

        .error {
            background: #e74c3c;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            display: none;
        }

        .success {
            background: #27ae60;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.btn:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
}

.btn-small:hover {
    transform: translateY(-1px);
}

.btn-small:active {
    transform: translateY(0);
}

.quick-filter-btn.active {
    background: var(--primary-color) !important;
    color: white !important;
    transform: translateY(-1px);
    box-shadow: 0 3px 8px rgba(52, 152, 219, 0.3);
}

/* Theme-specific active states */
[data-theme="dark-nostr"] .quick-filter-btn.active {
    background: var(--primary-color) !important;
    box-shadow: 0 3px 8px rgba(139, 92, 246, 0.4);
}

[data-theme="bitcoin-gold"] .quick-filter-btn.active {
    background: var(--primary-color) !important;
    box-shadow: 0 3px 8px rgba(247, 147, 26, 0.4);
}

[data-theme="nostr-purple"] .quick-filter-btn.active {
    background: var(--primary-color) !important;
    box-shadow: 0 3px 8px rgba(124, 58, 237, 0.4);
}

[data-theme="neon-green"] .quick-filter-btn.active {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.6) !important;
}
        
        /* Fix layout so tabs (Original Notes / Replies) don’t overflow */
.app-layout {
  display: grid;
  grid-template-columns: 300px 1fr;
  gap: 20px;
  margin-top: 20px;
}


      .sidebar h4 {
    font-size: 14px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
    margin: 25px 0 12px 0;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}

.sidebar h4:first-of-type {
    margin-top: 0;
}

.sidebar {
    background: var(--card-background);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    height: fit-content;
}

.sidebar-section {
    margin-bottom: 32px;
    padding-bottom: 24px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
}

.sidebar-section:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

.main-content {
    background: var(--card-background);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.note-card {
    background: var(--card-background);
    padding: 24px;
    margin-bottom: 18px;
    border-radius: 12px;
    position: relative;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    transition: all 0.2s ease;
    border: 1px solid rgba(0,0,0,0.06);
    /* Default: Blue border for original notes */
    border-left: 4px solid var(--primary-color);
}

.note-card:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 16px rgba(0,0,0,0.12);
}

/* High specificity rules to override everything */
.note-card.reply-card:not(.archived) {
    border-left: 4px solid var(--purple-color) !important;
}

.note-card:not(.reply-card):not(.archived) {
    border-left: 4px solid var(--primary-color) !important;
}

.note-card.archived {
    border-left: 4px solid var(--success-color) !important;
}

     .note-header {
    font-size: 12px;
    color: var(--text-muted);
    margin-bottom: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

        .note-actions {
            display: flex;
            gap: 5px;
        }

     .note-content {
    white-space: pre-wrap;
    line-height: 1.6;
    margin-bottom: 16px;
    font-size: 14px;
    color: var(--text-color);
}

        .hashtags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

/* Hashtag pills — follow current theme */
/* Unified hashtag styling - follows primary theme color */
.hashtag {
  background: color-mix(in srgb, var(--primary-color) 18%, var(--card-background)) !important;
  border: 1px solid color-mix(in srgb, var(--primary-color) 40%, var(--card-background)) !important;
  color: var(--primary-color) !important;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.15s ease;
  user-select: none;
}

.hashtag:hover {
  background: color-mix(in srgb, var(--primary-color) 32%, var(--card-background)) !important;
  border-color: var(--primary-hover) !important;
  color: #fff !important;
  transform: translateY(-1px);
}

/* Remove ALL the old reply/archived specific rules */
.note-card.reply-card .hashtag,
.note-card.archived .hashtag {
  background: color-mix(in srgb, var(--primary-color) 18%, var(--card-background)) !important;
  border-color: color-mix(in srgb, var(--primary-color) 40%, var(--card-background)) !important;
  color: var(--primary-color) !important;
}

.note-card.reply-card .hashtag:hover,
.note-card.archived .hashtag:hover {
  background: color-mix(in srgb, var(--primary-color) 32%, var(--card-background)) !important;
  border-color: var(--primary-hover) !important;
  color: #fff !important;
}

/* Hashtags in archived cards = success theme */
.note-card.archived .hashtag {
  background: color-mix(in srgb, var(--success-color) 18%, var(--card-background));
  border-color: color-mix(in srgb, var(--success-color) 40%, var(--card-background));
  color: var(--success-color);
}
.note-card.archived .hashtag:hover {
  background: color-mix(in srgb, var(--success-color) 32%, var(--card-background));
  border-color: var(--success-color);
  color: #fff;
}

       .tag-filter {
    display: block;
    width: 100%;
    padding: 8px;
    margin-bottom: 5px;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    text-align: left;
    color: var(--text-color);
}


.tag-filter.active {
    background: var(--primary-color);
    color: white;
}

.tag-filter:hover {
  background: color-mix(in srgb, var(--primary-color) 24%, #fff);
  border-color: var(--primary-color);
}

/* Active state */
.tag-filter.active {
  background: var(--primary-color);
  border-color: var(--primary-color);
  color: #fff;
}

/* Special pills that match your theme variables */
.tag-filter[data-tag="__original"] {
  background: var(--primary-color);
  border-color: var(--primary-color);
  color: #fff;
}
.tag-filter[data-tag="__replies"] {
  background: var(--purple-color);
  border-color: var(--purple-color);
  color: #fff;
}
.tag-filter[data-tag="__replies"].active {
  background: var(--purple-color);
}
.tag-filter[data-tag="__archived"],
.tag-filter[data-tag^="__archive_"] {
  background: var(--success-color);
  border-color: var(--success-color);
  color: #fff;
}


 .archive-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    margin-bottom: 8px;
    background: var(--background-color);
    border-radius: 8px;
    border: 1px solid var(--border-color);
    transition: all 0.2s ease;
}

.archive-item:hover:not(.active) {
    background: var(--card-background);
    border-color: var(--primary-color);
}

.archive-item.active {
    background: var(--success-color);
    border-color: var(--success-color);
    color: white;
}

.archive-name {
    cursor: pointer;
    flex: 1;
    font-size: 14px;
}

.archive-count {
    font-size: 12px;
    color: var(--text-muted);
    margin-right: 8px;
}

        .archive-actions {
            display: flex;
            gap: 5px;
        }

      .loading {
    text-align: center;
    padding: 50px;
    color: var(--text-muted);
}

        .hidden { display: none;
        }

    .search-box {
    width: 100%;
    padding: 12px 16px;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 18px;
    background: var(--card-background);
    color: var(--text-color);
    font-size: 14px;
    transition: border-color 0.2s ease;
}

.search-box:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

       .keyword-input {
    width: 100%;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    margin-bottom: 10px;
    font-size: 14px;
    background: var(--card-background);
    color: var(--text-color);
}

        .info-box {
    background: var(--background-color);
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    font-size: 13px;
    border-left: 3px solid var(--primary-color);
}

       .progress-bar {
  width: 100%;
  height: 20px;
  background: color-mix(in srgb, var(--primary-color) 12%, #ecf0f1);
  border: 1px solid color-mix(in srgb, var(--primary-color) 35%, #ecf0f1);
  border-radius: 10px;
  overflow: hidden;
  margin: 10px 0;
}

.progress-fill {
  height: 100%;
  background: var(--primary-color);             /* follows theme */
  transition: width 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 12px;
}

.archive-options {
    margin: 20px 0;
}

.archive-option {
    padding: 12px 16px;
    margin: 8px 0;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.archive-option:hover {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

/* neon-green archive options */
[data-theme="neon-green"] .archive-option {
    background: var(--accent-weak-2) !important;
    border-color: var(--accent-border) !important;
    color: var(--accent) !important;
}

[data-theme="neon-green"] .archive-option:hover {
    background: var(--accent-weak) !important;
    border-color: var(--accent) !important;
}

        .note-checkbox {
            margin-right: 10px;
            transform: scale(1.2);
        }

       .bulk-controls {
    background: var(--background-color);
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    border: 1px solid var(--border-color);
}

        .bulk-controls.hidden {
            display: none;
        }

    .status-info {
    font-size: 12px;
    color: var(--text-muted);
    margin: 5px 0;
}

/* Prevent sideways scroll caused by long strings */
#pubkey-display,
.note-content,
.note-header,
.archive-name {
  overflow-wrap: anywhere;   /* allow breaks anywhere */
  word-break: break-word;    /* fallback */
  max-width: 100%;
}

/* Keep panels from exceeding container width */
.sidebar,
.main-content {
  max-width: 100%;
}

.archive-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    margin-bottom: 8px;
    background: var(--background-color);
    border-radius: 8px;
    border: 1px solid var(--border-color);
    transition: all 0.2s ease;
    cursor: pointer;
    position: relative;
}

.archive-name {
    flex: 1;
    font-size: 14px;
    pointer-events: none;
}

.archive-count {
    font-size: 12px;
    color: var(--text-muted);
    margin-right: 8px;
    pointer-events: none;
}

.archive-actions {
    display: flex;
    gap: 5px;
    z-index: 10;
}

.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(4px);
    animation: fadeIn 0.2s ease;
}

.modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    padding: 32px;
    border-radius: 12px;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    border: 1px solid var(--border-color);
    transform: scale(0.9);
    animation: modalSlideIn 0.2s ease forwards;
}

@keyframes modalSlideIn {
    to {
        transform: scale(1);
    }
}

.modal-close {
    float: right;
    background: var(--primary-color) !important;
    color: white !important;
    border: none !important;
    padding: 10px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s ease;
}

.modal-close:hover {
    background: var(--primary-hover) !important;
    transform: translateY(-1px);
}

/* Stack on small screens */
@media (max-width: 768px) {
  .app-layout {
    grid-template-columns: 1fr;
  }
}
/* Consistent spacing system */
.mb-1 { margin-bottom: 8px; }
.mb-2 { margin-bottom: 16px; }
.mb-3 { margin-bottom: 24px; }
.mb-4 { margin-bottom: 32px; }

.mt-1 { margin-top: 8px; }
.mt-2 { margin-top: 16px; }
.mt-3 { margin-top: 24px; }
.mt-4 { margin-top: 32px; }

kbd {
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 3px;
    padding: 1px 4px;
    font-size: 11px;
    font-family: monospace;
    color: var(--text-color);
}

.copy-btn {
  border: none;
  padding: 4px 8px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.2s ease;
}

/* Default theme */
.copy-btn {
  background: var(--primary-color);
  color: white;
  border: 1px solid var(--primary-color);
}

.copy-btn:hover {
  background: var(--primary-hover);
  transform: translateY(-1px);
}

/* Dark themes */
[data-theme="dark-nostr"] .copy-btn,
[data-theme="bitcoin-gold"] .copy-btn {
  background: var(--primary-color);
  color: white;
  border: 1px solid var(--primary-color);
}

[data-theme="dark-nostr"] .copy-btn:hover,
[data-theme="bitcoin-gold"] .copy-btn:hover {
  background: var(--primary-hover);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

/* Nostr Purple theme */
[data-theme="nostr-purple"] .copy-btn {
  background: var(--primary-color);
  color: white;
  border: 1px solid var(--primary-color);
}

[data-theme="nostr-purple"] .copy-btn:hover {
  background: var(--primary-hover);
}

/* Neon Green theme */
[data-theme="neon-green"] .copy-btn {
  background: var(--accent-weak-2) !important;
  border: 1px solid var(--accent-border) !important;
  color: var(--accent) !important;
  text-shadow: 0 0 3px var(--accent);
}

[data-theme="neon-green"] .copy-btn:hover {
  background: var(--accent-weak) !important;
  box-shadow: 0 0 6px rgba(0,255,0,0.4) !important;
}

/* Stack Import button + hint with tight spacing */
.import-archive-block {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0 !important;                 /* kill any flex gap */
  margin-bottom: 14px;
}

/* ensure the button above doesn't add extra space */
.import-archive-block > .btn {
  margin: 0 !important;              /* some .btn styles add margin-bottom */
}

/* pull the hint closer to the button */
.import-hint {
  color: var(--text-muted);
  font-size: 11px;
  text-align: center;
  margin-top: 4px !important;        /* force a small, tight gap */
  line-height: 1.15;                 /* compact line height */
}

/* if any generic rule targets .sidebar-section .btn + small, override it */
.sidebar-section .btn + .import-hint {
  margin-top: 4px !important;
}

/* Lazy loading styles */
.note-image {
    max-width: 100%;
    height: auto;
    margin: 10px 0;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: transform 0.2s ease;
}

.note-image:hover {
    transform: scale(1.02);
}

/* Load More button theming */
#load-more-btn {
    background: var(--primary-color) !important;
    color: white !important;
    border: 1px solid var(--primary-color) !important;
}

#load-more-btn:hover {
    background: var(--primary-hover) !important;
    transform: translateY(-1px);
}

/* Neon Green Load More button */
[data-theme="neon-green"] #load-more-btn {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    text-shadow: 0 0 4px var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #load-more-btn:hover {
    background: color-mix(in srgb, var(--accent) 28%, #000) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

.youtube-thumbnail {
    position: relative;
    display: inline-block;
    margin: 10px 0;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    cursor: pointer;
    transition: transform 0.2s ease;
}

.youtube-thumbnail:hover {
    transform: scale(1.02);
}

.youtube-thumbnail img {
    width: 320px;
    height: 180px;
    object-fit: cover;
    display: block;
}

.youtube-thumbnail .play-button {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8);
    color: white;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
}

.youtube-thumbnail .play-button::before {
    content: "▶";
    margin-left: 3px;
}

[data-theme="dark-nostr"] .modal {
    background: rgba(0, 0, 0, 0.8) !important;
}

[data-theme="dark-nostr"] .modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="dark-nostr"] .modal-close {
    background: var(--primary-color) !important;
    color: white !important;
}

[data-theme="dark-nostr"] .modal-close:hover {
    background: var(--primary-hover) !important;
}

[data-theme="bitcoin-gold"] .modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="bitcoin-gold"] .modal-close {
    background: var(--primary-color) !important;
    color: white !important;
}

[data-theme="bitcoin-gold"] .modal-close:hover {
    background: var(--primary-hover) !important;
}

[data-theme="nostr-purple"] .modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="nostr-purple"] .modal-close {
    background: var(--primary-color) !important;
    color: white !important;
}

[data-theme="nostr-purple"] .modal-close:hover {
    background: var(--primary-hover) !important;
}

/* Search input theming for all themes */
#search-input {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

#search-input::placeholder {
    color: var(--text-muted) !important;
}

#search-input:focus {
    border-color: var(--primary-color) !important;
    outline: none;
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
}

/* Remove blue highlight/focus state for npub button on ALL themes */
.npub-copy-btn {
    display: inline;
    background: var(--primary-color);
    color: white;
    border: none;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 11px;
    font-family: monospace;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 0 4px;
    outline: none !important;
    -webkit-tap-highlight-color: transparent !important;
}

.npub-copy-btn:hover {
    background: var(--primary-hover);
    transform: scale(1.05);
}

.npub-copy-btn:active {
    transform: scale(0.95);
    outline: none !important;
}

/* Theme-specific npub button styles */
[data-theme="nostr-purple"] .npub-copy-btn {
    background: var(--purple-color);
    color: white;
    border: 1px solid var(--purple-color);
}

[data-theme="nostr-purple"] .npub-copy-btn:hover {
    background: color-mix(in srgb, var(--purple-color) 80%, #fff);
}

[data-theme="dark-nostr"] .npub-copy-btn {
    background: var(--primary-color);
    color: white;
}

[data-theme="dark-nostr"] .npub-copy-btn:hover {
    background: var(--primary-hover);
}

[data-theme="bitcoin-gold"] .npub-copy-btn {
    background: var(--primary-color);
    color: var(--card-background);
}

[data-theme="bitcoin-gold"] .npub-copy-btn:hover {
    background: var(--primary-hover);
}

[data-theme="neon-green"] .npub-copy-btn {
    background: #003300 !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    font-weight: 600;
    text-shadow: 0 0 3px var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] .npub-copy-btn:hover {
    background: #006600 !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* Prevent button from staying in stuck state */
.npub-copy-btn:disabled {
    opacity: 0.7;
    cursor: not-allowed;
}


/* Dark themes search input fixes */
[data-theme="dark-nostr"] #search-input,
[data-theme="bitcoin-gold"] #search-input,
[data-theme="nostr-purple"] #search-input {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="dark-nostr"] #search-input::placeholder,
[data-theme="bitcoin-gold"] #search-input::placeholder,
[data-theme="nostr-purple"] #search-input::placeholder {
    color: var(--text-muted) !important;
}

/* Date input theming */
[data-theme="dark-nostr"] input[type="date"],
[data-theme="bitcoin-gold"] input[type="date"],
[data-theme="nostr-purple"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="neon-green"] input[type="date"] {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
}

/* More comprehensive date input theming */
input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    border-radius: 4px;
    padding: 6px 8px;
    font-size: 12px;
}

/* Theme-specific date input styling */
[data-theme="dark-nostr"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: dark; /* This helps with native controls */
}

[data-theme="bitcoin-gold"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: dark;
}

[data-theme="nostr-purple"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: dark;
}

[data-theme="neon-green"] input[type="date"] {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    color-scheme: dark;
}

/* Enhanced calendar picker indicator styling */
input[type="date"]::-webkit-calendar-picker-indicator {
    background: transparent;
    bottom: 0;
    cursor: pointer;
    height: auto;
    left: 0;
    position: absolute;
    right: 0;
    top: 0;
    width: auto;
    opacity: 0.8;
}

/* Theme-specific calendar indicators */
[data-theme="dark-nostr"] input[type="date"]::-webkit-calendar-picker-indicator,
[data-theme="bitcoin-gold"] input[type="date"]::-webkit-calendar-picker-indicator,
[data-theme="nostr-purple"] input[type="date"]::-webkit-calendar-picker-indicator {
    filter: invert(1) brightness(0.8);
}

[data-theme="neon-green"] input[type="date"]::-webkit-calendar-picker-indicator {
    filter: invert(1) hue-rotate(120deg) saturate(2) brightness(1.2);
}

/* Focus states */
input[type="date"]:focus {
    border-color: var(--primary-color) !important;
    outline: none;
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
}

[data-theme="neon-green"] input[type="date"]:focus {
    border-color: var(--accent) !important;
    box-shadow: 0 0 0 2px rgba(0, 255, 0, 0.3);
}

/* Fix Nostr Purple theme - should use light color scheme */
[data-theme="nostr-purple"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: light; /* Changed from dark to light */
}

[data-theme="nostr-purple"] input[type="date"]::-webkit-calendar-picker-indicator {
    filter: none; /* Remove the invert filter for light theme */
    opacity: 0.7;
}

/* Neon green search input */
[data-theme="neon-green"] #search-input {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
}

/* Neon green archive name input placeholder */
[data-theme="neon-green"] #new-archive-name::placeholder {
    color: var(--accent) !important;
}

[data-theme="neon-green"] #new-archive-name {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
}

[data-theme="neon-green"] #search-input::placeholder {
    color: color-mix(in srgb, var(--accent) 60%, transparent) !important;
}

[data-theme="neon-green"] #search-input:focus {
    border-color: var(--accent) !important;
    box-shadow: 0 0 0 2px rgba(0, 255, 0, 0.3) !important;
}

body[data-theme="nostr-purple"] .note-card .hashtag:hover,
[data-theme="nostr-purple"] .note-card .hashtag:hover {
  background: color-mix(in srgb, var(--purple-color) 28%, #fff) !important;
}

/* FINAL OVERRIDES — Neon Green hashtag pills (wins everywhere) */
body[data-theme="neon-green"] .note-card .hashtag,
[data-theme="neon-green"] .note-card.reply-card .hashtag,
[data-theme="neon-green"] .note-card.archived .hashtag {
  background: var(--accent-weak-2) !important;
  border: 1px solid var(--accent-border) !important;
  color: var(--accent) !important;
  border-radius: 12px; /* keep pill shape */
}
body[data-theme="neon-green"] .note-card .hashtag:hover,
[data-theme="neon-green"] .note-card.reply-card .hashtag:hover,
[data-theme="neon-green"] .note-card.archived .hashtag:hover {
  background: var(--accent-weak) !important;
}

/* neon-green: buttons */
[data-theme="neon-green"] .btn {
  background: var(--accent-weak);
  color: var(--accent);
  border: 1px solid var(--accent-border);
  text-shadow: 0 0 4px var(--accent);
}
[data-theme="neon-green"] .btn:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000);
  border-color: var(--accent);
}

/* neon-green: hashtags inside notes */
[data-theme="neon-green"] .hashtag {
  background: var(--accent-weak-2);
  border: 1px solid var(--accent-border);
  color: var(--accent);
  border-radius: 12px;
}
[data-theme="neon-green"] .hashtag:hover {
  background: var(--accent-weak);
}

/* neon-green: tag filters in sidebar */
[data-theme="neon-green"] .tag-filter {
  background: var(--accent-weak-2);
  border-color: var(--accent-border);
  color: var(--accent);
}
[data-theme="neon-green"] .tag-filter:hover,
[data-theme="neon-green"] .tag-filter.active {
  background: var(--accent-weak);
  border-color: var(--accent);
  color: var(--accent);
}

/* neon-green: progress bar */
[data-theme="neon-green"] .progress-bar {
  background: var(--accent-weak-2);
  border-color: var(--accent-border);
}
[data-theme="neon-green"] .progress-fill {
  background: var(--accent);
  color: #000;
  text-shadow: none;
}

/* neon-green: utility buttons (refresh, disconnect, clear cache, info, etc.) */
[data-theme="neon-green"] #refresh-btn,
[data-theme="neon-green"] #disconnect-btn,
[data-theme="neon-green"] #clear-cache-btn,
[data-theme="neon-green"] .modal-close {
  background: var(--accent-weak) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 4px var(--accent) !important;
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #refresh-btn:hover,
[data-theme="neon-green"] #disconnect-btn:hover,
[data-theme="neon-green"] #clear-cache-btn:hover,
[data-theme="neon-green"] .modal-close:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000) !important;
  border-color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* neon-green: All remaining buttons - comprehensive fix */
[data-theme="neon-green"] #search-keyword-btn,
[data-theme="neon-green"] #select-all-visible,
[data-theme="neon-green"] #deselect-all,
[data-theme="neon-green"] #select-all-keyword,
[data-theme="neon-green"] #deselect-all-keyword,
[data-theme="neon-green"] #bulk-add-to-archive,
[data-theme="neon-green"] #bulk-remove-from-archive,
[data-theme="neon-green"] #bulk-archive-btn,
[data-theme="neon-green"] #bulk-delete-btn {
  background: var(--accent-weak) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 4px var(--accent) !important;
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #search-keyword-btn:hover,
[data-theme="neon-green"] #select-all-visible:hover,
[data-theme="neon-green"] #deselect-all:hover,
[data-theme="neon-green"] #select-all-keyword:hover,
[data-theme="neon-green"] #deselect-all-keyword:hover,
[data-theme="neon-green"] #bulk-add-to-archive:hover,
[data-theme="neon-green"] #bulk-remove-from-archive:hover,
[data-theme="neon-green"] #bulk-archive-btn:hover,
[data-theme="neon-green"] #bulk-delete-btn:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000) !important;
  border-color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* neon-green: Dropdown selects */
[data-theme="neon-green"] #bulk-archive-dropdown,
[data-theme="neon-green"] #bulk-target-archive {
  background: var(--accent-weak-2) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
}

/* neon-green: Info buttons with inline styles */
[data-theme="neon-green"] button[onclick*="showNoteInfo"] {
  background: var(--accent-weak-2) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 3px var(--accent) !important;
}

/* neon-green: small info buttons */
[data-theme="neon-green"] .btn-small {
background: var(--accent-weak-2) !important;
color: var(--accent) !important;
border: 1px solid var(--accent-border) !important;
text-shadow: 0 0 3px var(--accent) !important;
}
[data-theme="neon-green"] .btn-small:hover {
background: var(--accent-weak) !important;
border-color: var(--accent) !important;
}

/* neon-green: Regular archives (non-active) */
[data-theme="neon-green"] .archive-item {
  background: var(--accent-weak-2) !important;
  border: 1px solid var(--accent-border) !important;
  color: var(--accent) !important;
  box-shadow: none !important;
}

/* neon-green: Only the active archive gets the glow */
[data-theme="neon-green"] .archive-item.active {
  background: var(--accent-weak) !important;
  border: 2px solid var(--accent) !important;
  color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* neon-green: Load More button */
[data-theme="neon-green"] #load-more-btn {
  background: var(--accent-weak) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 4px var(--accent) !important;
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #load-more-btn:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000) !important;
  border-color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

[data-theme="neon-green"] .modal {
    background: rgba(0, 0, 0, 0.8) !important;
}

[data-theme="neon-green"] .modal-content {
    background: var(--card-background) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3) !important;
}

[data-theme="neon-green"] .modal-close {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    text-shadow: 0 0 4px var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] .modal-close:hover {
    background: color-mix(in srgb, var(--accent) 28%, #000) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* Neon green theme override for Import Archive */
[data-theme="neon-green"] #import-btn {
  background: #003300 !important;       /* darker green base */
  border: 1px solid var(--accent-border);
  color: var(--accent);
}

[data-theme="neon-green"] #import-btn:hover {
  background: #006600 !important;       /* brightens on hover */
  box-shadow: 0 0 12px rgba(0,255,0,0.35);
}

/* Hashtag group header hover effects */
.hashtag-group-header:hover {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Fix text color for dark themes */
[data-theme="dark-nostr"] .hashtag-group-header:hover,
[data-theme="bitcoin-gold"] .hashtag-group-header:hover {
    color: var(--card-background) !important;
}

/* Fix hashtag button hover text color for dark themes */
[data-theme="dark-nostr"] .tag-filter:hover,
[data-theme="bitcoin-gold"] .tag-filter:hover {
    color: var(--card-background) !important;
}

/* Neon green theme stays the same */
[data-theme="neon-green"] .hashtag-group-header {
    background: var(--accent-weak-2) !important;
    border-color: var(--accent-border) !important;
    color: var(--accent) !important;
}

[data-theme="neon-green"] .hashtag-group-header:hover {
    background: var(--accent-weak) !important;
    border-color: var(--accent) !important;
    color: var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.3) !important;
}

/* Fix Clear All Filters button theming */
[data-theme="neon-green"] .search-container button[onclick="clearAllFilters()"] {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    text-shadow: 0 0 4px var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] .search-container button[onclick="clearAllFilters()"]:hover {
    background: color-mix(in srgb, var(--accent) 28%, #000) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* Fix hashtag hover colors for dark themes */
[data-theme="dark-nostr"] .tag-filter:hover {
    color: var(--text-color) !important;
    background: color-mix(in srgb, var(--primary-color) 40%, transparent) !important;
}

[data-theme="bitcoin-gold"] .tag-filter:hover {
    color: var(--text-color) !important;
    background: color-mix(in srgb, var(--primary-color) 40%, transparent) !important;
}

/* Hashtag drag selection styles */
.hashtag-selecting {
    cursor: grabbing !important;
}

.hashtag-selecting .hashtag {
    cursor: grabbing !important;
}

/* Improve hashtag hover states during selection */
.hashtag {
    transition: all 0.15s ease;
    user-select: none;
}

.hashtag:hover {
    transform: translateY(-1px);
}

/* Selected hashtag highlighting for Default theme */
.hashtag[data-selected="true"],
body .note-card .hashtag[data-selected="true"] {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Selected hashtag highlighting for Dark Nostr theme */
body[data-theme="dark-nostr"] .note-card .hashtag[data-selected="true"],
[data-theme="dark-nostr"] .note-card .hashtag[data-selected="true"],
body[data-theme="dark-nostr"] .note-card.repost-card .hashtag[data-selected="true"],
body[data-theme="dark-nostr"] .note-card.quote-card .hashtag[data-selected="true"] {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Selected hashtag highlighting for Bitcoin Gold theme */
body[data-theme="bitcoin-gold"] .note-card .hashtag[data-selected="true"],
[data-theme="bitcoin-gold"] .note-card .hashtag[data-selected="true"],
body[data-theme="bitcoin-gold"] .note-card.repost-card .hashtag[data-selected="true"],
body[data-theme="bitcoin-gold"] .note-card.quote-card .hashtag[data-selected="true"] {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Selected hashtag highlighting for Nostr Purple theme */
body[data-theme="nostr-purple"] .note-card .hashtag[data-selected="true"],
[data-theme="nostr-purple"] .note-card .hashtag[data-selected="true"],
body[data-theme="nostr-purple"] .note-card.repost-card .hashtag[data-selected="true"],
body[data-theme="nostr-purple"] .note-card.quote-card .hashtag[data-selected="true"] {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Selected hashtag highlighting for Neon Green theme */
body[data-theme="neon-green"] .note-card .hashtag[data-selected="true"],
[data-theme="neon-green"] .note-card.reply-card .hashtag[data-selected="true"],
[data-theme="neon-green"] .note-card.archived .hashtag[data-selected="true"] {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.6) !important;
}

/* Background loading indicator */
.background-loading-indicator {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--card-background);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px 16px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 1000;
    font-size: 13px;
    color: var(--text-color);
    transform: translateX(300px);
    transition: transform 0.3s ease;
}

.background-loading-indicator.show {
    transform: translateX(0);
}

.background-loading-indicator .progress-text {
    margin-bottom: 4px;
    font-weight: 500;
}

.background-loading-indicator .progress-bar-small {
    width: 200px;
    height: 4px;
    background: var(--background-color);
    border-radius: 2px;
    overflow: hidden;
}

.background-loading-indicator .progress-fill-small {
    height: 100%;
    background: var(--primary-color);
    width: 0%;
    transition: width 0.3s ease;
}

/* Smart loading indicators */
.smart-loading-indicator {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--card-background);
    border: 2px solid var(--primary-color);
    border-radius: 12px;
    padding: 24px 32px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    z-index: 2000;
    text-align: center;
    min-width: 300px;
}

.smart-loading-text {
    font-size: 16px;
    font-weight: 500;
    color: var(--text-color);
    margin-bottom: 12px;
}

.smart-loading-details {
    font-size: 13px;
    color: var(--text-muted);
    margin-bottom: 16px;
}

.smart-progress-bar {
    width: 100%;
    height: 6px;
    background: var(--background-color);
    border-radius: 3px;
    overflow: hidden;
}

.smart-progress-fill {
    height: 100%;
    background: var(--primary-color);
    width: 0%;
    transition: width 0.3s ease;
    animation: smartProgress 2s ease-in-out infinite;
}

@keyframes smartProgress {
    0% { width: 0%; }
    50% { width: 70%; }
    100% { width: 100%; }
}

/* Repost card styling - change to use secondary color */
.note-card.repost-card {
    border-left: 4px solid var(--secondary-color) !important;
}

/* Quote card styling - also use secondary color like reposts */
.note-card.quote-card {
    border-left: 4px solid var(--secondary-color) !important;
}

/* Update theme-specific repost colors to use secondary */
[data-theme="dark-nostr"] .note-card.repost-card {
    border-left: 4px solid var(--secondary-color) !important;
}

[data-theme="bitcoin-gold"] .note-card.repost-card {
    border-left: 4px solid var(--secondary-color) !important;
}

[data-theme="nostr-purple"] .note-card.repost-card {
    border-left: 4px solid var(--secondary-color) !important;
}

[data-theme="neon-green"] .note-card.repost-card {
    border-left: 4px solid var(--secondary-color) !important;
}

/* Theme-specific overrides (these will inherit the secondary color from each theme) */
[data-theme="default"] .note-card.repost-card,
[data-theme="default"] .note-card.quote-card,
[data-theme="dark-nostr"] .note-card.repost-card,
[data-theme="dark-nostr"] .note-card.quote-card,
[data-theme="bitcoin-gold"] .note-card.repost-card,
[data-theme="bitcoin-gold"] .note-card.quote-card,
[data-theme="nostr-purple"] .note-card.repost-card,
[data-theme="nostr-purple"] .note-card.quote-card,
[data-theme="neon-green"] .note-card.repost-card,
[data-theme="neon-green"] .note-card.quote-card {
    border-left: 4px solid var(--secondary-color) !important;
}
    </style>
</head>
<body>
    <div class="container">
        <!-- Connection Screen -->
        <div id="connection-screen">
            <div class="header">
                <h1><span class="emoji">📝</span> Nostr Notes Archive</h1>
                <p>View and organize your Nostr notes</p>
            </div>

            <div class="connection-box">
                <h3 style="text-align: center; margin-bottom: 20px;">Connect Your Account</h3>
                
                <div class="form-group">
               <label>Your Public Key (npub):</label>
<input type="text" id="pubkey-input" placeholder="Enter your npub..." style="font-family:monospace;">
<small style="color: var(--text-muted); font-size:12px;">
                </div>
                
                 <button id="connect-btn" class="btn"><span class="emoji">🔍</span> Load My Notes</button>
                
                <div class="info-box">
                    <strong>How to find your public key:</strong><br>
                    • Damus: Profile → Settings → Account → Public Key<br>
                    • Primal: Settings → Account → Copy public key<br>
                    • Iris: Profile → Copy public key<br>
                    <br>
                    Paste your npub (NIP-19) above.
                </div>

                <div id="connection-error" class="error"></div>
            </div>
        </div>

        <!-- Main App -->
        <div id="main-app" class="hidden">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <div>
                    <h2><span class="emoji">📝</span> My Nostr Archive</h2>
                  <small id="pubkey-display" style="color: var(--text-muted); font-family: monospace;">
                </div>
               <button id="disconnect-btn" style="background: #95a5a6; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
    Disconnect
</button>
            </div>

            <div class="app-layout">
    <div class="sidebar">
        <div class="search-container" style="margin-bottom: 16px;">
    <!-- Main search bar -->
    <div style="margin-bottom: 12px;">
        <input type="text" id="search-input" placeholder="Search notes... (/ to focus)" 
               style="width: 100%; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 4px;">
    </div>
    
    <!-- Quick filters - now toggleable -->
<div class="quick-filters" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; margin-bottom: 12px;">
    <button class="btn btn-tiny quick-filter-btn" data-filter="week" onclick="toggleQuickFilter('week')">This Week</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="month" onclick="toggleQuickFilter('month')">This Month</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="6months" onclick="toggleQuickFilter('6months')">6 Months</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="year" onclick="toggleQuickFilter('year')">This Year</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="images" onclick="toggleQuickFilter('images')">Images</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="youtube" onclick="toggleQuickFilter('youtube')">Videos</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="long" onclick="toggleQuickFilter('long')">Long</button>
</div>
    
    <!-- Date range filters -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
        <div>
            <label style="font-size: 11px; color: var(--text-muted); margin-bottom: 2px; display: block;">FROM DATE</label>
            <input type="date" id="date-from" onchange="applyDateFilters()" 
                   style="width: 100%; padding: 4px 6px; border: 1px solid var(--border-color); border-radius: 3px; font-size: 12px; background: var(--background-color); color: var(--text-color);">
        </div>
        <div>
            <label style="font-size: 11px; color: var(--text-muted); margin-bottom: 2px; display: block;">TO DATE</label>
            <input type="date" id="date-to" onchange="applyDateFilters()"
                   style="width: 100%; padding: 4px 6px; border: 1px solid var(--border-color); border-radius: 3px; font-size: 12px; background: var(--background-color); color: var(--text-color);">
        </div>
    </div>
    
    <!-- Clear filters button -->
    <button class="btn btn-tiny" onclick="clearAllFilters()" style="width: 100%; background: #95a5a6; color: white; border: none;">
        Clear All Filters
    </button>
</div>
        
        <div class="sidebar-section">
            <h4>My Archives</h4>
            <div id="archive-list">
                <!-- Archives will be populated here -->
            </div>
            <div style="margin-top: 15px;">
                <input type="text" id="new-archive-name" class="keyword-input" placeholder="New archive name..." maxlength="30">
               <button id="create-archive-btn" class="btn" style="font-size: 14px; padding: 8px;"><span class="emoji">🗂</span> Create Archive</button>
              </div>
        </div>

        <div class="sidebar-section">
            <h4>Filter by Tags</h4>
            <div id="tag-filters">
                <button class="tag-filter active" data-tag="">All Notes (0)</button>
               <button class="tag-filter" data-tag="__original" style="background: #3498db; color: white;"><span class="emoji">📝</span> Original Notes (0)</button>
               <button class="tag-filter" data-tag="__replies" style="background: #9b59b6; color: white;"><span class="emoji">💬</span> Replies (0)</button>
            </div>
        </div>

        <div class="sidebar-section">
            <h4>Export</h4>
            <button id="export-json" class="btn" style="font-size: 14px; padding: 8px;">Export JSON</button>
            <button id="export-md" class="btn" style="font-size: 14px; padding: 8px;">Export Markdown</button>
        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
        <input type="file" id="import-file" accept=".json,.md,.txt" style="display: none;">
        <div class="import-archive-block">
  <button id="import-btn" class="btn" style="font-size: 14px; padding: 8px; background: #27ae60;">
    <span class="emoji">📁</span> Import Archive
  </button>
  <small class="import-hint">Supports JSON exports from this app</small>
</div>
    </div>
    
    <button id="clear-cache-btn" class="btn" style="font-size: 14px; padding: 8px; background: #e74c3c;"><span class="emoji">🗑️</span> Clear Cache</button>
</div>

<button id="storage-info-btn" class="btn" style="font-size: 14px; padding: 8px;">
    Storage Info
</button>

        <div class="sidebar-section">
    <h4>Keyboard Shortcuts</h4>
    <div style="font-size: 12px; color: var(--text-muted); line-height: 1.4;">
        <div><kbd>/</kbd> or <kbd>Ctrl+K</kbd> Focus search</div>
        <div><kbd>Esc</kbd> Clear search/selections</div>
        <div><kbd>A</kbd> Select all visible</div>
        <div><kbd>Del</kbd> Remove selected</div>
    </div>
</div>

        <div class="sidebar-section">
            <h4>About</h4>
            <button id="app-info-btn" class="btn" style="font-size: 14px; padding: 8px;">
                App Info
            </button>
        </div>
        
        
    <div class="sidebar-section">
            <h4>Theme</h4>
            <select id="theme-selector" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--card-background); color: var(--text-color);">
                <option value="default">Default Blue</option>
                <option value="nostr-purple">Nostr Purple</option>
                <option value="dark-nostr">Dark Nostr</option>
                <option value="bitcoin-gold">Bitcoin Gold</option>
                <option value="neon-green">Neon Green</option>
            </select>
    </div>
</div>


    <div class="main-content">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 32px; padding-bottom: 16px; border-bottom: 1px solid var(--border-color);">
    <div>
        <h3 id="notes-title">All Notes</h3>
        <small id="notes-count" style="color: var(--text-muted);">0 notes</small>
    </div>
   <button id="refresh-btn" style="background: #3498db; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
    <span class="emoji">🔄</span> Refresh
</button>
</div>



                    <div id="bulk-controls" class="bulk-controls hidden">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <span id="selected-count" style="font-weight: bold;">0 notes selected</span>
                            <div>
                                <button id="select-all-visible" class="btn btn-small" style="background: #34495e;">Select All Visible</button>
                                <button id="deselect-all" class="btn btn-small" style="background: #7f8c8d;">Deselect All</button>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                           <select id="bulk-archive-dropdown" style="flex: 1; min-width: 150px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--card-background); color: var(--text-color);">
                                <option value="">Select archive...</option>
                            </select>
                           <button id="bulk-add-to-archive" class="btn btn-small" style="background: #27ae60;"><span class="emoji">📂</span> Add to Archive</button>
                           <button id="bulk-remove-from-archive" class="btn btn-small" style="background: #e74c3c;"><span class="emoji">🗑️</span> Remove from Archive</button>
                        </div>
                    </div>
                  <!-- Loader: ALL loader UI goes inside #loading -->
<div id="loading" class="loading hidden">
<div style="font-size: 24px; margin-bottom: 10px;"><span class="emoji">🔄</span></div>
  <p id="loading-text">Loading your notes...</p>
  <div class="progress-bar">
    <div id="progress-fill" class="progress-fill" style="width: 0%;">0%</div>
  </div>
  <div id="status-info" class="status-info"></div>
</div>


<!-- Notes list lives OUTSIDE the loading box -->
<div id="notes-container"></div>

<div id="load-more-container" class="hidden" style="text-align: center; margin: 20px 0;">
  <button id="load-more-btn" class="btn">Load More Notes</button>
  <div id="pagination-info" style="font-size:14px;">
    Showing 0 of 0 notes
  </div>
</div>


<!-- Empty state also OUTSIDE the loading box -->
<div id="empty-state" class="hidden" style="text-align: center; padding: 50px; color: #666;">
<div style="font-size: 48px; margin-bottom: 20px;"><span class="emoji">📝</span></div>
  <h3>No notes found</h3>
  <p>Make sure you've posted notes to Nostr, or check your public key.</p>
</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentPubkey = null;
        let allNotes = [];
        let filteredNotes = [];
        let archivedNotes = new Set(); // Keep for backward compatibility
        let namedArchives = {}; // New: stores multiple archives { archiveName: Set(noteIds) }
        let currentTag = '';
        let searchQuery = '';
        let currentArchive = 'default'; // Track which archive we're viewing
        let selectedNotes = new Set(); // Track selected notes for bulk operations
        let selectedTags = new Set(); // NEW: multi-select tags
        let notesPerPage = 100;
        let currentPage = 1;

        // Progressive loading state
let isBackgroundLoading = false;
let backgroundLoadingProgress = 0;
let totalNotesExpected = 0;

// IndexedDB setup with Dexie
let db = null;

          // ADD THIS FUNCTION HERE:
        function npubToHex(npub) {
            try {
                if (!window.NostrTools || !window.NostrTools.nip19) {
                    throw new Error('NostrTools library not loaded');
                }
                
                const decoded = window.NostrTools.nip19.decode(npub);
                if (decoded.type !== 'npub') {
                    throw new Error('Not a valid npub');
                }
                
                return decoded.data;
            } catch (error) {
                console.error('Error converting npub to hex:', error);
                return null;
            }
        }

// Normalize pasted npub (strip spaces, prefix, hidden chars)
function normalizeNpub(input) {
  let s = (input || '').trim().toLowerCase();

  // remove spaces/newlines
  s = s.replace(/\s+/g, '');

  // remove nostr: URI prefix if present
  s = s.replace(/^nostr:/, '');

  // remove zero-width characters and BOM
  s = s.replace(/[\u200B-\u200D\uFEFF]/g, '');

  // replace “smart quotes” with plain quotes (just in case)
  s = s.replace(/[‘’]/g, "'").replace(/[“”]/g, '"');

  return s;
}

        // Enhanced relay list with better reliability
    const RELAYS = [
    'wss://relay.snort.social',
    'wss://relay.nostrplebs.com',
    'wss://relay.damus.io',
    'wss://relay.primal.net',
    'wss://offchain.pub',
    'wss://nostr.wine',
    'wss://nostr.land',
    'wss://nos.lol',
    'wss://relay.nostr.band',
     'wss://purplepag.es',   
    'wss://nostr.mom',
    'wss://relayable.org',          
    'wss://relay.orangepill.dev'    
];

        // Initialize the app
      document.addEventListener('DOMContentLoaded', function () {
    setupEventListeners();
    setupKeyboardShortcuts();
    setupHashtagDragSelection();

  // Auto-login if we have a saved npub
  const savedNpub = localStorage.getItem('nostr-saved-npub');
  if (savedNpub) {
    document.getElementById('pubkey-input').value = savedNpub;
    connectWithPubkey();
  }
});

        function setupEventListeners() {
            document.getElementById('connect-btn').addEventListener('click', connectWithPubkey);
            document.getElementById('disconnect-btn').addEventListener('click', disconnect);
            document.getElementById('storage-info-btn').addEventListener('click', showStorageInfo);

          // Add null check for app-info-btn
            const appInfoBtn = document.getElementById('app-info-btn');
            if (appInfoBtn) {
                appInfoBtn.addEventListener('click', showAppInfo);
            }    

           // Add null checks for import elements
    const importBtn = document.getElementById('import-btn');
    const importFile = document.getElementById('import-file');
    
    if (importBtn) importBtn.addEventListener('click', triggerFileImport);
    if (importFile) importFile.addEventListener('change', handleFileImport);

            // NEW: allow pressing Enter in the npub box to connect
const pubkeyInput = document.getElementById('pubkey-input');
pubkeyInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    connectWithPubkey();
  }
});

           // IMPROVEMENT 3: Debounced search for better performance
let searchTimeout;
document.getElementById('search-input').addEventListener('input', function(e) {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => handleSearch(e), 300);
});
            document.getElementById('refresh-btn').addEventListener('click', refreshNotes);
            document.getElementById('export-json').addEventListener('click', exportAsJSON);
            document.getElementById('export-md').addEventListener('click', exportAsMarkdown);
            document.getElementById('create-archive-btn').addEventListener('click', createNewArchive);
            document.getElementById('new-archive-name').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        createNewArchive();
    }
});
            document.getElementById('clear-cache-btn').addEventListener('click', clearAllCache);
            document.getElementById('load-more-btn').addEventListener('click', loadMoreNotes);
            
            
            // Bulk controls for main view
            document.getElementById('select-all-visible').addEventListener('click', selectAllVisible);
            document.getElementById('deselect-all').addEventListener('click', deselectAll);
            document.getElementById('bulk-add-to-archive').addEventListener('click', bulkAddToArchive);
            document.getElementById('bulk-remove-from-archive').addEventListener('click', bulkRemoveFromArchive);
        }

        function setupHashtagDragSelection() {
    const tagFiltersEl = document.getElementById('tag-filters');
    if (!tagFiltersEl) return;
    
    // Remove any existing listeners to prevent duplicates
    if (tagFiltersEl.__dragSetup) return;
    
    // Handle mousedown on hashtag buttons only
    tagFiltersEl.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // Left mouse button only
        
        const btn = e.target.closest('.tag-filter');
        if (!btn) return;
        
        const tag = btn.dataset.tag;
        if (!tag || !tag.startsWith('#')) return; // Only hashtags, not special buttons
        
        startHashtagSelection(tag, e);
    });
    
    // Handle mouseover for dragging
    tagFiltersEl.addEventListener('mouseover', (e) => {
        if (!isSelecting) return;
        
        const btn = e.target.closest('.tag-filter');
        if (!btn) return;
        
        const tag = btn.dataset.tag;
        if (!tag || !tag.startsWith('#')) return;
        
        continueHashtagSelection(tag, e);
    });
    
    tagFiltersEl.__dragSetup = true; // Prevent duplicate setup
}

        function loadArchivedNotes() {
    if (!currentPubkey) return; // Don't load if no user connected
    
    try {
        // Load legacy archive for backward compatibility
        const saved = localStorage.getItem(`nostr-archived-notes-${currentPubkey}`);
        if (saved) {
            archivedNotes = new Set(JSON.parse(saved));
        } else {
            archivedNotes = new Set();
        }
        
        // Load named archives
        const savedArchives = localStorage.getItem(`nostr-named-archives-${currentPubkey}`);
        if (savedArchives) {
            const parsed = JSON.parse(savedArchives);
            namedArchives = {};
            Object.keys(parsed).forEach(name => {
                namedArchives[name] = new Set(parsed[name]);
            });
        } else {
            namedArchives = {};
        }
        
        // Migration logic (only for this specific user)
        if (archivedNotes.size > 0 && !namedArchives['My Archive']) {
            namedArchives['My Archive'] = new Set([...archivedNotes]);
            archivedNotes.clear();
            saveArchivedNotes();
        }
    } catch (error) {
        console.error('Error loading archived notes:', error);
        namedArchives = {};
        archivedNotes = new Set();
    }
}

// IMPROVEMENT: Keyboard shortcuts
function setupKeyboardShortcuts() {
    document.addEventListener('keydown', function(e) {
        // Don't trigger shortcuts when typing in inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            // Exception: Escape should work even in inputs
            if (e.key === 'Escape') {
                e.target.blur();
                if (e.target.id === 'search-input') {
                    e.target.value = '';
                    handleSearch();
                }
            }
            return;
        }

         // NEW: allow Enter to submit npub on the connection screen
  if (e.key === 'Enter') {
    const connectionScreen = document.getElementById('connection-screen');
    const pubkeyInput = document.getElementById('pubkey-input');

    if (
      connectionScreen && pubkeyInput &&
      !connectionScreen.classList.contains('hidden') &&
      (document.activeElement === pubkeyInput || pubkeyInput.value.trim())
    ) {
      e.preventDefault();
      connectWithPubkey();
      return; // handled
    }
  }


        // Prevent default for handled shortcuts
        const handled = true;

        switch(e.key) {
            case '/':
                e.preventDefault();
                document.getElementById('search-input').focus();
                break;
                
            case 'Escape':
    // Always clear everything and go back to "All Notes" state
    const searchInput = document.getElementById('search-input');
    
    // Clear search input
    searchInput.value = '';
    searchQuery = '';
    
    // Clear ALL filters and states
    activeQuickFilters.clear();
    selectedTags.clear();
    currentTag = '';
    currentArchive = 'default';
    
    // Clear all UI active states
    document.querySelectorAll('.quick-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    document.querySelectorAll('.tag-filter').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.tag === '') {
            btn.classList.add('active');
        }
    });
    
    // Clear date filters
    document.getElementById('date-from').value = '';
    document.getElementById('date-to').value = '';
    
    // Clear selections
    deselectAll();
    
    // Force reset to all notes
    filteredNotes = allNotes.slice();
    resetPagination();
    renderNotes();
    
    // Reset title and count
    document.getElementById('notes-title').textContent = 'All Notes';
    document.getElementById('notes-count').textContent = `${allNotes.length} notes`;
    
    // Blur the search input
    searchInput.blur();
    break;
                
            case 'k':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    document.getElementById('search-input').focus();
                }
                break;
                
            case 'a':
                if (!e.ctrlKey && !e.metaKey) {
                    // Toggle select all visible notes
                    if (selectedNotes.size > 0) {
                        deselectAll();
                    } else {
                        selectAllVisible();
                    }
                }
                break;
                
            case 'Delete':
            case 'Backspace':
                if (selectedNotes.size > 0) {
                    e.preventDefault();
                    if (confirm(`Remove ${selectedNotes.size} selected notes from all archives?`)) {
                        bulkRemoveFromArchive();
                    }
                }
                break;
                
                
            default:
                return; // Don't prevent default for unhandled keys
        }
    });
}

function saveArchivedNotes() {
    if (!currentPubkey) return; // Don't save if no user connected
    try {
        // Save legacy for backward compatibility
        localStorage.setItem(`nostr-archived-notes-${currentPubkey}`, JSON.stringify([...archivedNotes]));

        // Save named archives (convert Sets to arrays for JSON)
        const toSave = {};
        Object.keys(namedArchives).forEach(name => {
            toSave[name] = [...namedArchives[name]];
        });
        localStorage.setItem(`nostr-named-archives-${currentPubkey}`, JSON.stringify(toSave));
    } catch (error) {
        console.error('Error saving archived notes:', error);
    }
}

        function createNewArchive() {
    const name = document.getElementById('new-archive-name').value.trim();
    if (!name) {
        showToast('Please enter an archive name', 'error');
        return;
    }
    
    if (namedArchives[name]) {
        showToast('Archive with this name already exists', 'error');
        return;
    }
    
    namedArchives[name] = new Set();
    saveArchivedNotes();
    updateArchiveList();
    updateTargetArchiveDropdown();
    
    document.getElementById('new-archive-name').value = '';
    showToast(`Archive "${name}" created successfully!`, 'success');
}

        function deleteArchive(archiveName) {
            if (confirm(`Are you sure you want to delete the archive "${archiveName}"? This cannot be undone.`)) {
                delete namedArchives[archiveName];
                saveArchivedNotes();
                updateArchiveList();
                updateTargetArchiveDropdown();
                
                // If we were viewing the deleted archive, switch to all notes
                if (currentArchive === archiveName) {
                    filterByTag('');
                }
            }
        }

       function viewArchive(archiveName) {
    // Check if we're already viewing this archive - if so, go back to All Notes
    if (currentArchive === archiveName) {
        // Reset to All Notes view
        currentArchive = 'default';
        currentTag = '';
        selectedTags.clear(); // ADDED: Clear hashtag selections
        
        // Clear all active states
        document.querySelectorAll('.archive-item').forEach(item => {
            item.classList.remove('active');
        });
        
        // Set "All Notes" as active in tag filters
        document.querySelectorAll('.tag-filter').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.tag === '') {
                btn.classList.add('active');
            }
        });
        
        // Use the existing filterByTag function to properly reset to all notes
        filterByTag('');
        
        return; // Exit early
    }
    
    // Normal archive selection
    currentArchive = archiveName;
    currentTag = '__archive_' + archiveName;
    selectedTags.clear(); // ADDED: Clear hashtag selections when switching to archive
    
    // Clear all active states first
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Clear tag filters active states
    document.querySelectorAll('.tag-filter').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Use the existing filterByTag function
    filterByTag('__archive_' + archiveName);
    
    // Force update the archive list to show correct active state
    updateArchiveList();
}

        function updateArchiveList() {
    const container = document.getElementById('archive-list');
    if (!container) return;
    
    if (Object.keys(namedArchives).length === 0) {
        container.innerHTML = '<div style="color: #666; font-style: italic; font-size: 13px;">No archives created yet</div>';
        return;
    }
    
    container.innerHTML = Object.keys(namedArchives).map(name => {
        const count = namedArchives[name].size;
        const isActive = currentArchive === name;
        
        return `
            <div class="archive-item ${isActive ? 'active' : ''}" onclick="viewArchive('${name}')">
                <div class="archive-name">${escapeHtml(name)}</div>
                <div class="archive-count">(${count})</div>
                <div class="archive-actions" onclick="event.stopPropagation();">
                    <button class="btn btn-tiny btn-delete" onclick="deleteArchive('${name}')">×</button>
                </div>
            </div>
        `;
    }).join('');
}

        function updateTargetArchiveDropdown() {
    const bulkArchiveDropdown = document.getElementById('bulk-archive-dropdown');
    
    const archiveOptions = '<option value="">Select archive...</option>' +
        Object.keys(namedArchives).map(name => 
            `<option value="${name}">${escapeHtml(name)}</option>`
        ).join('');
    
    if (bulkArchiveDropdown) bulkArchiveDropdown.innerHTML = archiveOptions;
}

        function toggleArchiveNote(noteId, archiveName = null) {
            // If no specific archive is provided, show archive selection
            if (!archiveName && Object.keys(namedArchives).length > 0) {
                showArchiveSelectionModal(noteId);
                return;
            }
            
            // Legacy behavior - add to default archive
            if (archivedNotes.has(noteId)) {
                archivedNotes.delete(noteId);
                // Also remove from all named archives
                Object.keys(namedArchives).forEach(name => {
                    namedArchives[name].delete(noteId);
                });
            } else {
                // Add to "My Archive" if it exists, otherwise create it
                if (!namedArchives['My Archive']) {
                    namedArchives['My Archive'] = new Set();
                }
                namedArchives['My Archive'].add(noteId);
            }
            
            saveArchivedNotes();
            renderNotes();
            updateTagFilters();
            updateArchiveList();
        }

        function addToArchive(noteId, archiveName) {
            if (!namedArchives[archiveName]) {
                namedArchives[archiveName] = new Set();
            }
            
            namedArchives[archiveName].add(noteId);
            
            saveArchivedNotes();
            renderNotes();
            updateTagFilters();
            updateArchiveList();
        }

        function showArchiveSelectionModal(noteId) {
    const archiveNames = Object.keys(namedArchives);
    if (archiveNames.length === 0) {
       showToast('Please create an archive first');
        return;
    }
    
    // Create custom modal HTML
    const optionsList = archiveNames.map((name, index) => 
        `<div class="archive-option" data-index="${index}" onclick="selectArchiveOption(${index}, '${noteId}')">
            ${index + 1}. ${escapeHtml(name)}
        </div>`
    ).join('');
    
    const modalHtml = `
        <div class="modal" onclick="closeArchiveModal(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeArchiveModal()">×</button>
                <h3>Select archive for this note:</h3>
                <div class="archive-options">
                    ${optionsList}
                </div>
                <div style="margin-top: 20px; text-align: center;">
                    <button class="btn btn-small" onclick="closeArchiveModal()">Cancel</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function selectArchiveOption(index, noteId) {
    const archiveNames = Object.keys(namedArchives);
    if (index >= 0 && index < archiveNames.length) {
        addToArchive(noteId, archiveNames[index]);
        showToast(`Note added to "${archiveNames[index]}" archive!`, 'success');
    }
    closeArchiveModal();
}

function closeArchiveModal(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

        // Bulk operations for main view
        function toggleNoteSelection(noteId) {
            if (selectedNotes.has(noteId)) {
                selectedNotes.delete(noteId);
            } else {
                selectedNotes.add(noteId);
            }
            updateSelectionUI();
        }

        function selectAllVisible() {
            filteredNotes.forEach(note => selectedNotes.add(note.id));
            updateSelectionUI();
            renderNotes();
        }

        function deselectAll() {
            selectedNotes.clear();
            updateSelectionUI();
            renderNotes();
        }

        function bulkAddToArchive() {
            const targetArchive = document.getElementById('bulk-archive-dropdown').value;
           if (!targetArchive) {
    showToast('Please select a target archive', 'error');
    return;
}

            if (selectedNotes.size === 0) {
                showToast('Please select some notes first');
                return;
            }

            let addedCount = 0;
            selectedNotes.forEach(noteId => {
                if (!namedArchives[targetArchive].has(noteId)) {
                    namedArchives[targetArchive].add(noteId);
                    addedCount++;
                }
            });

            saveArchivedNotes();
            updateArchiveList();
            updateTagFilters();
            selectedNotes.clear();
            updateSelectionUI();
            renderNotes();

            showToast(`Added ${addedCount} notes to "${targetArchive}" archive`, 'success');
        }

        function bulkRemoveFromArchive() {
            if (selectedNotes.size === 0) {
               showToast('Please select some notes first');
                return;
            }

            let removedCount = 0;
            selectedNotes.forEach(noteId => {
                Object.keys(namedArchives).forEach(archiveName => {
                    if (namedArchives[archiveName].has(noteId)) {
                        namedArchives[archiveName].delete(noteId);
                        removedCount++;
                    }
                });
                archivedNotes.delete(noteId);
            });

            saveArchivedNotes();
            updateArchiveList();
            updateTagFilters();
            selectedNotes.clear();
            updateSelectionUI();
            renderNotes();

            showToast(`Removed ${removedCount} notes from all archives`, 'success');
        }

        function updateSelectionUI() {
            const bulkControls = document.getElementById('bulk-controls');
            const selectedCount = document.getElementById('selected-count');
            
            if (selectedNotes.size > 0) {
                bulkControls.classList.remove('hidden');
                selectedCount.textContent = `${selectedNotes.size} notes selected`;
            } else {
                bulkControls.classList.add('hidden');
            }
        }

       async function connectWithPubkey() {
    // Force fresh fetch
    useIndexedDB = true;
    
    const connectBtn = document.getElementById('connect-btn');
    connectBtn.classList.add('loading');
    connectBtn.disabled = true;
    connectBtn.textContent = 'Connecting...';

    // Check if NostrTools is available
    if (!window.NostrTools) {
        showError('NostrTools library not loaded. Please refresh the page.');
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Load My Notes';
        return;
    }
    
    const raw = document.getElementById('pubkey-input').value;
    const npub = normalizeNpub(raw);

    if (!npub) {
        showError('Please enter your npub');
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Load My Notes';
        return;
    }
    
    if (!npub.startsWith('npub1')) {
        showError('Invalid npub (must start with "npub1")');
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Load My Notes';
        return;
    }

    if (!/^npub1[02-9ac-hj-np-z]+$/.test(npub)) {
        showError('Invalid npub format');
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Load My Notes';
        return;
    }

    const hexPubkey = npubToHex(npub);
    if (!hexPubkey || hexPubkey.length !== 64) {
        showError('Invalid npub format - could not convert to hex');
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Load My Notes';
        return;
    }

    currentPubkey = hexPubkey.toLowerCase();

    // Clear any previous data when switching users
    allNotes = [];
    filteredNotes = [];
    selectedTags.clear();
    currentTag = '';

    // Clear all filters when switching users
    activeQuickFilters.clear();
    document.querySelectorAll('.quick-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    // Clear date filters
    document.getElementById('date-from').value = '';
    document.getElementById('date-to').value = '';

    // Clear search
    document.getElementById('search-input').value = '';
    searchQuery = '';

    // Clear hashtag active states
    document.querySelectorAll('.tag-filter').forEach(btn => {
        btn.classList.remove('active');
    });

    // Reset archive states
    currentArchive = 'default';
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });

    document.getElementById('tag-filters').innerHTML = '<button class="tag-filter active" data-tag="">Loading...</button>';

    // Load archives for this specific user
    loadArchivedNotes();
    updateArchiveList();

    // Save the npub for next time
    localStorage.setItem('nostr-saved-npub', npub);

    document.getElementById('connection-screen').classList.add('hidden');
    document.getElementById('main-app').classList.remove('hidden');

    document.getElementById('pubkey-display').textContent = 
        npub.substring(0, 12) + '...' + npub.substring(npub.length - 8);
    
    updateArchiveList();
    updateTargetArchiveDropdown();
    
    // SIMPLIFIED LOADING LOGIC - No size detection
    let notes;
    let loadedFromChunkCache = false;
    let cachedChunkStats = null;
    
    try {
        showLoading(true);
        updateProgress(0, 'Connecting to relays...');
        updateStatus('Starting fresh load...', true);
        
        // Check if we have stored chunks first
        updateProgress(5, 'Checking for stored data...');
        
        const chunkStorage = new ChunkedNoteStorage(currentPubkey);
        const chunkReady = await chunkStorage.init();
        
        if (chunkReady) {
            const chunkStats = await chunkStorage.getStats();
            
            if (chunkStats && chunkStats.totalNotes > 0) {
                // Load from stored chunks
                loadedFromChunkCache = true;
                cachedChunkStats = chunkStats;
                updateProgress(15, `Loading all ${chunkStats.totalNotes} notes from storage...`);
                updateStatus(`Found stored data: ${chunkStats.totalChunks} chunks, ${chunkStats.totalNotes} notes`);
                
                notes = await loadNotesHybrid(currentPubkey, false);
                showToast(`Loaded ${notes.length} notes from storage instantly!`, 'success');
                updateStatus(`Loaded ${notes.length} notes from ${chunkStats.totalChunks} stored chunks`);
            } else {
                // No stored data - use progressive loading (QUICK FIX)
                updateProgress(15, 'Loading recent notes...');
                updateStatus('Loading recent notes first for faster startup...');
                
                notes = await loadRecentNotesOnly(currentPubkey, 90); // 90 days
                showToast(`Loaded ${notes.length} recent notes. Full history loading in background.`, 'success');
                updateStatus(`Loaded ${notes.length} recent notes - background loading full history...`);
            }
        } else {
            // Storage unavailable - use progressive loading
            updateProgress(15, 'Loading recent notes...');
            updateStatus('Loading recent notes first...');
            
            notes = await loadRecentNotesOnly(currentPubkey, 90);
            showToast(`Loaded ${notes.length} recent notes. Full history loading in background.`, 'success');
        }
        
        updateStatus(`Sorting ${notes.length} notes by date...`);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        allNotes = notes.sort((a, b) => b.created_at - a.created_at);
        
        updateStatus('Updating archives list...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        updateArchiveList();
        updateTargetArchiveDropdown();
        
        updateStatus('Updating tag filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        updateTagFilters();
        
        updateStatus('Applying filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        applyFilters();
        
        updateStatus('Rendering notes...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        renderNotes();
        
        // Always schedule background loading to get complete history
        if (!loadedFromChunkCache) {
            const estimatedTotal = notes.length * 5;
            scheduleBackgroundLoading(currentPubkey, { estimatedTotal });
        } else {
            // Refresh cached chunks in background
            const estimatedTotal = (cachedChunkStats && cachedChunkStats.totalNotes) || notes.length;
            scheduleBackgroundLoading(currentPubkey, { estimatedTotal });
        }
        
        updateStatus(`✅ Successfully loaded ${allNotes.length} notes!`);
        
    } catch (error) {
        console.error('Error loading notes:', error);
        showError('Failed to load notes: ' + error.message);
    } finally {
        showLoading(false);
        trackLoadTime();
        
        // Reset button after completion
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Load My Notes';
    }
}
    

        // Add these global variables at the top of your script
let isLoadingCancelled = false;
let activeWebSockets = new Set();
let backgroundLoadingTimeout = null;

// Update the disconnect function to cancel ongoing operations
function disconnect() {
    // Set cancellation flag FIRST
    isLoadingCancelled = true;
    
    // Cancel any background loading
    if (backgroundLoadingTimeout) {
        clearTimeout(backgroundLoadingTimeout);
        backgroundLoadingTimeout = null;
    }
    
    // Close all active WebSocket connections
    activeWebSockets.forEach(ws => {
        if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
            ws.close(1000, 'User disconnected');
        }
    });
    activeWebSockets.clear();
    
    // Hide any loading indicators
    hideBackgroundLoadingIndicator();
    showLoading(false);
    
    // Store the old pubkey before clearing
    const oldPubkey = currentPubkey;
    
    // Reset all variables
    currentPubkey = null;
    allNotes = [];
    filteredNotes = [];
    currentArchive = 'default';
    selectedTags.clear();
    currentTag = '';
    selectedNotes.clear();
    searchQuery = '';

    // Clear all filters on disconnect
    activeQuickFilters.clear();
    document.querySelectorAll('.quick-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.getElementById('date-from').value = '';
    document.getElementById('date-to').value = '';
    document.getElementById('search-input').value = '';
    searchQuery = '';
    
    // Clear localStorage cache data only
    localStorage.removeItem('nostr-last-pubkey');
    localStorage.removeItem('nostr-cached-notes'); 
    localStorage.removeItem('nostr-cache-updated-at');
    localStorage.removeItem('nostr-saved-npub');
    
    // Clear the UI immediately
    document.getElementById('notes-container').innerHTML = '';
    document.getElementById('tag-filters').innerHTML = '<button class="tag-filter active" data-tag="">All Notes (0)</button>';
    document.getElementById('notes-count').textContent = '0 notes';
    document.getElementById('archive-list').innerHTML = '<div style="color: #666; font-style: italic; font-size: 13px;">No archives created yet</div>';

    // Clear pagination state
    document.getElementById('load-more-container').classList.add('hidden');
    document.getElementById('pagination-info').textContent = 'Showing 0 of 0 notes';
    
    document.getElementById('main-app').classList.add('hidden');
    document.getElementById('connection-screen').classList.remove('hidden');
    document.getElementById('pubkey-input').value = '';

    hideError();

// Reset cancellation flag after cleanup
    isLoadingCancelled = false;
}

// IndexedDB fallback handler
let useIndexedDB = true;

function disableIndexedDB(error) {
    console.warn('IndexedDB disabled due to error:', error);
    useIndexedDB = false;
    showToast('Storage limitation detected - using memory-only mode', 'warning');
    
    // Log the error type for debugging
    if (error.name === 'QuotaExceededError') {
        showToast('Storage quota exceeded - consider clearing old data', 'warning');
    } else if (error.name === 'InvalidStateError') {
        console.log('Database state error - likely corruption or version mismatch');
    }
}

async function initDatabase(pubkey) {
    if (!useIndexedDB) return null;
    
    try {
        const dbName = `nostr-notes-${pubkey}`;
        
        if (db && db.isOpen()) {
            db.close();
        }
        
        db = new Dexie(dbName);
        db.version(1).stores({
            notes: 'id, pubkey, created_at, content, *hashtags, isReply, isRepost, isQuote, kind', // ADD isRepost, isQuote, kind
            settings: 'key, value'
        });
        
        await db.open();
        return db;
    } catch (error) {
        disableIndexedDB(error);
        return null;
    }
}

function clearLegacyCache(pubkey) {
    try {
        localStorage.removeItem(`nostr-last-pubkey-${pubkey}`);
        localStorage.removeItem(`nostr-cached-notes-${pubkey}`);
        localStorage.removeItem(`nostr-cache-updated-at-${pubkey}`);
    } catch (error) {
        console.warn('Could not clear legacy cache:', error);
    }
}

async function fetchNotesFromRelays(pubkey) {
    const uniqueEventsMap = new Map(); // Deduplicate as we go
    const completedRelays = [];
    
    console.log('=== STARTING RELAY FETCH ===');
    
    const relayStatuses = new Map();
    const relayPromises = RELAYS.map(async (relay, index) => {
        const relayName = relay.replace('wss://', '');
        relayStatuses.set(relay, 'connecting');
        
        try {
            updateStatus(`<span class="emoji">🔄</span> ${relayName}: Connecting.`);
            
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => {
                    relayStatuses.set(relay, 'timeout');
                    reject(new Error('Timeout after 60s'));
                }, 60000);
            });
            
            const fetchPromise = fetchAllNotesFromRelay(relay, pubkey, (progress, status) => {
                relayStatuses.set(relay, 'fetching');
                const completedCount = Array.from(relayStatuses.values()).filter(s => s === 'completed' || s === 'failed').length;
                updateProgress(
                    20 + ((completedCount / RELAYS.length) * 60), 
                    `${relayName}: ${status} | ${completedCount}/${RELAYS.length} relays done`
                );
            });
            
            const events = await Promise.race([fetchPromise, timeoutPromise]);
            
            // DEDUPLICATE IMMEDIATELY per relay
            let newCount = 0;
            events.forEach(event => {
                if (event?.id && !uniqueEventsMap.has(event.id)) {
                    uniqueEventsMap.set(event.id, event);
                    newCount++;
                }
            });
            
            relayStatuses.set(relay, 'completed');
            const completedCount = Array.from(relayStatuses.values()).filter(s => s === 'completed').length;
            updateStatus(`<span class="emoji">✅</span> ${relayName}: ${newCount} new notes (${uniqueEventsMap.size} total unique) (${completedCount}/${RELAYS.length} relays done)`);
            
            completedRelays.push(relay);
            return { relay, events, success: true };
            
        } catch (error) {
            relayStatuses.set(relay, 'failed');
            const failedCount = Array.from(relayStatuses.values()).filter(s => s === 'failed').length;
            updateStatus(`❌ ${relayName}: ${error.message} (${failedCount} failed)`);
            return { relay, events: [], success: false, error: error.message };
        }
    });
    
    // Wait for ALL relays to finish
    await Promise.allSettled(relayPromises);
    
    const uniqueEvents = Array.from(uniqueEventsMap.values());
console.log(`=== DEDUPLICATION COMPLETE: ${uniqueEvents.length} unique notes ===`);
updateStatus(`✅ Found ${uniqueEvents.length} unique notes across all relays`);

return uniqueEvents;
}

// NEW: Memory-efficient deduplication for image-heavy accounts
async function memoryEfficientDeduplication(allEvents) {
    console.log(`Starting deduplication of ${allEvents.length} events`);
    
    const uniqueEventsMap = new Map();
    const chunkSize = 2000; // Process in smaller chunks for image-heavy accounts
    let duplicatesFound = 0;
    
    for (let startIndex = 0; startIndex < allEvents.length; startIndex += chunkSize) {
        const endIndex = Math.min(startIndex + chunkSize, allEvents.length);
        const chunk = allEvents.slice(startIndex, endIndex);
        
        console.log(`Processing chunk ${Math.floor(startIndex/chunkSize) + 1}: events ${startIndex}-${endIndex}`);
        
        chunk.forEach(event => {
            if (!event?.id) return;
            
            const existing = uniqueEventsMap.get(event.id);
            if (!existing) {
                uniqueEventsMap.set(event.id, event);
            } else {
                duplicatesFound++;
                // Keep the event with more complete data
                if ((event.tags?.length || 0) > (existing.tags?.length || 0) || 
                    event.content.length > existing.content.length) {
                    uniqueEventsMap.set(event.id, event);
                }
            }
        });
        
        // Update progress and yield control
        const progress = 80 + ((endIndex / allEvents.length) * 15);
        updateProgress(progress, `Deduplicating: ${endIndex}/${allEvents.length} processed (${duplicatesFound} duplicates found)`);
        
        // Yield control to prevent browser freeze
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Memory cleanup
        if (startIndex % 10000 === 0 && performance.memory) {
            const memoryMB = performance.memory.usedJSHeapSize / 1024 / 1024;
            console.log(`Memory usage: ${memoryMB.toFixed(1)} MB`);
            if (memoryMB > 500) {
                console.log('High memory usage detected, forcing garbage collection pause');
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
    }
    
    const uniqueEvents = Array.from(uniqueEventsMap.values());
console.log(`=== DEDUPLICATION COMPLETE: ${uniqueEvents.length} unique notes ===`);
updateStatus(`✅ Found ${uniqueEvents.length} unique notes across all relays`);

return uniqueEvents;
}

async function fetchNotesFromRelaysSince(pubkey, sinceTimestamp) {
    const allEvents = [];
    const completedRelays = [];
    
    updateStatus('🔄 Checking relays for new notes...');
    
    const relayPromises = RELAYS.map(async (relay, index) => {
        const relayName = relay.replace('wss://', '');
        
        try {
            // Only fetch notes newer than our newest stored note
            const newNotes = await fetchNewNotesFromRelay(relay, pubkey, sinceTimestamp);
            
            updateStatus(`✅ ${relayName}: ${newNotes.length} new notes`);
            return { relay, events: newNotes, success: true };
            
        } catch (error) {
            updateStatus(`❌ ${relayName}: ${error.message}`);
            return { relay, events: [], success: false };
        }
    });
    
    const results = await Promise.allSettled(relayPromises);
    
    // Collect new events
    results.forEach((result) => {
        if (result.status === 'fulfilled' && result.value.success) {
            allEvents.push(...result.value.events);
        }
    });
    
    // Simple deduplication for new notes
    const uniqueEvents = [];
    const seenIds = new Set();
    
    allEvents.forEach(event => {
        if (event.id && !seenIds.has(event.id)) {
            seenIds.add(event.id);
            uniqueEvents.push(event);
        }
    });
    
    return uniqueEvents;
}

async function fetchNewNotesFromRelay(relayUrl, pubkey, sinceTimestamp) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        const events = [];
        let timeoutId;
        
        ws.onopen = function() {
            const filter = {
    kinds: [1, 6], // Add kind 6
    authors: [pubkey],
    since: sinceTimestamp + 1,
    limit: 1000
};
            
            const subscription = ['REQ', 'incremental-' + Date.now(), filter];
            ws.send(JSON.stringify(subscription));
            
            timeoutId = setTimeout(() => {
                ws.close();
                resolve(events);
            }, 10000); // 10 second timeout
        };
        
        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const [type, subId, eventData] = message;
                
                if (type === 'EVENT') {
                    const note = processNote(eventData);
                    if (note) {
                        events.push(note);
                    }
                } else if (type === 'EOSE') {
                    clearTimeout(timeoutId);
                    ws.close();
                    resolve(events);
                }
            } catch (error) {
                console.error('Error parsing message:', error);
            }
        };
        
        ws.onerror = function() {
            clearTimeout(timeoutId);
            reject(new Error('Connection failed'));
        };
        
        ws.onclose = function() {
            clearTimeout(timeoutId);
            resolve(events);
        };
    });
}

async function fetchAllNotesFromRelay(relayUrl, pubkey, progressCallback) {
    const allEvents = [];
    let until = null;
    let batchNumber = 1;
   const batchSize = 1000
    
    while (true) {
        progressCallback(
            Math.min(95, (batchNumber - 1) * 15), 
            `batch ${batchNumber} (${allEvents.length} notes)`
        );
        
        try {
            
            const batchEvents = await fetchBatchFromRelay(relayUrl, pubkey, until, batchSize);

// ADD THIS DEBUGGING LINE
console.log(`[${relayUrl}] Batch ${batchNumber}: ${batchEvents.length} events (total: ${allEvents.length})`);

// Check if we got events BEFORE trying to access them
if (batchEvents.length === 0) {
    console.warn(`[${relayUrl}] Batch ${batchNumber} returned 0 events - stopping`);
    break;
}

allEvents.push(...batchEvents);

// Safety check: ensure we have a valid event before accessing its timestamp
const oldestEvent = batchEvents[batchEvents.length - 1];
if (!oldestEvent || !oldestEvent.created_at) {
    console.warn(`[${relayUrl}] Invalid event structure in batch ${batchNumber} - stopping`);
    break;
}

until = oldestEvent.created_at - 1;
batchNumber++;

// Rate limiting
await new Promise(resolve => setTimeout(resolve, 250));

// Safety check - prevent infinite loops
if (batchNumber > 200) {
    console.warn(`[${relayUrl}] Safety limit: 200 batches reached (${allEvents.length} notes)`);
    break;
}

// Rate limiting - longer delay for hosted environments
await new Promise(resolve => setTimeout(resolve, 250)); // Increased to 250ms for stability

// Safety check - prevent infinite loops
if (batchNumber > 200) { // Increased from 100 to 200 for large accounts
    console.warn(`[${relayUrl}] Safety limit: 200 batches reached (${allEvents.length} notes)`);
    break;
}
            
        } catch (error) {
            console.error(`Error fetching batch ${batchNumber} from ${relayUrl}:`, error);
            break;
        }
    }
    
    progressCallback(100, `complete (${allEvents.length} notes)`);
    return allEvents;
}

   
// Enhanced hybrid loading with chunked storage
// Enhanced hybrid loading with chunked storage
async function loadNotesHybrid(pubkey, silent = false) {
    try {
        // Initialize chunked storage
        const chunkStorage = new ChunkedNoteStorage(pubkey);
        const chunkStorageReady = await chunkStorage.init();
        
        if (!chunkStorageReady) {
            if (!silent) updateStatus('Chunked storage unavailable, using legacy system...');
            return await fetchNotesFromRelays(pubkey);
        }
        
        // Check if we have chunked data
        const chunkStats = await chunkStorage.getStats();
        
        if (chunkStats && chunkStats.totalNotes > 0) {
            if (!silent) {
                updateStatus(`Found chunked storage: ${chunkStats.totalChunks} chunks, ${chunkStats.totalNotes} notes`);
                updateStatus(`Loading all notes from chunked storage...`);
            }
            
            // ALWAYS load all notes from chunks if they exist
            const allNotes = await chunkStorage.loadAllNotes();
            
            if (allNotes.length > 0) {
                if (!silent) updateStatus(`Loaded ${allNotes.length} notes from ${chunkStats.totalChunks} chunks`);
                return allNotes;
            }
        }
        
        // No valid chunked data, fetch fresh and store in chunks
        if (!silent) updateStatus('No chunk data found, fetching fresh and storing in chunks...');
        
        const freshNotes = await fetchNotesFromRelays(pubkey);
        
        if (freshNotes.length > 0) {
            // Store in chunked format
            const stored = await chunkStorage.storeNotesInChunks(freshNotes);
            
            if (stored && !silent) {
                const newStats = await chunkStorage.getStats();
                updateStatus(`Stored ${freshNotes.length} notes in ${newStats.totalChunks} chunks`);
            }
        }
        
        return freshNotes;
        
    } catch (error) {
        console.error('Chunked loading error:', error);
        if (!silent) updateStatus('Chunked loading failed, using fallback...');
        return await fetchNotesFromRelays(pubkey);
    }
}

// PRODUCTION FAILSAFE SYSTEM

async function checkDatabaseHealth(pubkey, silent = false) {
    try {
        if (!db || !db.isOpen()) {
            if (!silent) updateStatus('Database connection failed');
            return false;
        }
        
        // Test basic database operations
        const testCount = await db.notes.count();
        const testSettings = await db.settings.toArray();
        
        // Check if we can read a sample note
        if (testCount > 0) {
            const sampleNote = await db.notes.limit(1).first();
            
            // Basic integrity checks
            if (!sampleNote) {
                if (!silent) updateStatus('Database count/data mismatch detected');
                return false;
            }
            
            if (!sampleNote.id || sampleNote.content === undefined || !sampleNote.created_at) {
                if (!silent) updateStatus('Invalid note structure detected');
                return false;
            }
        }
        
        // Test write capability
        try {
            await db.settings.put({ key: 'health_check', value: Date.now() });
            await db.settings.delete('health_check');
        } catch (writeError) {
            if (!silent) updateStatus('Database write test failed');
            return false;
        }
        
        return true;
    } catch (error) {
        console.error('Database health check failed:', error);
        return false;
    }
}

function validateNotesData(notes, expectedCount) {
    // Check we got reasonable amount of data
    const minExpected = Math.max(Math.min(expectedCount * 0.8, expectedCount - 100), 20);
    if (notes.length < minExpected) {
        return { 
            isValid: false, 
            reason: `Got ${notes.length} notes, expected at least ${minExpected}` 
        };
    }
    
    // Check data structure integrity
    const validNotes = notes.filter(note => 
        note && 
        note.id && 
        typeof note.id === 'string' &&
        note.content !== undefined && 
        note.created_at && 
        typeof note.created_at === 'number' &&
        Array.isArray(note.hashtags)
    );
    
    const validRatio = validNotes.length / notes.length;
    if (validRatio < 0.95) {
        return { 
            isValid: false, 
            reason: `${Math.round((1-validRatio)*100)}% of notes have invalid structure` 
        };
    }
    
    // Check for duplicate IDs (corruption indicator)
    const uniqueIds = new Set(validNotes.map(note => note.id));
    if (uniqueIds.size < validNotes.length * 0.98) {
        return { 
            isValid: false, 
            reason: 'Duplicate note IDs detected (data corruption)' 
        };
    }
    
    // Check timestamp sanity (notes can't be from the future)
    const now = Math.floor(Date.now() / 1000);
    const futureNotes = validNotes.filter(note => note.created_at > now + 3600);
    if (futureNotes.length > validNotes.length * 0.01) {
        return { 
            isValid: false, 
            reason: 'Invalid timestamps detected' 
        };
    }
    
    return { isValid: true, reason: 'Data validation passed' };
}

// Add this function to validate and fix note classifications when loading
function validateNoteClassification(note) {
    // Ensure classification fields exist and are boolean
    const validatedNote = {
        ...note,
        isReply: Boolean(note.isReply),
        isRepost: Boolean(note.isRepost),
        isQuote: Boolean(note.isQuote),
        kind: note.kind || 1
    };
    
    // If classifications seem wrong, re-process the note
    if (validatedNote.kind === 6 && !validatedNote.isRepost) {
        validatedNote.isRepost = true;
        validatedNote.isReply = false;
        validatedNote.isQuote = false;
    }
    
    return validatedNote;
}

async function repairDatabase(pubkey) {
    try {
        console.log('Repairing database for', pubkey.substring(0, 8) + '...');
        
        // Close current connection
        if (db && db.isOpen()) {
            await db.close();
        }
        
        // Delete corrupted database
        const dbName = `nostr-notes-${pubkey}`;
        await new Promise((resolve) => {
            const deleteReq = indexedDB.deleteDatabase(dbName);
            deleteReq.onsuccess = () => {
                console.log('Corrupted database deleted successfully');
                resolve();
            };
            deleteReq.onerror = () => {
                console.log('Database deletion failed, continuing anyway');
                resolve();
            };
            deleteReq.onblocked = () => {
                console.log('Database deletion blocked, forcing continuation');
                setTimeout(resolve, 2000);
            };
            // Safety timeout
            setTimeout(resolve, 5000);
        });
        
        // Reinitialize fresh database
        db = null;
        await initDatabase(pubkey);
        
        console.log('Database repair completed successfully');
        return true;
    } catch (error) {
        console.error('Database repair failed:', error);
        disableIndexedDB(error);
        return false;
    }
}

// Chunked Storage System for Phase 2
class ChunkedNoteStorage {
    constructor(pubkey) {
        this.pubkey = pubkey;
        this.dbName = `nostr-chunks-${pubkey}`;
        this.db = null;
    }
    
    async init() {
        try {
            this.db = new Dexie(this.dbName);
            this.db.version(1).stores({
                chunks: 'chunkKey, notes, metadata, created_at, updated_at',
                indices: 'type, data'
            });
            
            await this.db.open();
            return true;
        } catch (error) {
            console.error('Chunked storage init failed:', error);
            return false;
        }
    }
    
    // Generate chunk key from timestamp (YYYY-MM format)
    getChunkKey(timestamp) {
        const date = new Date(timestamp * 1000);
        return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
    }
    
    // Organize notes into monthly chunks
    // In the ChunkedNoteStorage class, update the organizeNotesIntoChunks method
organizeNotesIntoChunks(notes) {
    const chunks = new Map();
    
    notes.forEach(note => {
        const chunkKey = this.getChunkKey(note.created_at);
        
        if (!chunks.has(chunkKey)) {
            chunks.set(chunkKey, {
                chunkKey,
                notes: [],
                metadata: {
                    startDate: note.created_at,
                    endDate: note.created_at,
                    noteCount: 0,
                    hasReplies: false,
                    hasReposts: false,  // ADD THIS
                    hasQuotes: false,   // ADD THIS
                    hashtags: new Set()
                }
            });
        }
        
        const chunk = chunks.get(chunkKey);
        // IMPORTANT: Store the complete note object with all classifications
        chunk.notes.push({
            ...note,
            isReply: note.isReply || false,
            isRepost: note.isRepost || false,
            isQuote: note.isQuote || false
        });
        
        chunk.metadata.noteCount++;
        chunk.metadata.startDate = Math.min(chunk.metadata.startDate, note.created_at);
        chunk.metadata.endDate = Math.max(chunk.metadata.endDate, note.created_at);
        
        if (note.isReply) {
            chunk.metadata.hasReplies = true;
        }
        if (note.isRepost) {
            chunk.metadata.hasReposts = true;
        }
        if (note.isQuote) {
            chunk.metadata.hasQuotes = true;
        }
        
        if (note.hashtags) {
            note.hashtags.forEach(tag => chunk.metadata.hashtags.add(tag));
        }
    });
    
    // Convert hashtag Sets to arrays for storage
    chunks.forEach(chunk => {
        chunk.metadata.hashtags = Array.from(chunk.metadata.hashtags);
    });
    
    return Array.from(chunks.values());
}
    
    // Store notes in chunks
    async storeNotesInChunks(notes) {
        if (!this.db) return false;
        
        try {
            const chunks = this.organizeNotesIntoChunks(notes);
            
            // Clear existing chunks
            await this.db.chunks.clear();
            await this.db.indices.clear();
            
            // Store chunks
            for (const chunk of chunks) {
                await this.db.chunks.put({
                    ...chunk,
                    created_at: Date.now(),
                    updated_at: Date.now()
                });
            }
            
            // Build search indices
            await this.buildSearchIndices(chunks);
            
            console.log(`Stored ${chunks.length} chunks covering ${notes.length} notes`);
            return true;
            
        } catch (error) {
            console.error('Error storing chunks:', error);
            return false;
        }
    }
    
    // Build search indices for faster filtering
    async buildSearchIndices(chunks) {
        const hashtagIndex = new Map();
        const dateIndex = new Map();
        
        chunks.forEach(chunk => {
            // Hashtag index
            chunk.metadata.hashtags.forEach(tag => {
                if (!hashtagIndex.has(tag)) {
                    hashtagIndex.set(tag, []);
                }
                hashtagIndex.get(tag).push(chunk.chunkKey);
            });
            
            // Date index
            dateIndex.set(chunk.chunkKey, {
                startDate: chunk.metadata.startDate,
                endDate: chunk.metadata.endDate,
                noteCount: chunk.metadata.noteCount
            });
        });
        
        // Store indices
        await this.db.indices.put({
            type: 'hashtags',
            data: Object.fromEntries(hashtagIndex)
        });
        
        await this.db.indices.put({
            type: 'dates',
            data: Object.fromEntries(dateIndex)
        });
    }
    
    // Load specific chunks
    async loadChunks(chunkKeys) {
        if (!this.db) return [];
        
        try {
            const chunks = await this.db.chunks
                .where('chunkKey')
                .anyOf(chunkKeys)
                .toArray();
            
            // Flatten notes from all chunks
            const allNotes = [];
            chunks.forEach(chunk => {
                allNotes.push(...chunk.notes);
            });
            
            return allNotes.sort((a, b) => b.created_at - a.created_at);
            
        } catch (error) {
            console.error('Error loading chunks:', error);
            return [];
        }
    }
    
    // Load all notes from all chunks
    async loadAllNotes() {
        if (!this.db) return [];
        
        try {
            const allChunks = await this.db.chunks.toArray();
            const allNotes = [];
            
            allChunks.forEach(chunk => {
                allNotes.push(...chunk.notes);
            });
            
            return allNotes.sort((a, b) => b.created_at - a.created_at);
            
        } catch (error) {
            console.error('Error loading all notes from chunks:', error);
            return [];
        }
    }
    
    // Get chunks containing specific hashtags
    async getChunksForHashtags(hashtags) {
        if (!this.db) return [];
        
        try {
            const hashtagIndex = await this.db.indices.get('hashtags');
            if (!hashtagIndex) return [];
            
            const relevantChunks = new Set();
            hashtags.forEach(tag => {
                if (hashtagIndex.data[tag]) {
                    hashtagIndex.data[tag].forEach(chunkKey => {
                        relevantChunks.add(chunkKey);
                    });
                }
            });
            
            return Array.from(relevantChunks);
            
        } catch (error) {
            console.error('Error getting chunks for hashtags:', error);
            return [];
        }
    }
    
    // Get chunks for date range
    async getChunksForDateRange(startDate, endDate) {
        if (!this.db) return [];
        
        try {
            const dateIndex = await this.db.indices.get('dates');
            if (!dateIndex) return [];
            
            const relevantChunks = [];
            Object.entries(dateIndex.data).forEach(([chunkKey, chunkInfo]) => {
                // Check if chunk overlaps with date range
                if (chunkInfo.endDate >= startDate && chunkInfo.startDate <= endDate) {
                    relevantChunks.push(chunkKey);
                }
            });
            
            return relevantChunks;
            
        } catch (error) {
            console.error('Error getting chunks for date range:', error);
            return [];
        }
    }
    
    // Get storage statistics
    async getStats() {
        if (!this.db) return null;
        
        try {
            const chunks = await this.db.chunks.toArray();
            let totalNotes = 0;
            let oldestNote = null;
            let newestNote = null;
            
            chunks.forEach(chunk => {
                totalNotes += chunk.metadata.noteCount;
                if (!oldestNote || chunk.metadata.startDate < oldestNote) {
                    oldestNote = chunk.metadata.startDate;
                }
                if (!newestNote || chunk.metadata.endDate > newestNote) {
                    newestNote = chunk.metadata.endDate;
                }
            });
            
            return {
                totalChunks: chunks.length,
                totalNotes,
                oldestNote: oldestNote ? new Date(oldestNote * 1000) : null,
                newestNote: newestNote ? new Date(newestNote * 1000) : null,
                avgNotesPerChunk: Math.round(totalNotes / chunks.length)
            };
            
        } catch (error) {
            console.error('Error getting storage stats:', error);
            return null;
        }
    }
}

// Chunk management utilities
async function getChunkStorageInfo(pubkey) {
    const chunkStorage = new ChunkedNoteStorage(pubkey);
    const ready = await chunkStorage.init();
    
    if (!ready) return null;
    
    return await chunkStorage.getStats();
}

// Phase 3: Smart Filter-Aware Loading System
class SmartFilterEngine {
    constructor(chunkStorage) {
        this.chunkStorage = chunkStorage;
        this.loadedChunks = new Map(); // Cache for loaded chunks
        this.estimatedCounts = new Map(); // Cache for filter estimates
    }
    
    // Get estimated count for filters without loading all data
    async getEstimatedCount(filters) {
        const cacheKey = JSON.stringify(filters);
        if (this.estimatedCounts.has(cacheKey)) {
            return this.estimatedCounts.get(cacheKey);
        }
        
        try {
            const relevantChunks = await this.getRelevantChunks(filters);
            let estimatedCount = 0;
            
            // For hashtag filters, we can be more precise
            if (filters.hashtags && filters.hashtags.length > 0) {
                const chunks = await this.chunkStorage.getChunksForHashtags(filters.hashtags);
                // Load chunk metadata to get more accurate estimates
                for (const chunkKey of chunks) {
                    const chunk = await this.chunkStorage.db.chunks.get(chunkKey);
                    if (chunk) {
                        // Estimate based on hashtag density in chunk
                        const matchingHashtags = filters.hashtags.filter(tag => 
                            chunk.metadata.hashtags.includes(tag)
                        );
                        const ratio = matchingHashtags.length / Math.max(chunk.metadata.hashtags.length, 1);
                        estimatedCount += Math.ceil(chunk.metadata.noteCount * ratio * 0.7); // Conservative estimate
                    }
                }
            } else {
                // For other filters, use chunk note counts
                for (const chunkKey of relevantChunks) {
                    const chunk = await this.chunkStorage.db.chunks.get(chunkKey);
                    if (chunk) {
                        estimatedCount += chunk.metadata.noteCount;
                    }
                }
            }
            
            this.estimatedCounts.set(cacheKey, estimatedCount);
            return estimatedCount;
            
        } catch (error) {
            console.error('Error estimating count:', error);
            return 0;
        }
    }
    
    // Determine which chunks are relevant for given filters
    async getRelevantChunks(filters) {
        let relevantChunks = new Set();
        
        try {
            // Start with all chunks
            const allChunks = await this.chunkStorage.db.chunks.toArray();
            allChunks.forEach(chunk => relevantChunks.add(chunk.chunkKey));
            
            // Filter by hashtags
            if (filters.hashtags && filters.hashtags.length > 0) {
                const hashtagChunks = await this.chunkStorage.getChunksForHashtags(filters.hashtags);
                relevantChunks = new Set(hashtagChunks);
            }
            
            // Filter by date range
            if (filters.dateFrom || filters.dateTo) {
                const startDate = filters.dateFrom ? Math.floor(filters.dateFrom.getTime() / 1000) : 0;
                const endDate = filters.dateTo ? Math.floor(filters.dateTo.getTime() / 1000) : Math.floor(Date.now() / 1000);
                
                const dateChunks = await this.chunkStorage.getChunksForDateRange(startDate, endDate);
                
                if (relevantChunks.size === allChunks.length) {
                    // If we started with all chunks, use date chunks
                    relevantChunks = new Set(dateChunks);
                } else {
                    // Intersect with existing relevant chunks
                    relevantChunks = new Set([...relevantChunks].filter(x => dateChunks.includes(x)));
                }
            }
            
            // Filter by content type (replies/original)
            if (filters.contentType) {
                const filteredChunks = [];
                for (const chunkKey of relevantChunks) {
                    const chunk = await this.chunkStorage.db.chunks.get(chunkKey);
                    if (chunk) {
                        if (filters.contentType === 'replies' && chunk.metadata.hasReplies) {
                            filteredChunks.push(chunkKey);
                        } else if (filters.contentType === 'original' && chunk.metadata.noteCount > 0) {
                            filteredChunks.push(chunkKey);
                        }
                    }
                }
                relevantChunks = new Set(filteredChunks);
            }
            
            return Array.from(relevantChunks);
            
        } catch (error) {
            console.error('Error getting relevant chunks:', error);
            return [];
        }
    }
    
    // Load notes from relevant chunks with filters applied
    async loadFilteredNotes(filters, maxNotes = 50000) {
        try {
            const relevantChunks = await this.getRelevantChunks(filters);
            
            if (relevantChunks.length === 0) {
                return [];
            }
            
            updateStatus(`Loading from ${relevantChunks.length} relevant chunks...`);
            
            // Load chunks in order of relevance (newest first)
            const sortedChunks = relevantChunks.sort((a, b) => b.localeCompare(a));
            let allNotes = [];
            let loadedCount = 0;
            
            for (const chunkKey of sortedChunks) {
                if (loadedCount >= maxNotes) break;
                
                // Check if chunk is already loaded
                if (!this.loadedChunks.has(chunkKey)) {
                    const chunkNotes = await this.chunkStorage.loadChunks([chunkKey]);
                    this.loadedChunks.set(chunkKey, chunkNotes);
                }
                
                const chunkNotes = this.loadedChunks.get(chunkKey) || [];
                allNotes.push(...chunkNotes);
                loadedCount += chunkNotes.length;
                
                // Update progress
                updateStatus(`Loaded ${loadedCount} notes from ${Object.keys(this.loadedChunks).length} chunks...`);
            }
            
            // Apply fine-grained filters
            const filteredNotes = this.applyDetailedFilters(allNotes, filters);
            
            updateStatus(`Filtered to ${filteredNotes.length} matching notes`);
            return filteredNotes.slice(0, maxNotes);
            
        } catch (error) {
            console.error('Error loading filtered notes:', error);
            return [];
        }
    }
    
    // Apply detailed filters to loaded notes
    applyDetailedFilters(notes, filters) {
        return notes.filter(note => {
            // Text search
            if (filters.searchText) {
                const searchTerms = filters.searchText.toLowerCase().split(/\s+/);
                const searchableText = (note.content + ' ' + (note.hashtags || []).join(' ')).toLowerCase();
                if (!searchTerms.every(term => searchableText.includes(term))) {
                    return false;
                }
            }
            
            // Hashtag filter
            if (filters.hashtags && filters.hashtags.length > 0) {
                if (!filters.hashtags.some(tag => note.hashtags && note.hashtags.includes(tag))) {
                    return false;
                }
            }
            
            // Date range
            if (filters.dateFrom && note.created_at < Math.floor(filters.dateFrom.getTime() / 1000)) {
                return false;
            }
            if (filters.dateTo && note.created_at > Math.floor(filters.dateTo.getTime() / 1000)) {
                return false;
            }
            
            // Content type
            if (filters.contentType === 'replies' && !note.isReply) {
                return false;
            }
            if (filters.contentType === 'original' && note.isReply) {
                return false;
            }
            
            // Media filters
            if (filters.hasImages) {
                const imageRegex = /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp))/gi;
                if (!imageRegex.test(note.content)) {
                    return false;
                }
            }
            
            if (filters.hasYouTube) {
                const youtubeRegex = /(youtube\.com\/watch\?v=|youtu\.be\/)/gi;
                if (!youtubeRegex.test(note.content)) {
                    return false;
                }
            }
            
            // Length filters
            if (filters.minLength && note.content.length < filters.minLength) {
                return false;
            }
            if (filters.maxLength && note.content.length > filters.maxLength) {
                return false;
            }
            
            return true;
        });
    }
    
    // Clear caches
    clearCaches() {
        this.loadedChunks.clear();
        this.estimatedCounts.clear();
    }
}

// Smart tag filtering using chunk awareness
// Smart tag filtering using chunk awareness
async function performSmartTagFilter(tag) {
    console.log('=== SMART TAG FILTER DEBUG ===');
    console.log('Filtering for tag:', tag);
    
    try {
        const chunkStorage = new ChunkedNoteStorage(currentPubkey);
        const ready = await chunkStorage.init();
        
        if (!ready) {
            console.log('Chunk storage not ready, falling back to memory filtering');
            const memoryResults = allNotes.filter(note => noteMatchesTag(note, tag));
            console.log('Memory filtering found:', memoryResults.length, 'results');
            return memoryResults;
        }
        
        console.log('Chunk storage ready, attempting smart filtering...');
        
        const filterEngine = new SmartFilterEngine(chunkStorage);
        
        // Convert tag to filter format
        const filters = {};
        
        if (tag.startsWith('#')) {
            filters.hashtags = [tag];
            console.log('Set hashtag filter:', filters.hashtags);
            
            // DEBUG: Check if hashtag exists in indices
            const hashtagIndex = await chunkStorage.db.indices.get('hashtags');
            console.log('Hashtag index:', hashtagIndex);
            
            if (hashtagIndex && hashtagIndex.data[tag]) {
                console.log('Found chunks for hashtag:', hashtagIndex.data[tag]);
            } else {
                console.log('No chunks found for hashtag in index, falling back to memory');
                const memoryResults = allNotes.filter(note => noteMatchesTag(note, tag));
                console.log('Memory fallback found:', memoryResults.length, 'results');
                return memoryResults;
            }
            
        } else if (tag === '__original') {
            filters.contentType = 'original';
        } else if (tag === '__replies') {
            filters.contentType = 'replies';
        } else if (tag.startsWith('__archive_')) {
            // Archive filtering still uses memory (archives are typically smaller)
            const archiveName = tag.replace('__archive_', '');
            if (namedArchives[archiveName]) {
                return allNotes.filter(note => namedArchives[archiveName].has(note.id));
            }
            return [];
        }
        
        // Get estimated count
        const estimatedCount = await filterEngine.getEstimatedCount(filters);
        console.log('Estimated count:', estimatedCount);
        
        if (estimatedCount > 0) {
            updateStatus(`Loading ${estimatedCount} estimated notes for ${tag}...`);
            
            // Load filtered notes
            const results = await filterEngine.loadFilteredNotes(filters);
            
            console.log('Smart filtering results:', results.length);
            updateStatus(`Loaded ${results.length} notes for ${tag}`);
            return results;
        }
        
        console.log('No estimated results, falling back to memory');
        const memoryResults = allNotes.filter(note => noteMatchesTag(note, tag));
        console.log('Memory fallback found:', memoryResults.length, 'results');
        return memoryResults;
        
    } catch (error) {
        console.error('Smart tag filter error:', error);
        // Fallback to memory search
        const memoryResults = allNotes.filter(note => noteMatchesTag(note, tag));
        console.log('Error fallback found:', memoryResults.length, 'results');
        return memoryResults;
    }
}

async function clearChunkStorage(pubkey) {
    try {
        const chunkStorage = new ChunkedNoteStorage(pubkey);
        const ready = await chunkStorage.init();
        
        if (ready && chunkStorage.db) {
            await chunkStorage.db.chunks.clear();
            await chunkStorage.db.indices.clear();
            return true;
        }
        
        return false;
    } catch (error) {
        console.error('Error clearing chunk storage:', error);
        return false;
    }
}

// Add this function to debug chunk storage
async function debugChunkStorage() {
    if (!currentPubkey) {
        console.log('No current pubkey');
        return;
    }
    
    const chunkStorage = new ChunkedNoteStorage(currentPubkey);
    const ready = await chunkStorage.init();
    
    if (!ready) {
        console.log('Chunk storage not ready');
        return;
    }
    
    console.log('=== CHUNK STORAGE DEBUG ===');
    
    // Get all chunks
    const chunks = await chunkStorage.db.chunks.toArray();
    console.log('Total chunks:', chunks.length);
    
    // Check hashtag index
    const hashtagIndex = await chunkStorage.db.indices.get('hashtags');
    console.log('Hashtag index:', hashtagIndex);
    
    if (hashtagIndex) {
        const hashtags = Object.keys(hashtagIndex.data);
        console.log('Hashtags in index:', hashtags.slice(0, 10), '(showing first 10)');
        
        // Check a specific hashtag
        const firstHashtag = hashtags[0];
        if (firstHashtag) {
            console.log(`Chunks for ${firstHashtag}:`, hashtagIndex.data[firstHashtag]);
        }
    }
    
    // Check sample chunk
    if (chunks.length > 0) {
        console.log('Sample chunk metadata:', chunks[0].metadata);
    }
}

// Make it globally available for testing
window.debugChunkStorage = debugChunkStorage;

async function fetchFreshAndStore(pubkey, silent = false) {
    if (!silent) updateStatus('Fetching fresh data from relays...');
    
    const freshNotes = await fetchNotesFromRelays(pubkey);
    
    if (freshNotes.length > 0 && db && useIndexedDB) {
        try {
            if (!silent) updateStatus('Storing fresh data in IndexedDB...');
            
            await db.notes.clear();
            await db.settings.clear();
            
            // IMPORTANT: Ensure all classification fields are explicitly stored
            const notesToStore = freshNotes.map(note => ({
                ...note,
                isReply: Boolean(note.isReply),
                isRepost: Boolean(note.isRepost),
                isQuote: Boolean(note.isQuote),
                kind: note.kind || 1
            }));
            
            // Store in chunks to avoid memory issues
            const chunkSize = 1000;
            for (let i = 0; i < notesToStore.length; i += chunkSize) {
                const chunk = notesToStore.slice(i, i + chunkSize);
                await db.notes.bulkAdd(chunk);
                
                if (!silent && notesToStore.length > chunkSize) {
                    updateStatus(`Stored ${Math.min(i + chunkSize, notesToStore.length)}/${notesToStore.length} notes...`);
                }
            }
            
            await db.settings.put({ key: 'last_sync_time', value: Date.now() });
            await db.settings.put({ key: 'total_notes_stored', value: notesToStore.length });
            
            if (!silent) {
                updateStatus(`Successfully stored ${notesToStore.length} notes in IndexedDB`);
            }
        } catch (storeError) {
            console.error('Failed to store fresh data:', storeError);
            if (!silent) updateStatus('Storage failed, continuing with memory-only mode');
            disableIndexedDB(storeError);
        }
    }
    
    return freshNotes;
}

async function incrementalSync(pubkey, silent = true) {
    if (!db || !useIndexedDB) {
        return await fetchNotesFromRelays(pubkey); // Fallback to full fetch
    }
    
    try {
        // Get the newest note we have stored
        const newestStoredNote = await db.notes
            .orderBy('created_at')
            .reverse()
            .first();
        
        if (!newestStoredNote) {
            // No stored notes, do full fetch
            return await fetchNotesFromRelays(pubkey);
        }
        
        const lastTimestamp = newestStoredNote.created_at;
        
        if (!silent) {
            updateStatus(`Checking for notes newer than ${new Date(lastTimestamp * 1000).toLocaleString()}...`);
        }
        
        // Fetch only newer notes from relays
        const newNotes = await fetchNotesFromRelaysSince(pubkey, lastTimestamp);
        
        if (newNotes.length > 0) {
            // Add new notes to IndexedDB
            await db.notes.bulkAdd(newNotes);
            await db.settings.put({ key: 'last_sync_time', value: Date.now() });
            
            if (!silent) {
                updateStatus(`Found and stored ${newNotes.length} new notes`);
            }
            
            // Return all notes (existing + new) for display
            const allNotes = await db.notes
                .orderBy('created_at')
                .reverse()
                .toArray();
            
            return allNotes;
        } else {
            if (!silent) {
                updateStatus('No new notes found');
            }
            
            // Return existing notes
            return await db.notes
                .orderBy('created_at')
                .reverse()
                .toArray();
        }
        
    } catch (error) {
        console.error('Incremental sync error:', error);
        // Fallback to full fetch
        return await fetchNotesFromRelays(pubkey);
    }
}

async function loadNotes(silent = false, isRefresh = false) {
    const previousNotesCount = allNotes.length; // Track what we had before
    let loadedFromChunkCache = false;
    let cachedChunkStats = null;
    
    if (!silent) {
        showLoading(true);
        updateProgress(0, 'Connecting to relays.');
        updateStatus('Starting fresh load...', true);
    } else {
        // small indicator only
        updateStatus('Refreshing notes…');
    }
            
    try {
        let notes;
        let isLargeAccount = false;
        let accountInfo = null; // Declare once at the top

        if (!silent) {
            // FIRST: Check if we have stored chunks (prioritize over account size detection)
            updateProgress(5, 'Checking for stored data...');
            
            const chunkStorage = new ChunkedNoteStorage(currentPubkey);
            const chunkReady = await chunkStorage.init();
            
            if (chunkReady) {
                const chunkStats = await chunkStorage.getStats();
                
                if (chunkStats && chunkStats.totalNotes > 0) {
                    // We have stored data - load it all immediately
                    loadedFromChunkCache = true;
                    cachedChunkStats = chunkStats;
                    updateProgress(15, `Loading all ${chunkStats.totalNotes} notes from storage...`);
                    updateStatus(`Found stored data: ${chunkStats.totalChunks} chunks, ${chunkStats.totalNotes} notes`);
                    
                    notes = await loadNotesHybrid(currentPubkey, silent);
                    
                    showToast(`Loaded ${notes.length} notes from storage instantly!`, 'success');
                    updateStatus(`Loaded ${notes.length} notes from ${chunkStats.totalChunks} stored chunks`);
                    
                } else {
                    // No stored data - do account size detection and progressive loading
                    updateProgress(10, 'No stored data found, checking account size...');
                    accountInfo = await estimateAccountSize(currentPubkey); // Set accountInfo here
                    
                    console.log('Account info:', accountInfo);
                    updateProgress(15, `Account: ${accountInfo.size} (${accountInfo.recentCount} recent notes)`);
                    
                    if (accountInfo.size === 'large') {
                        isLargeAccount = true;
                        updateProgress(20, 'Large account - loading recent notes first...');
                        updateStatus('Large account detected! Loading recent notes for faster startup...');
                        
                        notes = await loadRecentNotesOnly(currentPubkey, 30);
                        showToast(`Loaded ${notes.length} recent notes instantly! Older notes loading in background.`, 'success');
                        
                    } else if (accountInfo.size === 'medium') {
                        updateProgress(20, 'Medium account - loading recent notes first...');
                        updateStatus('Medium account detected! Loading recent notes first...');
                        
                        notes = await loadRecentNotesOnly(currentPubkey, 60);
                        showToast(`Loaded ${notes.length} recent notes. Full history loading in background.`, 'success');
                        
                    } else {
                        updateProgress(20, 'Small account detected - loading all notes...');
                        updateStatus('Small account detected - loading all notes...');
                        
                        notes = await loadNotesHybrid(currentPubkey, silent);
                    }
                }
            } else {
                // Chunked storage failed - fallback to original progressive loading
                updateProgress(10, 'Storage unavailable, checking account size...');
                accountInfo = await estimateAccountSize(currentPubkey); // Set accountInfo here too
                
                console.log('Account info:', accountInfo);
                updateProgress(15, `Account: ${accountInfo.size} (${accountInfo.recentCount} recent notes)`);
                
                if (accountInfo.size === 'large') {
                    isLargeAccount = true;
                    updateProgress(20, 'Large account - loading recent notes first...');
                    
                    notes = await loadRecentNotesOnly(currentPubkey, 30);
                    showToast(`Loaded ${notes.length} recent notes instantly! Older notes loading in background.`, 'success');
                    
                } else if (accountInfo.size === 'medium') {
                    updateProgress(20, 'Medium account - loading recent notes first...');
                    
                    notes = await loadRecentNotesOnly(currentPubkey, 60);
                    showToast(`Loaded ${notes.length} recent notes. Full history loading in background.`, 'success');
                    
                } else {
                    updateProgress(20, 'Small account detected - loading all notes...');
                    notes = await loadNotesHybrid(currentPubkey, silent);
                }
            }
        } else {
            // Silent loads (refreshes) always use hybrid approach
            notes = await loadNotesHybrid(currentPubkey, silent);
        }

        // Clear old localStorage cache since we're using IndexedDB now
        if (useIndexedDB) {
            clearLegacyCache(currentPubkey);
        }
        
        updateStatus(`Sorting ${notes.length} notes by date...`);
        await new Promise(resolve => setTimeout(resolve, 10)); // Brief pause
        
        allNotes = notes.sort((a, b) => b.created_at - a.created_at);
        
        updateStatus('Updating archives list...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Initialize archives UI after loading
        updateArchiveList();
        updateTargetArchiveDropdown();
        
        updateStatus('Updating tag filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        updateTagFilters();
        
        updateStatus('Applying filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        applyFilters();
        
        updateStatus('Rendering notes...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        renderNotes();
        
        // Schedule background loading AFTER UI is ready (only for fresh loads without stored data)
        // Fixed: Check if accountInfo exists before accessing its properties
        if (!silent && (isLargeAccount || (accountInfo && accountInfo.size === 'medium'))) {
            scheduleBackgroundLoading(currentPubkey, { estimatedTotal: notes.length * 5 });
        } else if (!silent && loadedFromChunkCache) {
            // Always refresh cached chunks in the background to make sure we don't miss notes
            const estimatedTotal = (cachedChunkStats && cachedChunkStats.totalNotes) || notes.length;
            scheduleBackgroundLoading(currentPubkey, { estimatedTotal });
        }
        
        // Calculate what was actually new
        const newNotesCount = allNotes.length - previousNotesCount;
        updateStatus(`✅ Successfully loaded ${allNotes.length} notes!`);
        
        if (!silent && isRefresh === true) {
            if (newNotesCount > 0) {
                showToast(`Refresh complete - ${newNotesCount} new notes loaded (${allNotes.length} total)`, 'success');
            } else {
                showToast(`Refresh complete - no new notes found (${allNotes.length} total)`, 'success');
            }
        }
        
    } catch (error) {
        console.error('Error loading notes:', error);
        showError('Failed to load notes: ' + error.message);
    } finally {
        if (!silent) {
            showLoading(false);
            trackLoadTime();
        }
    }
}
      
async function fetchBatchFromRelay(relayUrl, pubkey, until, limit, retryCount = 0) {
    const maxRetries = 3;
    
    console.log(`[${relayUrl}] Fetching batch: until=${until}, limit=${limit}, retry=${retryCount}`);
    
    try {
        const result = await fetchBatchFromRelayCore(relayUrl, pubkey, until, limit);
        console.log(`[${relayUrl}] Batch returned ${result.length} events`);
        return result;
    } catch (error) {
        console.error(`[${relayUrl}] Batch attempt ${retryCount + 1} failed:`, error.message);
        
        if (retryCount < maxRetries) {
            const backoffDelay = Math.pow(2, retryCount) * 1000;
            console.log(`[${relayUrl}] Retrying after ${backoffDelay}ms`);
            await new Promise(resolve => setTimeout(resolve, backoffDelay));
            return fetchBatchFromRelay(relayUrl, pubkey, until, limit, retryCount + 1);
        }
        
        console.warn(`[${relayUrl}] All retries exhausted, returning empty batch`);
        return [];
    }
}

function fetchBatchFromRelayCore(relayUrl, pubkey, until, limit) {
    return new Promise((resolve, reject) => {
        // Check if loading was cancelled before starting
        if (isLoadingCancelled) {
            resolve([]);
            return;
        }
        
        const ws = new WebSocket(relayUrl);
        activeWebSockets.add(ws); // Track this WebSocket
        
        const events = [];
        let timeoutId;
        let isResolved = false;
        
        const cleanup = (reason = 'unknown') => {
            if (timeoutId) clearTimeout(timeoutId);
            activeWebSockets.delete(ws); // Remove from tracking
            if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
                ws.close(1000, 'Batch complete');
            }
        };
        
        const resolveOnce = (result) => {
            if (!isResolved) {
                isResolved = true;
                cleanup();
                resolve(result);
            }
        };
        
        const rejectOnce = (error) => {
            if (!isResolved) {
                isResolved = true;
                cleanup();
                reject(error);
            }
        };
        
        ws.onopen = function() {
            // Check cancellation after connection opens
            if (isLoadingCancelled) {
                resolveOnce([]);
                return;
            }
            
            const filter = {
                kinds: [1, 6],
                authors: [pubkey],
                limit: limit
            };
            
            if (until) {
                filter.until = until;
            }
            
            const subscription = ['REQ', 'batch-' + Date.now(), filter];
            ws.send(JSON.stringify(subscription));
            
            timeoutId = setTimeout(() => {
    console.warn(`[${relayUrl}] Timeout after 45s, returning ${events.length} events`);
    resolveOnce(events);
}, 90000); // Changed from 90000 to 45000
        };
        
        ws.onmessage = function(event) {
            // Check cancellation on each message
            if (isLoadingCancelled) {
                resolveOnce(events);
                return;
            }
            
            try {
                const message = JSON.parse(event.data);
                const [type, subId, eventData] = message;
                
                if (type === 'EVENT') {
                    const note = processNote(eventData);
                    if (note) {
                        events.push(note);
                    }
                } else if (type === 'EOSE') {
                    resolveOnce(events);
                }
            } catch (error) {
                console.error('Error parsing message:', error);
            }
        };
        
        ws.onerror = function() {
            rejectOnce(new Error('Connection failed'));
        };
        
        ws.onclose = function() {
            if (!isResolved) {
                resolveOnce(events);
            }
        };
    });
}

// Account size detection for progressive loading
async function estimateAccountSize(pubkey) {
    try {
        // Try to get a COUNT from relays instead of recent notes
        const testRelays = ['wss://relay.snort.social', 'wss://relay.damus.io', 'wss://relay.primal.net'];
        let bestEstimate = 0;
        
        for (const relay of testRelays) {
            try {
                // Get a small sample to estimate total size
                const sampleSize = await getTotalNoteEstimate(relay, pubkey);
                bestEstimate = Math.max(bestEstimate, sampleSize);
                console.log(`${relay}: estimated ${sampleSize} total notes`);
                
                if (sampleSize > 5000) {
                    return { size: 'large', estimatedTotal: sampleSize };
                }
            } catch (error) {
                console.log(`${relay} failed for size check:`, error.message);
                continue;
            }
        }
        
        // Classification based on total estimate
        if (bestEstimate > 2000) {
            return { size: 'large', estimatedTotal: bestEstimate };
        } else if (bestEstimate > 500) {
            return { size: 'medium', estimatedTotal: bestEstimate };
        } else {
            return { size: 'small', estimatedTotal: bestEstimate };
        }
        
    } catch (error) {
        console.error('Account size estimation failed:', error);
        // Default to medium to use progressive loading
        return { size: 'medium', estimatedTotal: 1000 };
    }
}

async function getTotalNoteEstimate(relayUrl, pubkey) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        let count = 0;
        let hasReceivedAnyEvent = false;
        
        const timeoutId = setTimeout(() => {
            ws.close();
            // If we got some events, extrapolate
            if (hasReceivedAnyEvent && count > 0) {
                resolve(count * 3); // Rough estimate
            } else {
                resolve(0);
            }
        }, 15000); // 15 second timeout
        
        ws.onopen = function() {
            // Request first 1000 notes to estimate
            const filter = {
                kinds: [1, 6],
                authors: [pubkey],
                limit: 1000
            };
            
            ws.send(JSON.stringify(['REQ', 'size-check', filter]));
        };
        
        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const [type] = message;
                
                if (type === 'EVENT') {
                    count++;
                    hasReceivedAnyEvent = true;
                } else if (type === 'EOSE') {
                    clearTimeout(timeoutId);
                    ws.close();
                    // If we got exactly 1000, there are probably more
                    resolve(count >= 1000 ? count * 5 : count);
                }
            } catch (error) {
                // Ignore parse errors
            }
        };
        
        ws.onerror = function() {
            clearTimeout(timeoutId);
            reject(new Error('Connection failed'));
        };
    });
}

async function getRecentNoteCount(relayUrl, pubkey, daysBack) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        let count = 0;
        const timeoutId = setTimeout(() => {
            ws.close();
            resolve(count);
        }, 10000); // 10 second timeout
        
        ws.onopen = function() {
            const since = Math.floor(Date.now() / 1000) - (daysBack * 24 * 60 * 60);
            const filter = {
    kinds: [1, 6], // Add kind 6
    authors: [pubkey],
    since: since,
    limit: 1000
};
            
            ws.send(JSON.stringify(['REQ', 'size-check', filter]));
        };
        
        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const [type] = message;
                
                if (type === 'EVENT') {
                    count++;
                } else if (type === 'EOSE') {
                    clearTimeout(timeoutId);
                    ws.close();
                    resolve(count);
                }
            } catch (error) {
                // Ignore parse errors
            }
        };
        
        ws.onerror = function() {
            clearTimeout(timeoutId);
            reject(new Error('Connection failed'));
        };
    });
}

// Load only recent notes for large accounts
// Enhanced recent loading with chunked storage awareness
async function loadRecentNotesOnly(pubkey, daysBack = 30) {
    try {
        // Try to load from chunks first
        const chunkStorage = new ChunkedNoteStorage(pubkey);
        const chunkStorageReady = await chunkStorage.init();
        
        if (chunkStorageReady) {
            const stats = await chunkStorage.getStats();
            
            if (stats && stats.totalNotes > 0) {
                // Calculate date range for recent notes
                const sinceTimestamp = Math.floor(Date.now() / 1000) - (daysBack * 24 * 60 * 60);
                const nowTimestamp = Math.floor(Date.now() / 1000);
                
                // Get relevant chunks for this date range
                const relevantChunks = await chunkStorage.getChunksForDateRange(sinceTimestamp, nowTimestamp);
                
                if (relevantChunks.length > 0) {
                    updateStatus(`Loading recent notes from ${relevantChunks.length} chunks...`);
                    
                    const recentNotes = await chunkStorage.loadChunks(relevantChunks);
                    
                    // Filter to exact date range
                    const filteredNotes = recentNotes.filter(note => 
                        note.created_at >= sinceTimestamp
                    );
                    
                    if (filteredNotes.length > 0) {
                        updateStatus(`Loaded ${filteredNotes.length} recent notes from chunks`);
                        return filteredNotes;
                    }
                }
            }
        }
        
        // Fallback to relay loading
        updateStatus(`No chunk data available, loading recent notes from relays...`);
        return await loadRecentNotesFromRelays(pubkey, daysBack);
        
    } catch (error) {
        console.error('Chunked recent loading failed:', error);
        return await loadRecentNotesFromRelays(pubkey, daysBack);
    }
}

// Separate function for relay-based recent loading
async function loadRecentNotesFromRelays(pubkey, daysBack) {
    const allEvents = [];
    const since = Math.floor(Date.now() / 1000) - (daysBack * 24 * 60 * 60);
    
    updateStatus(`Loading recent notes from relays (last ${daysBack} days)...`);
    
    const relayPromises = RELAYS.slice(0, 5).map(async (relay, index) => {
        const relayName = relay.replace('wss://', '');
        
        try {
            updateStatus(`${relayName}: Loading recent notes...`);
            
            const recentNotes = await fetchRecentNotesFromRelay(relay, pubkey, since);
            
            updateStatus(`✅ ${relayName}: ${recentNotes.length} recent notes`);
            return { relay, events: recentNotes, success: true };
            
        } catch (error) {
            updateStatus(`❌ ${relayName}: ${error.message}`);
            return { relay, events: [], success: false };
        }
    });
    
    const results = await Promise.allSettled(relayPromises);
    
    // Collect events
    results.forEach((result) => {
        if (result.status === 'fulfilled' && result.value.success) {
            allEvents.push(...result.value.events);
        }
    });
    
    // Quick deduplication
    const uniqueEvents = [];
    const seenIds = new Set();
    
    allEvents.forEach(event => {
        if (event.id && !seenIds.has(event.id)) {
            seenIds.add(event.id);
            uniqueEvents.push(event);
        }
    });
    
    updateStatus(`✅ Loaded ${uniqueEvents.length} recent notes from relays`);
    return uniqueEvents;
}

// Enhanced background loading with chunked storage
async function scheduleBackgroundLoading(pubkey, accountInfo) {
    // Prevent overlapping background loads
    if (isBackgroundLoading) {
        return;
    }

    if (backgroundLoadingTimeout) {
        clearTimeout(backgroundLoadingTimeout);
        backgroundLoadingTimeout = null;
    }

    backgroundLoadingTimeout = setTimeout(async () => {
        // Check if cancelled before starting
        if (isLoadingCancelled) {
            backgroundLoadingTimeout = null;
            return;
        }
        
        try {
            isBackgroundLoading = true;
            console.log('Starting background loading...');
            showBackgroundLoadingIndicator();
            
            const fullNotes = await fetchNotesFromRelays(pubkey);
            
            // Check cancellation after fetch
            if (isLoadingCancelled) {
                hideBackgroundLoadingIndicator();
                isBackgroundLoading = false;
                backgroundLoadingTimeout = null;
                return;
            }
            // Initialize chunked storage
            const chunkStorage = new ChunkedNoteStorage(pubkey);
            const chunkStorageReady = await chunkStorage.init();
            
            if (chunkStorageReady) {
                // Store all notes in chunked format
                await chunkStorage.storeNotesInChunks(fullNotes);
                
                const stats = await chunkStorage.getStats();
                updateStatus(`Updated chunk storage: ${stats.totalChunks} chunks, ${stats.totalNotes} notes`);
            }
            
            // Find notes we don't already have in memory
            const existingIds = new Set(allNotes.map(note => note.id));
            const newNotes = fullNotes.filter(note => !existingIds.has(note.id));
            
            console.log(`Background loading found ${newNotes.length} additional notes`);
            
            if (newNotes.length > 0) {
                // Add to global array
                allNotes.push(...newNotes);
                allNotes.sort((a, b) => b.created_at - a.created_at);
                
                // Update UI if user is on default view
                updateTagFilters();
                
                if (!currentTag && selectedTags.size === 0 && activeQuickFilters.size === 0) {
                    applyFilters();
                    renderNotes();
                }
                
                hideBackgroundLoadingIndicator();
                showToast(`Background loading complete: ${newNotes.length} additional notes found and stored in chunks!`, 'success');
                updateStatus(`✅ Background loading: +${newNotes.length} older notes (${allNotes.length} total, stored in chunks)`);
            } else {
                hideBackgroundLoadingIndicator();
                updateStatus('✅ Background loading complete: chunk storage updated, no additional notes in memory');
            }
            
        } catch (error) {
            console.error('Background loading failed:', error);
            hideBackgroundLoadingIndicator();
        } finally {
            isBackgroundLoading = false;
            backgroundLoadingTimeout = null;
        }
    }, 2000);
}

function showBackgroundLoadingIndicator() {
    const indicator = document.createElement('div');
    indicator.id = 'bg-loading-indicator';
    indicator.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: var(--card-background);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 12px 16px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
        font-size: 13px;
        color: var(--text-color);
        animation: slideIn 0.3s ease;
    `;
    indicator.innerHTML = `
        <div style="margin-bottom: 4px; font-weight: 500;">Loading older notes...</div>
        <div style="width: 200px; height: 4px; background: var(--background-color); border-radius: 2px; overflow: hidden;">
            <div style="height: 100%; background: var(--primary-color); width: 0%; animation: progressAnim 3s ease-in-out infinite;"></div>
        </div>
    `;
    
    document.body.appendChild(indicator);
}

function hideBackgroundLoadingIndicator() {
    const indicator = document.getElementById('bg-loading-indicator');
    if (indicator) {
        indicator.remove();
    }
}

async function fetchRecentNotesFromRelay(relayUrl, pubkey, since) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        const events = [];
        let timeoutId;
        
        ws.onopen = function() {
            const filter = {
    kinds: [1, 6], // Add kind 6
    authors: [pubkey],
    since: since,
    limit: 2000
};
            
            ws.send(JSON.stringify(['REQ', 'recent-' + Date.now(), filter]));
            
            timeoutId = setTimeout(() => {
                ws.close();
                resolve(events);
            }, 15000); // 15 second timeout
        };
        
        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const [type, subId, eventData] = message;
                
                if (type === 'EVENT') {
                    const note = processNote(eventData);
                    if (note) {
                        events.push(note);
                    }
                } else if (type === 'EOSE') {
                    clearTimeout(timeoutId);
                    ws.close();
                    resolve(events);
                }
            } catch (error) {
                console.error('Error parsing message:', error);
            }
        };
        
        ws.onerror = function() {
            clearTimeout(timeoutId);
            reject(new Error('Connection failed'));
        };
        
        ws.onclose = function() {
            clearTimeout(timeoutId);
            resolve(events);
        };
    });
}

        function processNote(event) {
    if (!event || !event.id) {
        return null;
    }
    
    let content = event.content || '';
    let isRepost = false;
    let isQuote = false;
    let isReply = false;
    
    if (event.kind === 6) {
        // Kind 6 is ONLY a repost - set flag and exit early
        isRepost = true;
        
        if (!content.trim()) {
            content = "Boosted a note";
        } else {
            try {
                const embeddedEvent = JSON.parse(content);
                if (embeddedEvent.content) {
                    content = `Reposted: "${embeddedEvent.content.substring(0, 200)}${embeddedEvent.content.length > 200 ? '...' : ''}"`;
                }
            } catch (e) {
                content = `Reposted: ${content.substring(0, 200)}${content.length > 200 ? '...' : ''}`;
            }
        }
        
        // IMPORTANT: Return early for reposts to prevent further processing
        const hashtags = extractHashtags(content);
        return {
            id: event.id,
            pubkey: event.pubkey,
            created_at: event.created_at,
            content: content,
            hashtags: hashtags,
            isReply: false,    // Explicitly false
            isRepost: true,    // Only this is true
            isQuote: false,    // Explicitly false
            kind: event.kind,
            tags: event.tags || []
        };
        
    } else if (event.kind === 1) {
        // Only process kind 1 events for replies/quotes
        const eTags = event.tags?.filter(tag => tag[0] === 'e') || [];
        const pTags = event.tags?.filter(tag => tag[0] === 'p' && tag[1] !== event.pubkey) || [];
        
        // Check for note references (potential quotes)
        const hasNostrEntity = /nostr:(note1[a-z0-9]{58}|nevent1[a-z0-9]+)/i.test(content);
        const hasNoteRef = /\b(note1[a-z0-9]{58}|nevent1[a-z0-9]+)\b/i.test(content);
        
        if (hasNostrEntity || hasNoteRef) {
            // Has note references - determine if quote or reply
            const hasSubstantialContent = content.trim().length > 50;
            const startsWithMention = content.trim().startsWith('@');
            const hasReplyContext = startsWithMention || content.toLowerCase().includes('replying');
            
            if (hasReplyContext) {
                isReply = true;
            } else if (hasSubstantialContent) {
                isQuote = true;
            } else {
                isReply = true; // Default to reply for short content
            }
        } else if (eTags.length > 0 || pTags.length > 0 || content.trim().startsWith('@')) {
            // Has tags or mentions but no note references - reply
            isReply = true;
        }
        // Otherwise it's an original note (all flags remain false)
    }
    
    const hashtags = extractHashtags(content);
    
    return {
        id: event.id,
        pubkey: event.pubkey,
        created_at: event.created_at,
        content: content,
        hashtags: hashtags,
        isReply: isReply,
        isRepost: isRepost,
        isQuote: isQuote,
        kind: event.kind,
        tags: event.tags || []
    };
}

function getReplyTargetNpub(note) {
    if (!note.tags || !Array.isArray(note.tags)) return null;
    
    // Find p-tags (mentions of other users)
    const pTags = note.tags.filter(tag => tag[0] === 'p' && tag[1]);
    
    if (pTags.length === 0) return null;
    
    // Get the first p-tag (usually the person being replied to)
    const targetPubkey = pTags[0][1];
    
    try {
        // Convert hex pubkey to npub using NostrTools
        if (window.NostrTools && window.NostrTools.nip19) {
            return window.NostrTools.nip19.npubEncode(targetPubkey);
        }
    } catch (error) {
        console.error('Error converting pubkey to npub:', error);
    }
    
    return null;
}

// Add this function to create a shortened display version of npub
function shortenNpub(npub) {
    if (!npub || npub.length < 16) return npub;
    return npub.substring(0, 12) + '...' + npub.substring(npub.length - 8);
}

// Add this temporary debug function to check classifications
function debugNoteClassifications() {
    if (!allNotes.length) {
        console.log('No notes loaded');
        return;
    }
    
    const sample = allNotes.slice(0, 20);
    console.log('=== NOTE CLASSIFICATION DEBUG ===');
    
    sample.forEach(note => {
        const flags = [];
        if (note.isReply) flags.push('REPLY');
        if (note.isRepost) flags.push('REPOST');
        if (note.isQuote) flags.push('QUOTE');
        if (flags.length === 0) flags.push('ORIGINAL');
        
        console.log(`${note.id.substring(0, 8)}: [${flags.join(', ')}] "${note.content.substring(0, 50)}..."`);
    });
    
    const totals = {
        original: allNotes.filter(n => !n.isReply && !n.isRepost && !n.isQuote).length,
        replies: allNotes.filter(n => n.isReply).length,
        reposts: allNotes.filter(n => n.isRepost).length,
        quotes: allNotes.filter(n => n.isQuote).length,
        multipleFlags: allNotes.filter(n => [n.isReply, n.isRepost, n.isQuote].filter(Boolean).length > 1).length
    };
    
    console.log('TOTALS:', totals);
    console.log('Notes with multiple flags (should be 0):', totals.multipleFlags);
}

// Make it globally available
window.debugNoteClassifications = debugNoteClassifications;

// ADD these functions after your clearIndexedDB functions (around line 2500):

// 1. ADD this function to show storage usage information
async function showStorageInfo() {
    try {
        let info = {
            localStorage: 0,
            indexedDB: 0,
            totalNotes: allNotes.length,
            loadedNotes: allNotes.length,
            archives: Object.keys(namedArchives).length,
            totalArchived: 0
        };
        
        // Calculate localStorage usage
        let localStorageSize = 0;
        for (let key in localStorage) {
            if (localStorage.hasOwnProperty(key)) {
                localStorageSize += localStorage[key].length + key.length;
            }
        }
        info.localStorage = (localStorageSize / 1024).toFixed(2); // KB
        
        // Calculate IndexedDB usage and note count
        if (db && useIndexedDB) {
            try {
                const totalInDB = await db.notes.count();
                info.totalNotes = totalInDB;
            } catch (error) {
                console.log('Could not get IndexedDB count:', error);
            }
        }
        
        // Calculate archived notes
        Object.values(namedArchives).forEach(archive => {
            info.totalArchived += archive.size;
        });
        
        // Show storage info modal
        const modalHtml = `
            <div class="modal" onclick="closeStorageInfo(event)">
                <div class="modal-content" onclick="event.stopPropagation()">
                    <button class="modal-close" onclick="closeStorageInfo()">Close</button>
                    <h3>Storage Information</h3>
                    <div style="font-family: monospace; line-height: 1.6;">
                        <p><strong>Notes:</strong></p>
                        <p>  • Total stored: ${info.totalNotes.toLocaleString()}</p>
                        <p>  • Currently loaded: ${info.loadedNotes.toLocaleString()}</p>
                        <p>  • Memory usage: ~${(info.loadedNotes * 0.5).toFixed(1)} KB</p>
                        
                        <p><strong>Archives:</strong></p>
                        <p>  • Number of archives: ${info.archives}</p>
                        <p>  • Total archived notes: ${info.totalArchived}</p>
                        
                        <p><strong>Storage:</strong></p>
                        <p>  • LocalStorage: ${info.localStorage} KB</p>
                        <p>  • IndexedDB: ${useIndexedDB ? 'Active' : 'Not available'}</p>
                        
                        <p><strong>Performance:</strong></p>
                        <p>  • Load time: ${getLastLoadTime()}</p>
                        <p>  • Memory status: ${getMemoryStatus(info.loadedNotes)}</p>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <button class="btn btn-small" onclick="exportStorageReport()" style="background: var(--primary-color); margin-right: 10px;">
    Export Report
</button>
<button class="btn btn-small" onclick="optimizeStorage()" style="background: var(--success-color);">
    Optimize Storage
</button>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
    } catch (error) {
        showToast('Error getting storage info: ' + error.message, 'error');
    }
}

// App info modal function
async function showAppInfo() {
    const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
    
    const modalHtml = `
        <div class="modal" onclick="closeAppInfo(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeAppInfo()">Close</button>
                <h3>${isNeonGreen ? 'Nostr Notes Archive' : '📝 Nostr Notes Archive'}</h3>
                
                <div style="line-height: 1.6; margin-bottom: 24px;">
                    <p><strong>What is this app?</strong></p>
                    <p>This is a browser-based tool for viewing, organizing, and archiving your notes. It connects directly to Nostr relays to fetch your posts and allows you to organize them into custom archives for better management.</p>
                </div>

                <div style="line-height: 1.6; margin-bottom: 24px;">
                    <p><strong>Key Features:</strong></p>
                    <ul style="margin-left: 20px; margin-top: 8px;">
                        <li>View all your original notes and replies</li>
                        <li>Create custom archives to organize notes</li>
                        <li>Search by content, hashtags, and date ranges</li>
                        <li>Filter by images, videos, and note length</li>
                        <li>Export notes as JSON or Markdown</li>
                        <li>Fast IndexedDB caching for better performance</li>
                        <li>Multiple theme options including Neon Green</li>
                        <li>Keyboard shortcuts for power users</li>
                    </ul>
                </div>

                <div style="line-height: 1.6; margin-bottom: 24px;">
                    <p><strong>Privacy & Security:</strong></p>
                    <p>Your data stays in your browser. The app only connects to public Nostr relays to read your posts. No data is sent to external servers except for the relay connections needed to fetch your notes.</p>
                </div>

                <div style="background: var(--background-color); padding: 16px; border-radius: 8px; border-left: 4px solid var(--primary-color); margin-bottom: 24px;">
                    <p><strong>Created by Romeo</strong></p>
                    <p style="font-family: monospace; font-size: 13px; word-break: break-all; margin-top: 8px;">
                        <strong>Npub:</strong> npub12p5753xcjal8034w5czap3fcdvj9qj36h5873g73ea05emw2gznszr0ann
                    </p>
                    <button onclick="copyToClipboard('npub12p5753xcjal8034w5czap3fcdvj9qj36h5873g73ea05emw2gznszr0ann')" 
                            class="copy-btn" style="margin-top: 8px;">
                        Copy NPUB
                    </button>
                </div>

                <div style="text-align: center; font-size: 13px; color: var(--text-muted);">
                    <p>Built with ❤️ for the Nostr community</p>
                    <p style="margin-top: 8px;">Version 1.0 • Open Source • No Tracking</p>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeAppInfo(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

// 2. Helper functions for storage info
function getLastLoadTime() {
    const lastLoad = localStorage.getItem('nostr-last-load-time');
    if (lastLoad) {
        const seconds = (Date.now() - parseInt(lastLoad)) / 1000;
        return seconds < 60 ? `${seconds.toFixed(1)}s ago` : `${(seconds/60).toFixed(1)}m ago`;
    }
    return 'Unknown';
}

function getMemoryStatus(noteCount) {
    if (noteCount < 25000) return 'Excellent';
    if (noteCount < 75000) return 'Good'; 
    if (noteCount < 150000) return 'Fair';
    return 'High';
}

function closeStorageInfo(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

// 3. ADD storage optimization function
async function optimizeStorage() {
    try {
        let optimized = [];
        let freedSpace = 0;
        
        // Clear old localStorage entries from other users
        const keysToCheck = Object.keys(localStorage);
        keysToCheck.forEach(key => {
            if (key.startsWith('nostr-cached-notes-') && key !== `nostr-cached-notes-${currentPubkey}`) {
                const size = localStorage[key]?.length || 0;
                localStorage.removeItem(key);
                freedSpace += size;
                optimized.push('Removed old user cache');
            }
            if (key.startsWith('nostr-last-pubkey-') && key !== `nostr-last-pubkey-${currentPubkey}`) {
                localStorage.removeItem(key);
                optimized.push('Cleaned old pubkey data');
            }
        });
        
        // Clean up empty archives (this is actually useful)
        let emptyArchives = 0;
        Object.keys(namedArchives).forEach(archiveName => {
            if (namedArchives[archiveName].size === 0) {
                delete namedArchives[archiveName];
                emptyArchives++;
            }
        });
        if (emptyArchives > 0) {
            optimized.push(`Removed ${emptyArchives} empty archives`);
        }
        
        // Clear IndexedDB cache to force fresh relay fetch on next load
        if (db && useIndexedDB) {
            await db.settings.delete('last_sync_time');
            optimized.push('Reset sync cache (will fetch fresh data next time)');
        }
        
        if (optimized.length > 0) {
            if (emptyArchives > 0) saveArchivedNotes();
            const spaceSaved = freedSpace > 0 ? ` (freed ${(freedSpace/1024).toFixed(1)} KB)` : '';
            showToast(`Optimized: ${optimized.join(', ')}${spaceSaved}`, 'success');
        } else {
            showToast('Nothing to optimize - storage is clean!', 'success');
        }
        
        closeStorageInfo();
        
    } catch (error) {
        showToast('Error optimizing storage: ' + error.message, 'error');
    }
}

function exportStorageReport() {
    const report = {
        generated_at: new Date().toISOString(),
        user_pubkey: currentPubkey ? currentPubkey.substring(0, 16) + '...' : 'none',
        stats: {
            total_notes_stored: allNotes.length,
            notes_currently_loaded: allNotes.length,
            archives_count: Object.keys(namedArchives).length,
            total_archived_notes: Object.values(namedArchives).reduce((sum, archive) => sum + archive.size, 0),
            hashtags_found: new Set(allNotes.flatMap(note => note.hashtags || [])).size,
            replies_count: allNotes.filter(note => note.isReply).length,
            original_notes_count: allNotes.filter(note => !note.isReply).length
        },
        performance: {
            indexeddb_active: useIndexedDB,
            memory_status: getMemoryStatus(allNotes.length),
            relays_configured: RELAYS.length,
            last_load_time: getLastLoadTime()
        },
        archives: Object.keys(namedArchives).map(name => ({
            name: name,
            note_count: namedArchives[name].size
        }))
    };
    
    downloadFile(
        JSON.stringify(report, null, 2),
        `nostr-storage-report-${new Date().toISOString().split('T')[0]}.json`,
        'application/json'
    );
    
    showToast('Storage report exported!', 'success');
}

// 5. ADD function to track load times
function trackLoadTime() {
    localStorage.setItem('nostr-last-load-time', Date.now().toString());
}

        function extractHashtags(content) {
            const matches = content.match(/#\w+/g);
            return matches ? matches.map(tag => tag.toLowerCase()) : [];
        }

        function updateTagFilters() {
    const tagCounts = {};
    
    // Process hashtags - removed performance-killing logs
    allNotes.forEach(note => {
        if (note.hashtags && Array.isArray(note.hashtags)) {
            note.hashtags.forEach(tag => {
                tagCounts[tag] = (tagCounts[tag] || 0) + 1;
            });
        }
    });
    
    const archivedCount = allNotes.filter(note => archivedNotes.has(note.id)).length;
    const originalNotesCount = allNotes.filter(note => !note.isReply && !note.isRepost && !note.isQuote).length;
    const repliesCount = allNotes.filter(note => note.isReply).length;
    const repostsCount = allNotes.filter(note => note.isRepost).length;
    const quotesCount = allNotes.filter(note => note.isQuote).length;
    
    const container = document.getElementById('tag-filters');

    if (!container) {
        console.error('tag-filters container not found!');
        return;
    }

    container.innerHTML = `
    <button class="tag-filter active" data-tag="">All Notes (${allNotes.length})</button>
    <button class="tag-filter" data-tag="__original"><span class="emoji">📄</span> Original Notes (${originalNotesCount})</button>
    <button class="tag-filter" data-tag="__replies"><span class="emoji">💬</span> Replies (${repliesCount})</button>
    <button class="tag-filter" data-tag="__reposts"><span class="emoji">🔄</span> Reposts (${repostsCount})</button>
    <button class="tag-filter" data-tag="__quotes"><span class="emoji">💭</span> Quotes (${quotesCount})</button>
`;

    // Group hashtags alphabetically
    const hashtagGroups = {};
    Object.keys(tagCounts).sort((a, b) => a.localeCompare(b)).forEach(tag => {
        const firstLetter = tag.charAt(1).toUpperCase(); // Skip the # symbol
        if (!hashtagGroups[firstLetter]) {
            hashtagGroups[firstLetter] = [];
        }
        hashtagGroups[firstLetter].push(tag);
    });

    // Add grouped hashtags with collapsible sections
    Object.keys(hashtagGroups).sort().forEach(letter => {
        const groupCount = hashtagGroups[letter].length;
        
        // Add clickable letter header
        const letterHeader = document.createElement('button');
        letterHeader.className = 'hashtag-group-header';
        letterHeader.style.cssText = `
            width: 100%;
            text-align: left;
            background: var(--background-color);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            margin: 8px 0 0 0;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: var(--text-color);
            font-size: 13px;
            transition: background-color 0.2s ease;
        `;
        letterHeader.textContent = `${letter} (${groupCount} hashtags)`;
        letterHeader.onclick = () => toggleHashtagGroup(letter);
        container.appendChild(letterHeader);
        
        // Add container for hashtags (initially hidden)
        const hashtagContainer = document.createElement('div');
        hashtagContainer.id = `hashtag-group-${letter}`;
        hashtagContainer.style.cssText = `
            display: none;
            margin: 0 0 8px 0;
            padding: 4px 0;
            border-left: 2px solid var(--border-color);
            padding-left: 8px;
        `;
        
        hashtagGroups[letter].forEach(tag => {
            const button = document.createElement('button');
            button.className = 'tag-filter';
            button.dataset.tag = tag;
            button.textContent = `${tag} (${tagCounts[tag]})`;
            button.addEventListener('click', () => toggleTag(tag));
            hashtagContainer.appendChild(button);
        });
        
        container.appendChild(hashtagContainer);
    });
    
    // Add click handlers
    const allNotesBtn = container.querySelector('[data-tag=""]');
    const originalBtn = container.querySelector('[data-tag="__original"]');
    const repliesBtn = container.querySelector('[data-tag="__replies"]');
    const repostsBtn = container.querySelector('[data-tag="__reposts"]');
    const quotesBtn = container.querySelector('[data-tag="__quotes"]');

    if (allNotesBtn) allNotesBtn.addEventListener('click', () => toggleTag(''));
    if (originalBtn) originalBtn.addEventListener('click', () => toggleTag('__original'));
    if (repliesBtn) repliesBtn.addEventListener('click', () => toggleTag('__replies'));
    if (repostsBtn) repostsBtn.addEventListener('click', () => toggleTag('__reposts'));
    if (quotesBtn) quotesBtn.addEventListener('click', () => toggleTag('__quotes'));

    setActiveTagButtons();

    // --- one-time drag-select listeners for tag filters ---
    (function initTagDragOnce() {
        const tagFiltersEl = document.getElementById('tag-filters');
        if (!tagFiltersEl || tagFiltersEl.__dragInit) return;

        // Start drag only with LEFT button and only on real hashtags (e.g., "#coffee")
        tagFiltersEl.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;                         // left click only
            const btn = e.target.closest('.tag-filter');
            if (!btn) return;
            const tag = btn.dataset.tag;
            if (!tag || !tag.startsWith('#')) return;           // ignore All/Original/Replies
            startHashtagSelection(tag, e);                      // decides add/remove mode
        });

        // Continue while holding the button, over real hashtags only
        tagFiltersEl.addEventListener('mouseover', (e) => {
            if (!isSelecting) return;                           // set by startHashtagSelection
            const btn = e.target.closest('.tag-filter');
            if (!btn) return;
            const tag = btn.dataset.tag;
            if (!tag || !tag.startsWith('#')) return;
            continueHashtagSelection(tag, e);
        });

        // End drag anywhere
        document.addEventListener('mouseup', endHashtagSelection);

        tagFiltersEl.__dragInit = true;                       // guard against rebinding
    })();
}

        function filterByTag(tag) {
            currentTag = tag;

            document.getElementById('date-from').value = '';
            document.getElementById('date-to').value = '';
            
            // Update active button
            document.querySelectorAll('.tag-filter').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tag === tag) {
                    btn.classList.add('active');
                }
            });
            
            applyFilters();
            renderNotes();
            setActiveTagButtons();
        }

        function toggleHashtagGroup(letter) {
    const container = document.getElementById(`hashtag-group-${letter}`);
    
    if (container.style.display === 'none') {
        container.style.display = 'block';
    } else {
        container.style.display = 'none';
    }
}

function setActiveTagButtons() {
  const buttons = document.querySelectorAll('#tag-filters .tag-filter');
  buttons.forEach(btn => {
    const t = btn.dataset.tag || '';
    
    // Clear existing active state
    btn.classList.remove('active');
    
    // "All Notes" is active only when nothing is selected AND we're not in archive view
    if (t === '' && selectedTags.size === 0 && !currentTag.startsWith('__archive_')) {
      btn.classList.add('active');
    } 
    // Hashtag buttons are active when they're in selectedTags (regardless of archive view)
    else if (t !== '' && selectedTags.has(t)) {
      btn.classList.add('active');
    }
    // Special buttons (Original Notes, Replies) are active when selected
    else if (t === '__original' && selectedTags.has('__original')) {
      btn.classList.add('active');
    }
    else if (t === '__replies' && selectedTags.has('__replies')) {
      btn.classList.add('active');
    }
    else if (t === '__reposts' && selectedTags.has('__reposts')) {
      btn.classList.add('active');
    }
    else if (t === '__quotes' && selectedTags.has('__quotes')) {
      btn.classList.add('active');
    }
  });
}

function applyDateFilters() {
    // Clear archive selection when manually setting dates
    const dateFrom = document.getElementById('date-from').value;
    const dateTo = document.getElementById('date-to').value;
    
    if (dateFrom || dateTo) {
        currentArchive = 'default';
        currentTag = '';
        selectedTags.clear();
        
        // Clear archive active states
        document.querySelectorAll('.archive-item').forEach(item => {
            item.classList.remove('active');
        });
        
        // Clear tag filter active states
        document.querySelectorAll('.tag-filter').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Set "All Notes" as active
        document.querySelector('.tag-filter[data-tag=""]').classList.add('active');
    }
    
    applyAllFilters();
}


// Make it globally available
window.toggleHashtagGroup = toggleHashtagGroup;
        // === Multi-tag selection helpers ===
function toggleTag(tag) {
    // Only clear archive state for special tags, not hashtags
    if (!tag.startsWith('#')) {
        // Clear archive active states when selecting any tag (but NOT quick filters)
        currentArchive = 'default';
        document.querySelectorAll('.archive-item').forEach(item => {
            item.classList.remove('active');
        });
        
        // Clear date filters when selecting non-hashtag tags
        document.getElementById('date-from').value = '';
        document.getElementById('date-to').value = '';
    }
    
    if (!tag) {
        // "All Notes" clears ALL selections including quick filters
        selectedTags.clear();
        currentTag = '';
        activeQuickFilters.clear(); // Clear quick filters only for "All Notes"
        
        // Clear quick filter buttons
        document.querySelectorAll('.quick-filter-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Set "All Notes" as active
        document.querySelectorAll('.tag-filter').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.tag === '') {
                btn.classList.add('active');
            }
        });
        
        // Use simple filtering for "All Notes"
        window.inAdvancedSearchMode = false;
        filteredNotes = allNotes.slice();
        resetPagination();
        renderNotes();
        return;
    } 
    
    // For hashtag/content type selection, work WITH quick filters, not against them
    if (selectedTags.has(tag)) {
    selectedTags.delete(tag);
    
    // If no tags selected after removal, check if we have quick filters
    if (selectedTags.size === 0 && activeQuickFilters.size > 0) {
        // We still have quick filters active, so use advanced search
        applyAllFilters();
    } else if (selectedTags.size === 0 && activeQuickFilters.size === 0) {
        // If we're in an archive, stay in the archive but show all notes from that archive
        if (currentArchive !== 'default' && currentTag.startsWith('__archive_')) {
            // Stay in archive, just remove hashtag filter
            applyFilters();
            renderNotes();
        } else {
            // Nothing active, go to "All Notes"
            currentTag = '';
            document.querySelectorAll('.tag-filter').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tag === '') {
                    btn.classList.add('active');
                }
            });
            window.inAdvancedSearchMode = false;
            filteredNotes = allNotes.slice();
            resetPagination();
            renderNotes();
        }
    } else {
        // Other tags still selected, continue with appropriate filtering
        if (activeQuickFilters.size > 0) {
            applyAllFilters();
        } else {
            applyFilters();
            renderNotes();
        }
    }
    } else {
        selectedTags.add(tag);
        
        // Check if all content types are selected - that equals "All Notes"
        const hasOriginal = selectedTags.has('__original');
        const hasReplies = selectedTags.has('__replies');
        const hasReposts = selectedTags.has('__reposts');
        const hasQuotes = selectedTags.has('__quotes');
        
        // If all 4 content types are selected, clear them but keep quick filters
        if (hasOriginal && hasReplies && hasReposts && hasQuotes && selectedTags.size === 4) {
            selectedTags.clear();
            currentTag = '';
            
            if (activeQuickFilters.size > 0) {
                // Quick filters are active, use advanced search
                applyAllFilters();
            } else {
                // No filters active, go to "All Notes"
                document.querySelectorAll('.tag-filter').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.tag === '') {
                        btn.classList.add('active');
                    }
                });
                window.inAdvancedSearchMode = false;
                filteredNotes = allNotes.slice();
                resetPagination();
                renderNotes();
            }
        } else if (hasOriginal && hasReplies && selectedTags.size === 2 && !hasReposts && !hasQuotes) {
            // If only original and replies are selected, clear them but keep quick filters
            selectedTags.clear();
            currentTag = '';
            
            if (activeQuickFilters.size > 0) {
                // Quick filters are active, use advanced search
                applyAllFilters();
            } else {
                // No filters active, go to "All Notes"
                document.querySelectorAll('.tag-filter').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.tag === '') {
                        btn.classList.add('active');
                    }
                });
                window.inAdvancedSearchMode = false;
                filteredNotes = allNotes.slice();
                resetPagination();
                renderNotes();
            }
        } else {
            // Normal tag selection - use appropriate filter system
            if (activeQuickFilters.size > 0) {
                applyAllFilters();
            } else {
                applyFilters();
                renderNotes();
            }
        }
    }
    
    setActiveTagButtons();
}

function noteMatchesTag(note, tag) {
    if (tag === '__original') return !note.isReply && !note.isRepost && !note.isQuote;
    if (tag === '__replies') return note.isReply;
    if (tag === '__reposts') return note.isRepost;
    if (tag === '__quotes') return note.isQuote;
    if (tag === '__archived') return archivedNotes.has(note.id);
    if (tag.startsWith('__archive_')) {
        const name = tag.replace('__archive_', '');
        return namedArchives[name] && namedArchives[name].has(note.id);
    }
    return note.hashtags && note.hashtags.includes(tag);
}

        function handleSearch() {
    searchQuery = document.getElementById('search-input').value.toLowerCase();
    
    // If there are active quick filters, use the advanced search system
    if (activeQuickFilters.size > 0) {
        applyAllFilters();
    } else {
        // Use the simple filter system
        applyFilters();
        renderNotes();
    }
}

      function applyFilters() {
    // If we have active quick filters, delegate to the advanced search system
    if (activeQuickFilters.size > 0) {
        applyAllFilters();
        return;
    }
    
    // Original applyFilters logic continues here...
    filteredNotes = allNotes.slice();

    // If multiple tags are selected, keep notes that match ANY selected tag
    if (selectedTags.size > 0) {
        const tags = Array.from(selectedTags);
        
        // If we're in an archive context, first filter by archive, then by hashtags
        if (currentTag && currentTag.startsWith('__archive_')) {
            const archiveName = currentTag.replace('__archive_', '');
            if (namedArchives[archiveName]) {
                // First filter to only notes in this archive
                filteredNotes = filteredNotes.filter(note => namedArchives[archiveName].has(note.id));
                // Then filter by selected hashtags within that archive
                filteredNotes = filteredNotes.filter(note =>
                    tags.some(tag => noteMatchesTag(note, tag))
                );
            }
        } else {
            // Normal hashtag filtering (not in archive context)
            filteredNotes = filteredNotes.filter(note =>
                tags.some(tag => noteMatchesTag(note, tag))
            );
        }
    } else {
        // Fall back to old single-select behavior (currentTag)
        if (currentTag === '__archived') {
            filteredNotes = filteredNotes.filter(note => archivedNotes.has(note.id));
        } else if (currentTag === '__original') {
            filteredNotes = filteredNotes.filter(note => !note.isReply && !note.isRepost && !note.isQuote);
        } else if (currentTag === '__replies') {
            filteredNotes = filteredNotes.filter(note => note.isReply);
        } else if (currentTag === '__reposts') {
            filteredNotes = filteredNotes.filter(note => note.isRepost);
        } else if (currentTag === '__quotes') {
            filteredNotes = filteredNotes.filter(note => note.isQuote);
        } else if (currentTag && currentTag.startsWith('__archive_')) {
            const archiveName = currentTag.replace('__archive_', '');
            if (namedArchives[archiveName]) {
                filteredNotes = filteredNotes.filter(note => namedArchives[archiveName].has(note.id));
            }
        } else if (currentTag) {
            filteredNotes = filteredNotes.filter(note => note.hashtags.includes(currentTag));
        }
        // If no specific tag, show ALL notes (don't filter)
    }

    // Enhanced text search - NOW INCLUDES NPUB SEARCHING
    if (searchQuery) {
        const q = searchQuery.toLowerCase();
        filteredNotes = filteredNotes.filter(note => {
            // Search in content
            if (note.content.toLowerCase().includes(q)) return true;
            
            // Search in hashtags
            if (note.hashtags && note.hashtags.some(tag => tag.includes(q))) return true;
            
            // NEW: Search in reply target npub
            if (note.isReply) {
                const replyTargetNpub = getReplyTargetNpub(note);
                if (replyTargetNpub && replyTargetNpub.toLowerCase().includes(q)) {
                    return true;
                }
                
                // Also search in the hex pubkey if searching by npub prefix
                if (note.tags && Array.isArray(note.tags)) {
                    const pTags = note.tags.filter(tag => tag[0] === 'p' && tag[1]);
                    if (pTags.length > 0) {
                        const targetPubkey = pTags[0][1];
                        if (targetPubkey.toLowerCase().includes(q)) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        });
    }

    // Reset pagination when filters change
    resetPagination();
}



        function renderNotes() {
    const container = document.getElementById('notes-container');
    const emptyState = document.getElementById('empty-state');
    const loadMoreContainer = document.getElementById('load-more-container');
    const paginationInfo = document.getElementById('pagination-info');
    const title = document.getElementById('notes-title');
    const count = document.getElementById('notes-count');
    
    if (!container) {
        console.error('notes-container not found!');
        return;
    }
    
    // Calculate how many notes to show
    const totalToShow = Math.min(currentPage * notesPerPage, filteredNotes.length);
    const notesToRender = filteredNotes.slice(0, totalToShow);
            
    // Update title and count
    if (selectedTags.size > 0) {
    // Check if we're in an archive context
    if (currentArchive !== 'default' && currentTag.startsWith('__archive_')) {
        const archiveName = currentTag.replace('__archive_', '');
        const tagNames = Array.from(selectedTags).map(tag => {
            if (tag === '__original') return 'Original Notes';
            if (tag === '__replies') return 'Replies';
            if (tag === '__reposts') return 'Reposts';
            if (tag === '__quotes') return 'Quotes';
            if (tag === '__archived') return 'Archived';
            return tag;
        });
        // Show archive context with selected tags
        title.textContent = `Archive: ${archiveName} (${tagNames.join(' + ')})`;
    } else {
        // Check if all content types are selected - that's equivalent to "All Notes"
        const hasOriginal = selectedTags.has('__original');
        const hasReplies = selectedTags.has('__replies');
        const hasReposts = selectedTags.has('__reposts');
        const hasQuotes = selectedTags.has('__quotes');
        
        if ((hasOriginal && hasReplies && selectedTags.size === 2) ||
            (hasOriginal && hasReplies && hasReposts && hasQuotes && selectedTags.size === 4)) {
            // If only original and replies are selected, OR all 4 types are selected, show "All Notes"
            title.textContent = 'All Notes';
        } else {
            // Multi-tag selection takes priority
            const tagNames = Array.from(selectedTags).map(tag => {
                if (tag === '__original') return 'Original Notes';
                if (tag === '__replies') return 'Replies';
                if (tag === '__reposts') return 'Reposts';
                if (tag === '__quotes') return 'Quotes';
                if (tag === '__archived') return 'Archived';
                return tag;
            });
            title.textContent = tagNames.join(' + ');
        }
    }
    } else if (currentTag === '__archived') {
        title.textContent = 'All Archived Notes';
    } else if (currentTag === '__original') {
        title.textContent = 'Original Notes';
    } else if (currentTag === '__replies') {
        title.textContent = 'Replies';
    } else if (currentTag === '__reposts') {
        title.textContent = 'Reposts';
    } else if (currentTag === '__quotes') {
        title.textContent = 'Quotes';
    } else if (currentTag.startsWith('__archive_')) {
        const archiveName = currentTag.replace('__archive_', '');
        // Check if neon-green theme is active
        const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
        title.textContent = isNeonGreen ? `Archive: ${archiveName}` : `📂 Archive: ${archiveName}`;
        title.style.color = 'var(--text-muted)';
    } else if (currentTag) {
        title.textContent = `Notes tagged ${currentTag}`;
        title.style.color = '';     // Reset color
        title.style.fontWeight = ''; // Reset weight
    } else {
        title.textContent = 'All Notes';
        title.style.color = '';     // Reset color
        title.style.fontWeight = ''; // Reset weight
    }
    count.textContent = `${filteredNotes.length} notes`;

    if (filteredNotes.length === 0) {
        container.innerHTML = '';
        loadMoreContainer.classList.add('hidden');
        if (emptyState) emptyState.classList.remove('hidden');
        updateSelectionUI();
        return;
    }

    // Update export button text to show what will be exported
    const exportJsonBtn = document.getElementById('export-json');
    const exportMdBtn = document.getElementById('export-md');
    // Define isNeonGreen here so it can be used below
    const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';

    if (currentTag.startsWith('__archive_')) {
        const archiveName = currentTag.replace('__archive_', '');
        if (exportJsonBtn) exportJsonBtn.textContent = `Export "${archiveName}" JSON`;
        if (exportMdBtn) exportMdBtn.textContent = `Export "${archiveName}" Markdown`;
    } else {
        if (exportJsonBtn) exportJsonBtn.textContent = 'Export JSON';
        if (exportMdBtn) exportMdBtn.textContent = 'Export Markdown';
    }

    if (emptyState) emptyState.classList.add('hidden');

    // Only show load more button if we're not currently loading AND there are more notes to show
    // Show load more button logic
    const hasMoreNotes = totalToShow < filteredNotes.length;

    if (hasMoreNotes && filteredNotes.length > 0) {
        loadMoreContainer.classList.remove('hidden');
        paginationInfo.textContent = `Showing ${totalToShow} of ${filteredNotes.length} notes`;
    } else {
        loadMoreContainer.classList.add('hidden');
        if (filteredNotes.length > 0) {
            paginationInfo.textContent = `Showing all ${filteredNotes.length} notes`;
        }
    }
            
    // Render notes in chunks to prevent blocking
    const renderInChunks = async () => {
        const chunkSize = 50; // Smaller chunks for rendering
        let html = '';
        
        for (let i = 0; i < notesToRender.length; i += chunkSize) {
            const chunk = notesToRender.slice(i, i + chunkSize);
                
            chunk.forEach(note => {
                const date = new Date(note.created_at * 1000).toLocaleString();
                const isArchived = archivedNotes.has(note.id);
                const isSelected = selectedNotes.has(note.id);
                
                const hashtagsHtml = note.hashtags && note.hashtags.length > 0 ? 
                    note.hashtags.map(tag => {
                        const isSelected = selectedTags.has(tag);
                        return `<span class="hashtag" 
                               onmousedown="startHashtagSelection('${tag}', event)" 
                               onmouseenter="continueHashtagSelection('${tag}', event)"
                               ontouchstart="startHashtagSelection('${tag}', event)"
                               data-tag="${tag}"
                               ${isSelected ? 'data-selected="true"' : ''}>${tag}</span>`;
                    }).join(' ') : '';
                
                // Different styling for different note types
const cardClass = `note-card ${isArchived ? 'archived' : ''} ${note.isReply ? 'reply-card' : ''} ${note.isRepost ? 'repost-card' : ''} ${note.isQuote ? 'quote-card' : ''}`;

// Set appropriate indicator based on note type
let noteIndicator = '<span class="emoji">📄</span> '; // Default for original notes
if (note.isRepost) {
    noteIndicator = '<span class="emoji">🔄</span> ';
} else if (note.isQuote) {
    noteIndicator = '<span class="emoji">💭</span> ';
} else if (note.isReply) {
    // Get the npub they're replying to
    const replyTargetNpub = getReplyTargetNpub(note);
    if (replyTargetNpub) {
        const shortNpub = shortenNpub(replyTargetNpub);
        noteIndicator = `<span class="emoji">💬</span> Replying to <button onclick="copyToClipboard('${replyTargetNpub}')" class="npub-copy-btn" title="Click to copy full npub">${shortNpub}</button> `;
    } else {
        noteIndicator = '<span class="emoji">💬</span> ';
    }
}
                
                // IMPROVED: Check if we're in a specific archive view
                const isInSpecificArchive = currentTag.startsWith('__archive_');
                const currentArchiveName = isInSpecificArchive ? currentTag.replace('__archive_', '') : '';
                const isNoteInCurrentArchive = isInSpecificArchive && namedArchives[currentArchiveName] && namedArchives[currentArchiveName].has(note.id);
                
                // Create the appropriate archive button
                let archiveButtonHtml = '';
                if (isInSpecificArchive && isNoteInCurrentArchive) {
                    // We're viewing a specific archive and this note is in it - show "Remove from [archive]"
                    archiveButtonHtml = `
                        <button class="btn btn-small" style="background: #e74c3c; color: white;" 
                                onclick="removeFromSpecificArchive('${note.id}', '${currentArchiveName}')">
                            <span class="emoji">🗑️</span> Remove
                        </button>`;
                } else {
                    // Normal archive/unarchive button
                    archiveButtonHtml = `
                        <button class="btn btn-small btn-archive ${isArchived ? 'archived' : ''}" 
                                onclick="toggleArchiveNote('${note.id}')">
                            ${isArchived ? '✓ Archived' : '<span class="emoji">📂</span> Archive'}
                        </button>`;
                }
                
                html += `
                    <div class="${cardClass}">
                        <div class="note-header">
                            <div style="display: flex; align-items: center;">
                                <input type="checkbox" class="note-checkbox" ${isSelected ? 'checked' : ''} 
                                       onchange="toggleNoteSelection('${note.id}')">
                                <span>${noteIndicator}${date}</span>
                            </div>
                            <div class="note-actions">
                                ${archiveButtonHtml}
                                <button class="btn btn-small" style="background: #95a5a6;" 
                                        onclick="showNoteInfo('${note.id}')">
                                    <span class="emoji">ℹ️</span> Info
                                </button>
                            </div>
                        </div>
                        <div class="note-content">${makeLinksClickable(processYouTubeLinks(processImageLinks(escapeHtml(note.content))))}</div>
                        ${hashtagsHtml ? `<div class="hashtags">${hashtagsHtml}</div>` : ''}
                    </div>
                `;
            });
                
            // Update progress and yield control
            if (i % 100 === 0) {
                await new Promise(resolve => setTimeout(resolve, 1));
            }
        }
        
        container.innerHTML = html;
        setupLazyLoading();
        updateSelectionUI();
        setupHashtagDragSelection();
    };
    
    renderInChunks();
}


        function refreshNotes() {
    if (!currentPubkey) {
        showToast('No user connected - cannot refresh', 'error');
        return;
    }
    
    showToast('Refreshing notes...', 'success', 2000);
    
    // Use incremental refresh instead of full fetch
    loadNotesIncremental(true); // true = isRefresh
}

async function loadNotesIncremental(isRefresh = false) {
    const previousNotesCount = allNotes.length;
    
    try {
        if (isRefresh) {
            updateStatus('Checking for new notes...');
        } else {
            showLoading(true);
            updateStatus('Loading notes...', true);
        }
        
        // Get the timestamp of our newest note
        const newestNote = allNotes.length > 0 ? allNotes[0] : null;
        const sinceTimestamp = newestNote ? newestNote.created_at : 0;
        
        updateStatus(`Looking for notes newer than ${newestNote ? new Date(sinceTimestamp * 1000).toLocaleString() : 'beginning'}...`);
        
        // Fetch only newer notes
        const newNotes = await fetchNotesFromRelaysSince(currentPubkey, sinceTimestamp);
        
        if (newNotes.length > 0) {
            // Add new notes to the beginning of our array
            allNotes.unshift(...newNotes);
            allNotes.sort((a, b) => b.created_at - a.created_at);
            
            // Update chunked storage with new notes
            const chunkStorage = new ChunkedNoteStorage(currentPubkey);
            const chunkReady = await chunkStorage.init();
            
            if (chunkReady) {
                await chunkStorage.storeNotesInChunks(allNotes);
                updateStatus(`Updated chunked storage with ${newNotes.length} new notes`);
            }
            
            updateArchiveList();
            updateTargetArchiveDropdown();
            updateTagFilters();
            applyFilters();
            renderNotes();
            
            showToast(`Found ${newNotes.length} new notes!`, 'success');
        } else {
            showToast('No new notes found', 'success');
        }
        
        updateStatus(`✅ Refresh complete: ${newNotes.length} new notes (${allNotes.length} total)`);
        
    } catch (error) {
        console.error('Refresh failed:', error);
        showToast('Refresh failed: ' + error.message, 'error');
    } finally {
        if (!isRefresh) {
            showLoading(false);
        }
    }
}

async function loadNotesForced(isRefresh = false) {
    const previousNotesCount = allNotes.length;
    
    if (!isRefresh) {
        showLoading(true);
        updateProgress(0, 'Connecting to relays.');
        updateStatus('Starting fresh load...', true);
    } else {
        updateStatus('Refreshing notes from relays...');
    }
    
    try {
        let notes;
        
        if (isRefresh) {
            // Force fresh fetch from relays for refresh
            updateProgress(20, 'Fetching fresh notes from relays...');
            notes = await fetchNotesFromRelays(currentPubkey);
            
            // Store in chunked format after successful refresh
            const chunkStorage = new ChunkedNoteStorage(currentPubkey);
            const chunkReady = await chunkStorage.init();
            
            if (chunkReady && notes.length > 0) {
                await chunkStorage.storeNotesInChunks(notes);
                updateStatus(`Stored ${notes.length} notes in chunks after refresh`);
            }
        } else {
            // Original loading logic for non-refresh loads
            notes = await loadNotesHybrid(currentPubkey, false);
        }

        updateStatus(`Sorting ${notes.length} notes by date...`);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        allNotes = notes.sort((a, b) => b.created_at - a.created_at);
        
        updateStatus('Updating archives list...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        updateArchiveList();
        updateTargetArchiveDropdown();
        
        updateStatus('Updating tag filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        updateTagFilters();
        
        updateStatus('Applying filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        applyFilters();
        
        updateStatus('Rendering notes...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        renderNotes();
        
        const newNotesCount = allNotes.length - previousNotesCount;
        updateStatus(`✅ Successfully loaded ${allNotes.length} notes!`);
        
        if (isRefresh) {
            if (newNotesCount > 0) {
                showToast(`Refresh complete - ${newNotesCount} new notes loaded (${allNotes.length} total)`, 'success');
            } else {
                showToast(`Refresh complete - no new notes found (${allNotes.length} total)`, 'success');
            }
        }
        
    } catch (error) {
        console.error('Error loading notes:', error);
        showError('Failed to load notes: ' + error.message);
    } finally {
        if (!isRefresh) {
            showLoading(false);
            trackLoadTime();
        }
    }
}

function setupLazyLoading() {
    // Simple lazy loading for images
    const images = document.querySelectorAll('img[loading="lazy"]');
    
    if ('IntersectionObserver' in window) {
        const imageObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    if (img.dataset.src) {
                        img.src = img.dataset.src;
                        img.removeAttribute('data-src');
                    }
                    observer.unobserve(img);
                }
            });
        });
        
        images.forEach(img => imageObserver.observe(img));
    }
}

        function exportAsJSON() {
            const dataToExport = filteredNotes;
            
            let filterType;
let displayName; // Add this to show user-friendly names

if (currentTag.startsWith('__archive_')) {
    const archiveName = currentTag.replace('__archive_', '');
    filterType = archiveName;
    displayName = `Archive: ${archiveName}`;
} else if (currentTag === '__original') {
    filterType = 'original-notes';
    displayName = 'Original Notes';
} else if (currentTag === '__replies') {
    filterType = 'replies';
    displayName = 'Replies';
} else if (currentTag) {
    filterType = currentTag;
    displayName = `Tag: ${currentTag}`;
} else {
    filterType = 'all-notes';
    displayName = 'All Notes';
}
            
            const data = {
                exported_at: new Date().toISOString(),
                filter_type: filterType,
                total_notes: dataToExport.length,
                notes: dataToExport.map(note => ({
    id: note.id,
    date: new Date(note.created_at * 1000).toISOString(),
    content: note.content,
    hashtags: note.hashtags,
    archived: Object.values(namedArchives).some(archive => archive.has(note.id)),
    isReply: note.isReply,
    isRepost: note.isRepost,
    isQuote: note.isQuote
}))
            };
            
            downloadFile(
                JSON.stringify(data, null, 2),
                `nostr-notes-${filterType}-${new Date().toISOString().split('T')[0]}.json`,
                'application/json'
            );
        }

        function exportAsMarkdown() {
            const dataToExport = filteredNotes;
            
            const filterType = currentTag.startsWith('__archive_') 
                ? currentTag.replace('__archive_', '') 
                : currentTag === '__archived' ? 'My Archive' 
                : currentTag || 'All Notes';
            
            let markdown = `# My Nostr Notes\n\n`;
            markdown += `Exported: ${new Date().toISOString()}\n`;
            markdown += `Filter: ${filterType}\n`;
            markdown += `Total Notes: ${dataToExport.length}\n\n---\n\n`;
            
            dataToExport.forEach(note => {
                const date = new Date(note.created_at * 1000).toLocaleString();
                const isArchived = archivedNotes.has(note.id);
                const isReply = note.isReply;
                const noteType = note.isRepost ? '🔄' : note.isQuote ? '💭' : note.isReply ? '💬' : '📝';
                markdown += `## ${noteType} ${date}${isArchived ? ' 🗂️' : ''}\n\n`;
                markdown += `${note.content}\n\n`;
                if (note.hashtags.length > 0) {
                    markdown += `**Tags:** ${note.hashtags.join(', ')}\n\n`;
                }
                markdown += `---\n\n`;
            });
            
            downloadFile(
                markdown,
                `nostr-notes-${filterType.replace(/[^a-z0-9]/gi, '-').toLowerCase()}-${new Date().toISOString().split('T')[0]}.md`,
                'text/markdown'
            );
        }

        function showNoteInfo(noteId) {
    const note = allNotes.find(n => n.id === noteId);
    if (!note) return;
    
    const date = new Date(note.created_at * 1000);
    const archiveStatus = Object.keys(namedArchives).filter(name => 
        namedArchives[name].has(noteId)
    );
    const nevent = createNevent(note);
    
    const modalHtml = `
        <div class="modal" onclick="closeModal(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeModal()">Close</button>
                <h3>Note Information</h3> 
                <p><strong>Nevent:</strong> <button onclick="copyToClipboard('${nevent}')" class="copy-btn">Copy</button><br><small style="word-break: break-all;">${nevent}</small></p>
                <p><strong>ID:</strong><br><small style="word-break: break-all;">${note.id}</small></p>
                <p><strong>Author:</strong><br><small style="word-break: break-all;">${note.pubkey}</small></p>
                <p><strong>Created:</strong> ${date.toLocaleString()}</p>
                <p><strong>Type:</strong> ${note.isReply ? 'Reply' : 'Original Note'}</p>
                <p><strong>Content Length:</strong> ${note.content.length} characters</p>
                <p><strong>Hashtags:</strong> ${note.hashtags.length > 0 ? note.hashtags.join(', ') : 'None'}</p>
                <p><strong>Archives:</strong> ${archiveStatus.length > 0 ? archiveStatus.join(', ') : 'Not archived'}</p>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeModal(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

        function createNevent(note) {
    try {
        if (!window.NostrTools || !window.NostrTools.nip19) {
            return 'NostrTools not available';
        }
        
        // Create nevent data
        const neventData = {
            id: note.id,
            relays: RELAYS.slice(0, 2), // Include first 2 relays
            author: note.pubkey
        };
        
        return window.NostrTools.nip19.neventEncode(neventData);
    } catch (error) {
        console.error('Error creating nevent:', error);
        return 'Error creating nevent';
    }
}

// REPLACE your existing clearAllCache function (around line 2600) with this enhanced version:

async function clearAllCache() {
    if (confirm('This will clear ALL data including cached notes, archives, and IndexedDB. This action cannot be undone. Continue?')) {
        try {
            // Cancel any ongoing operations FIRST
            isLoadingCancelled = true;
            
            // Cancel background loading
            if (backgroundLoadingTimeout) {
                clearTimeout(backgroundLoadingTimeout);
                backgroundLoadingTimeout = null;
            }
            
            // Close all active WebSocket connections
            activeWebSockets.forEach(ws => {
                if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
                    ws.close(1000, 'Cache cleared by user');
                }
            });
            activeWebSockets.clear();
            
            // Hide any loading indicators immediately
            hideBackgroundLoadingIndicator();
            showLoading(false);
            
            // Enhanced IndexedDB clearing - clear everything first
            await clearIndexedDBCompletely();
            
            // Clear chunked storage for current user
            if (currentPubkey) {
                await clearChunkStorage(currentPubkey);
            }
            
            // Only clear data for the current user, not all users
            if (currentPubkey) {
                // Clear cache data for current user
                localStorage.removeItem(`nostr-last-pubkey-${currentPubkey}`);
                localStorage.removeItem(`nostr-cached-notes-${currentPubkey}`);
                localStorage.removeItem(`nostr-cache-updated-at-${currentPubkey}`);
                
                // Clear archives for current user
                localStorage.removeItem(`nostr-archived-notes-${currentPubkey}`);
                localStorage.removeItem(`nostr-named-archives-${currentPubkey}`);
            }
            
            // Clear global settings (theme, etc.) but NOT other users' data
            localStorage.removeItem('nostr-saved-npub');
            localStorage.removeItem('archives-cleanup-done');
            
            // Reset all global variables
            currentPubkey = null;
            allNotes = [];
            filteredNotes = [];
            archivedNotes = new Set();
            namedArchives = {};
            currentTag = '';
            searchQuery = '';
            currentArchive = 'default';
            selectedNotes = new Set();
            selectedTags = new Set();
            
            // Clear quick filters
            activeQuickFilters.clear();
            document.querySelectorAll('.quick-filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Clear date filters
            document.getElementById('date-from').value = '';
            document.getElementById('date-to').value = '';
            
            // Clear search
            document.getElementById('search-input').value = '';
            
            // Clear the UI immediately
            document.getElementById('notes-container').innerHTML = '';
            document.getElementById('tag-filters').innerHTML = '<button class="tag-filter active" data-tag="">All Notes (0)</button>';
            document.getElementById('notes-count').textContent = '0 notes';
            document.getElementById('notes-title').textContent = 'All Notes';
            document.getElementById('archive-list').innerHTML = '<div style="color: #666; font-style: italic; font-size: 13px;">No archives created yet</div>';
            
            // Hide bulk controls and other UI elements
            document.getElementById('bulk-controls').classList.add('hidden');
            document.getElementById('load-more-container').classList.add('hidden');
            document.getElementById('empty-state').classList.add('hidden');
            
            // Reset database connection completely
            db = null;
            useIndexedDB = true; // Reset this flag
            
            // Go back to connection screen
            document.getElementById('main-app').classList.add('hidden');
            document.getElementById('connection-screen').classList.remove('hidden');
            document.getElementById('pubkey-input').value = '';
            
            showToast('All data cleared successfully! Please reconnect.', 'success');
            
            // Reset cancellation flag after everything is done
            isLoadingCancelled = false;
            
        } catch (error) {
            console.error('Error clearing data:', error);
            showToast('Error clearing some data: ' + error.message, 'error');
            
            // Reset cancellation flag even on error
            isLoadingCancelled = false;
        }
    }
}

// ADD this new function to handle IndexedDB clearing:
async function clearIndexedDBCompletely() {
    try {
        // Close current database connection if open
        if (db && db.isOpen()) {
            // Clear all data before closing
            try {
                await db.notes.clear();
                await db.settings.clear();
            } catch (error) {
                console.log('Error clearing tables before close:', error);
            }
            await db.close();
        }
        
        // Clear the specific databases for current user
        if (currentPubkey) {
            const databases = [
                `nostr-notes-${currentPubkey}`,
                `nostr-chunks-${currentPubkey}`
            ];
            
            for (const dbName of databases) {
                // Delete the database entirely
                if (window.indexedDB && window.indexedDB.deleteDatabase) {
                    await new Promise((resolve, reject) => {
                        const deleteReq = window.indexedDB.deleteDatabase(dbName);
                        
                        deleteReq.onsuccess = () => {
                            console.log(`IndexedDB ${dbName} deleted successfully`);
                            resolve();
                        };
                        
                        deleteReq.onerror = (event) => {
                            console.error(`Error deleting IndexedDB ${dbName}:`, event.target.error);
                            resolve(); // Don't reject - continue with cleanup
                        };
                        
                        deleteReq.onblocked = () => {
                            console.warn(`IndexedDB ${dbName} deletion blocked`);
                            // Force resolve after delay
                            setTimeout(resolve, 2000);
                        };
                        
                        // Timeout safety
                        setTimeout(() => {
                            console.warn('IndexedDB deletion timeout');
                            resolve();
                        }, 5000);
                    });
                }
            }
        }
        
        // Reset database variables completely
        db = null;
        useIndexedDB = true; // Reset this flag so it will try IndexedDB again
        
        console.log('IndexedDB cleared completely');
        
    } catch (error) {
        console.error('Error clearing IndexedDB completely:', error);
        // Reset variables anyway
        db = null;
        useIndexedDB = true;
    }
}

// OPTIONAL: Add a separate "Clear IndexedDB Only" function for debugging
async function clearIndexedDBOnly() {
    if (confirm('Clear IndexedDB cache only? (Archives and settings will be preserved)')) {
        try {
            await clearIndexedDB();
            showToast('IndexedDB cleared. Notes will be refetched from relays on next load.', 'success');
        } catch (error) {
            showToast('Error clearing IndexedDB: ' + error.message, 'error');
        }
    }
}

                function loadMoreNotes() {
            currentPage++;
            renderNotes();
        }

        function resetPagination() {
    currentPage = 1;
}

        function updateProgress(percent, text) {
            const progressFill = document.getElementById('progress-fill');
            const loadingText = document.getElementById('loading-text');
            
            if (progressFill) {
                progressFill.style.width = `${percent}%`;
                progressFill.textContent = `${Math.round(percent)}%`;
            }
            if (loadingText && text) {
                loadingText.textContent = text;
            }
        }

       // REPLACE the existing updateStatus function with this enhanced version:
function updateStatus(text, clearPrevious = false) {
    const statusInfo = document.getElementById('status-info');
    if (statusInfo) {
        if (clearPrevious) {
            statusInfo.innerHTML = text + '<br>';
        } else {
            // Limit status history to prevent UI overflow
            const lines = statusInfo.innerHTML.split('<br>');
            if (lines.length > 10) {
                lines.splice(0, lines.length - 8); // Keep last 8 lines
                statusInfo.innerHTML = lines.join('<br>');
            }
            statusInfo.innerHTML += text + '<br>';
        }
        
        // Auto-scroll to bottom
        statusInfo.scrollTop = statusInfo.scrollHeight;
    }
}

// Toast notification system
// Add these variables at the top of your script
let activeToasts = new Set();
let toastTimeout = null;

// Replace your existing showToast function with this:
function showToast(message, type = 'success', duration = 3000) {
    // Prevent duplicate toasts
    if (activeToasts.has(message)) {
        return;
    }
    
    // Clear any pending toast timeout
    if (toastTimeout) {
        clearTimeout(toastTimeout);
    }
    
    // Add to active toasts
    activeToasts.add(message);
    
    // Remove existing toasts of the same type
    document.querySelectorAll(`.toast.${type}`).forEach(existingToast => {
        existingToast.remove();
    });
    
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    
    document.body.appendChild(toast);
    
    // Trigger animation
    setTimeout(() => toast.classList.add('show'), 10);
    
    // Remove after duration
    toastTimeout = setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            if (document.body.contains(toast)) {
                document.body.removeChild(toast);
            }
            activeToasts.delete(message);
        }, 300);
    }, duration);
}

        // Utility functions
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showLoading(show) {
            document.getElementById('loading').classList.toggle('hidden', !show);
        }

        function showError(message) {
            const errorEl = document.getElementById('connection-error');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function hideError() {
            document.getElementById('connection-error').style.display = 'none';
        }

        function copyToClipboard(text) {
    // Prevent rapid double-clicks
    const button = event.target;
    if (button.disabled) return;
    
    // Disable button temporarily
    button.disabled = true;
    
    navigator.clipboard.writeText(text).then(function() {
        // Store original state
        const originalText = button.textContent;
        const originalBg = button.style.background;
        
        // Show success state
        button.textContent = 'Copied!';
        button.style.background = '#27ae60';
        
        // Reset after 1 second (reduced from 1.5s for snappier feel)
        setTimeout(() => {
            button.textContent = originalText;
            button.style.background = originalBg;
            button.disabled = false; // Re-enable button
            
            // Force remove any stuck focus/active states
            button.blur();
        }, 1000);
    }).catch(function(err) {
        console.error('Could not copy text: ', err);
        showToast('Copy failed. Please select and copy manually.', 'error');
        button.disabled = false; // Re-enable on error
    });
}

function triggerFileImport() {
    document.getElementById('import-file').click();
}



async function handleFileImport(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const fileName = file.name.toLowerCase();
    
    try {
        const content = await file.text();
        
        if (fileName.endsWith('.json')) {
            await importFromJSON(content);
        } else {
            showToast('Only JSON files are supported for import', 'error');
        }
    } catch (error) {
        console.error('Import error:', error);
        showToast('Error reading file: ' + error.message, 'error');
    }
    
    // Reset file input
    event.target.value = '';
}

async function importFromJSON(jsonContent) {
    try {
        const data = JSON.parse(jsonContent);
        
        // Validate the JSON structure
        if (!data.notes || !Array.isArray(data.notes)) {
            throw new Error('Invalid JSON format - missing notes array');
        }
        
        let importedCount = 0;
        let archivesToCreate = new Set();
        let notesToArchive = [];
        
        // Process each note from the import
        // Process each note from the import with debugging
let foundById = 0;
let foundByContent = 0;
let notFound = 0;
let archivedTrue = 0;
let archivedFalse = 0;

data.notes.forEach(importedNote => {
    const existingNote = allNotes.find(note => 
    note.id === importedNote.id
    // Temporarily comment out content matching
    // || note.content.replace(/\s+/g, ' ').trim() === importedNote.content.replace(/\s+/g, ' ').trim()
);
    
    if (existingNote) {
        if (existingNote.id === importedNote.id) foundById++;
        else foundByContent++;
        
        if (importedNote.archived || importedNote.archiveName) {
            archivedTrue++;
            const archiveName = data.filter_type && data.filter_type !== 'all' 
                ? data.filter_type 
                : 'Imported Archive';
            
            archivesToCreate.add(archiveName);
            notesToArchive.push({
                noteId: existingNote.id,
                archiveName: archiveName
            });
            importedCount++;
        } else {
            archivedFalse++;
        }
    } else {
        notFound++;
    }
});
        
        if (importedCount === 0) {
            showToast('No matching notes found to import', 'warning');
            return;
        }
        
        // Create archives if they don't exist
        archivesToCreate.forEach(archiveName => {
            if (!namedArchives[archiveName]) {
                namedArchives[archiveName] = new Set();
            }
        });
        
        // Add notes to archives
        notesToArchive.forEach(({ noteId, archiveName }) => {
            namedArchives[archiveName].add(noteId);
        });
        
        // Save and update UI
        saveArchivedNotes();
        updateArchiveList();
        updateTagFilters();
        renderNotes();
        
        showToast(`Successfully imported ${importedCount} archived notes!`, 'success');
        
    } catch (error) {
        console.error('JSON import error:', error);
        showToast('Error importing JSON: ' + error.message, 'error');
    }
}

function removeFromSpecificArchive(noteId, archiveName) {
    if (!namedArchives[archiveName]) return;
    
    namedArchives[archiveName].delete(noteId);
    saveArchivedNotes();
    updateArchiveList();
    updateTagFilters();
    renderNotes();
    
    showToast(`Removed note from "${archiveName}" archive`, 'success');
}

let isSelecting = false;
let selectionStarted = false;
let selectionMode = null; // 'add' or 'remove'

function startHashtagSelection(tag, event) {
    event.preventDefault();
    event.stopPropagation();
    
    // Store initial mouse position to detect if this is a drag or click
    const startX = event.clientX;
    const startY = event.clientY;
    const startTime = Date.now();
    
    // Set up temporary mouse move listener to detect drag
    let hasMoved = false;
    const mouseMoveHandler = (moveEvent) => {
        const deltaX = Math.abs(moveEvent.clientX - startX);
        const deltaY = Math.abs(moveEvent.clientY - startY);
        
        // If mouse moved more than 5 pixels, consider it a drag
        if (deltaX > 5 || deltaY > 5) {
            hasMoved = true;
            startDragMode(tag);
        }
    };
    
    // Set up temporary mouse up listener
    const mouseUpHandler = (upEvent) => {
        document.removeEventListener('mousemove', mouseMoveHandler);
        document.removeEventListener('mouseup', mouseUpHandler);
        
        const timeDiff = Date.now() - startTime;
        
        // If it was a quick click without movement, treat as single click
        if (!hasMoved && timeDiff < 300) {
            handleSingleTagClick(tag);
        }
        
        // End any drag operation
        endHashtagSelection();
    };
    
    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', mouseUpHandler);
}

function startDragMode(tag) {
    if (isSelecting) return; // Already in drag mode
    
    isSelecting = true;
    selectionStarted = true;
    
    // Clear any existing archive/filter selections when starting hashtag selection
    currentArchive = 'default';
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Determine selection mode based on current state of clicked tag
    if (selectedTags.has(tag)) {
        selectionMode = 'remove';
        selectedTags.delete(tag);
    } else {
        selectionMode = 'add';
        selectedTags.add(tag);
    }
    
    // Update visuals immediately without full render
    updateHashtagVisualsOnly();
    updateCountOnly();
    setActiveTagButtons();
    
    // Prevent text selection during drag
    document.body.style.userSelect = 'none';
    document.body.style.webkitUserSelect = 'none';
    document.body.style.mozUserSelect = 'none';
    
    // Add visual feedback for drag mode
    document.body.classList.add('hashtag-selecting');
}

function handleSingleTagClick(tag) {
    // This handles normal single-click behavior
    toggleTag(tag);
}

function continueHashtagSelection(tag, event) {
    if (isSelecting && selectionStarted && selectionMode) {
        event.preventDefault();
        event.stopPropagation();
        
        let changed = false;
        
        if (selectionMode === 'add') {
            // Add tags that aren't already selected
            if (!selectedTags.has(tag)) {
                selectedTags.add(tag);
                changed = true;
            }
        } else if (selectionMode === 'remove') {
            // Remove tags that are currently selected
            if (selectedTags.has(tag)) {
                selectedTags.delete(tag);
                changed = true;
            }
        }
        
        if (changed) {
            updateHashtagVisualsOnly();
            updateCountOnly();
            setActiveTagButtons();
        }
    }
}

function endHashtagSelection() {
    if (selectionStarted) {
        isSelecting = false;
        selectionStarted = false;
        selectionMode = null;
        
        // Restore text selection
        document.body.style.userSelect = '';
        document.body.style.webkitUserSelect = '';
        document.body.style.mozUserSelect = '';
        document.body.classList.remove('hashtag-selecting');
        
        // Now do the full render and filter update
        applyFilters();
        renderNotes();
    }
}

// Helper function to update only hashtag visuals without full re-render
function updateHashtagVisualsOnly() {
    document.querySelectorAll('.hashtag').forEach(hashtagElement => {
        const tag = hashtagElement.dataset.tag || hashtagElement.textContent;
        if (selectedTags.has(tag)) {
            hashtagElement.setAttribute('data-selected', 'true');
            hashtagElement.style.backgroundColor = 'var(--primary-color)';
            hashtagElement.style.color = 'white';
            hashtagElement.style.borderColor = 'var(--primary-color)';
        } else {
            hashtagElement.removeAttribute('data-selected');
            hashtagElement.style.backgroundColor = '';
            hashtagElement.style.color = '';
            hashtagElement.style.borderColor = '';
        }
    });
}

// Helper function to update count without full render
function updateCountOnly() {
    // Quick filter update without full processing
    let quickCount = 0;
    if (selectedTags.size > 0) {
        const tags = Array.from(selectedTags);
        quickCount = allNotes.filter(note =>
            tags.some(tag => noteMatchesTag(note, tag))
        ).length;
    } else {
        quickCount = allNotes.length;
    }
    
    document.getElementById('notes-count').textContent = `${quickCount} notes`;
}

function extractVideoId(url) {
    const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
        /youtube\.com\/watch\?.*v=([^&\n?#]+)/
    ];
    
    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) return match[1];
    }
    return null;
}

function processYouTubeLinks(content) {
    // More flexible regex that can find YouTube URLs even after "Reposted: " prefix
    const youtubeRegex = /(https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)[^\s"<>]+)/g;
    
    return content.replace(youtubeRegex, (url) => {
        const videoId = extractVideoId(url);
        if (!videoId) return url;
        
        return `<div class="youtube-preview" onclick="loadYouTubeThumbnail(this, '${url}', '${videoId}')" style="
            border: 1px dashed var(--border-color);
            padding: 20px;
            margin: 8px 0;
            border-radius: 6px;
            background: var(--background-color);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        " onmouseover="this.style.borderColor='var(--primary-color)'; this.style.color='var(--primary-color)'" 
           onmouseout="this.style.borderColor='var(--border-color)'; this.style.color='var(--text-muted)'">
            Click to load YouTube video
        </div>`;
    });
}

function processImageLinks(content) {
    // More flexible regex for images
    const imageRegex = /(https?:\/\/[^\s"<>]+\.(jpg|jpeg|png|gif|webp)(?:\?[^\s"<>]*)?)/gi;
    
    return content.replace(imageRegex, (url) => {
        return `<div class="image-preview" onclick="loadImage(this, '${url}')" style="
            border: 1px dashed var(--border-color);
            padding: 20px;
            margin: 8px 0;
            border-radius: 6px;
            background: var(--background-color);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        " onmouseover="this.style.borderColor='var(--primary-color)'; this.style.color='var(--primary-color)'" 
           onmouseout="this.style.borderColor='var(--border-color)'; this.style.color='var(--text-muted)'">
            Click to load image
        </div>`;
    });
}

function loadImage(element, url) {
  // render the image
  element.innerHTML = `
    <div style="position: relative; text-align: center; display: flex; justify-content: center;">
      <img class="note-image"
           src="${url}"
           alt="Image"
           loading="lazy"
           onerror="this.style.display='none'"
           style="max-width: 100%; height: auto; border-radius: 8px; display: block;">
    </div>`;
  // make the WHOLE dotted box clickable to close
  element.setAttribute('onclick', `closeImage(this, '${url}')`);
}

function closeImage(element, url) {
  // restore the preview state on the SAME dotted box
  element.innerHTML = `Click to load image`;
  element.setAttribute('onclick', `loadImage(this, '${url}')`);
  // (mouseover/out styles were already on the outer box, so they keep working)
}

function loadYouTubeThumbnail(element, url, videoId) {
  const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
  element.innerHTML = `
    <div style="position: relative; text-align: center; display: flex; justify-content: center;">
      <div class="youtube-thumbnail"
           onclick="event.stopPropagation(); window.open('${url}', '_blank')">
        <img src="${thumbnailUrl}" alt="YouTube Video" loading="lazy"
             onerror="this.src='https://img.youtube.com/vi/${videoId}/hqdefault.jpg'">
        <div class="play-button"></div>
      </div>
    </div>`;
  // make the WHOLE dotted box clickable to close
  element.setAttribute('onclick', `closeYouTube(this, '${url}', '${videoId}')`);
}

function closeYouTube(element, url, videoId) {
  // restore the preview state on the SAME dotted box
  element.innerHTML = `Click to load YouTube video`;
  element.setAttribute('onclick', `loadYouTubeThumbnail(this, '${url}', '${videoId}')`);
}

function makeLinksClickable(content) {
    // More flexible regex for video URLs
    const videoRegex = /(https?:\/\/[^\s"<>]+\.(mp4|mov|avi|webm)(?:\?[^\s"<>]*)?)/gi;
    return content.replace(videoRegex, (url) => {
        return `<a href="${url}" target="_blank" style="color: var(--primary-color); text-decoration: underline;">${url}</a>`;
    });
}


// Enhanced advanced search using smart filter engine
async function performAdvancedSearch(query, filters = {}) {
    try {
        // Initialize smart filter engine
        const chunkStorage = new ChunkedNoteStorage(currentPubkey);
        const ready = await chunkStorage.init();
        
        if (!ready) {
            return performInMemorySearch(query, filters);
        }
        
        const filterEngine = new SmartFilterEngine(chunkStorage);
        
        // Build comprehensive filter object
        const smartFilters = {
            searchText: query,
            hashtags: [],
            dateFrom: filters.dateFrom,
            dateTo: filters.dateTo,
            contentType: filters.contentType,
            hasImages: filters.hasImages,
            hasYouTube: filters.hasYouTube,
            minLength: filters.minLength,
            maxLength: filters.maxLength
        };
        
        // Add selected hashtags to filter
        if (selectedTags.size > 0) {
            selectedTags.forEach(tag => {
                if (tag.startsWith('#')) {
                    smartFilters.hashtags.push(tag);
                } else if (tag === '__original') {
                    smartFilters.contentType = 'original';
                } else if (tag === '__replies') {
                    smartFilters.contentType = 'replies';
                }
            });
        }
        
        // Get estimated count first
        const estimatedCount = await filterEngine.getEstimatedCount(smartFilters);
        updateStatus(`Estimated ${estimatedCount} matching notes across chunks`);
        
        // Load filtered notes
        const results = await filterEngine.loadFilteredNotes(smartFilters, 50000); // Load up to 50k results
        
        updateStatus(`Found ${results.length} notes matching filters`);
        return results;
        
    } catch (error) {
        console.error('Smart search error:', error);
        return performInMemorySearch(query, filters);
    }
}

function performInMemorySearch(query, filters) {
    let results = allNotes.slice();
    
    // Apply date filters
    if (filters.dateFrom) {
        const fromTimestamp = Math.floor(filters.dateFrom.getTime() / 1000);
        results = results.filter(note => note.created_at >= fromTimestamp);
    }
    
    if (filters.dateTo) {
        const toTimestamp = Math.floor(filters.dateTo.getTime() / 1000);
        results = results.filter(note => note.created_at <= toTimestamp);
    }
    
    // Apply content type filters
    if (filters.contentType === 'original') {
        results = results.filter(note => !note.isReply && !note.isRepost && !note.isQuote);
    } else if (filters.contentType === 'replies') {
        results = results.filter(note => note.isReply);
    } else if (filters.contentType === 'reposts') {
        results = results.filter(note => note.isRepost);
    } else if (filters.contentType === 'quotes') {
        results = results.filter(note => note.isQuote);
    }
    
    if (filters.minLength) {
        results = results.filter(note => note.content.length >= filters.minLength);
    }
    
    if (filters.maxLength) {
        results = results.filter(note => note.content.length <= filters.maxLength);
    }
    
    if (filters.hasImages) {
        const imageRegex = /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp))/gi;
        results = results.filter(note => imageRegex.test(note.content));
    }
    
    if (filters.hasYouTube) {
        const youtubeRegex = /(youtube\.com\/watch\?v=|youtu\.be\/)/gi;
        results = results.filter(note => youtubeRegex.test(note.content));
    }
    
    if (query && query.trim()) {
    const searchTerms = query.toLowerCase().split(/\s+/);
    results = results.filter(note => {
        const searchText = (note.content + ' ' + (note.hashtags || []).join(' ')).toLowerCase();
        
        // Check content and hashtags
        const matchesContent = searchTerms.every(term => searchText.includes(term));
        if (matchesContent) return true;
        
        // NEW: Also check reply target npub
        if (note.isReply) {
            const replyTargetNpub = getReplyTargetNpub(note);
            if (replyTargetNpub) {
                const matchesNpub = searchTerms.every(term => 
                    replyTargetNpub.toLowerCase().includes(term)
                );
                if (matchesNpub) return true;
            }
            
            // Also check hex pubkey
            if (note.tags && Array.isArray(note.tags)) {
                const pTags = note.tags.filter(tag => tag[0] === 'p' && tag[1]);
                if (pTags.length > 0) {
                    const targetPubkey = pTags[0][1];
                    const matchesHex = searchTerms.every(term => 
                        targetPubkey.toLowerCase().includes(term)
                    );
                    if (matchesHex) return true;
                }
            }
        }
        
        return false;
    });
}
    
    return results;
}


// Track active quick filters
let activeQuickFilters = new Set();

function toggleQuickFilter(type) {
    console.log('toggleQuickFilter called:', type);
    console.log('activeQuickFilters before:', Array.from(activeQuickFilters));
    
    const button = document.querySelector(`[data-filter="${type}"]`);
    
    // Define which filters are date-based (mutually exclusive)
    const dateFilters = ['week', 'month', '6months', 'year'];
    
    if (activeQuickFilters.has(type)) {
        // Remove filter
        activeQuickFilters.delete(type);
        button.classList.remove('active');
    } else {
        // If this is a date filter, clear other date filters first
        if (dateFilters.includes(type)) {
            dateFilters.forEach(dateFilter => {
                if (dateFilter !== type && activeQuickFilters.has(dateFilter)) {
                    activeQuickFilters.delete(dateFilter);
                    document.querySelector(`[data-filter="${dateFilter}"]`).classList.remove('active');
                }
            });
        }
        
        // Add filter
        activeQuickFilters.add(type);
        button.classList.add('active');
    }
    
    console.log('activeQuickFilters after toggle:', Array.from(activeQuickFilters));
    
    // Clear archive selection when ANY quick filter operation happens
    // but DON'T clear hashtag selections (selectedTags)
    currentArchive = 'default';
    currentTag = '';
    
    // Clear archive active states
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Update "All Notes" button state based on whether we have any selections
    document.querySelectorAll('.tag-filter').forEach(btn => {
        if (btn.dataset.tag === '') {
            // "All Notes" is only active if no hashtags AND no quick filters are selected
            if (selectedTags.size === 0 && activeQuickFilters.size === 0) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }
        // Don't modify hashtag button states here - let setActiveTagButtons handle them
    });
    
    console.log('currentArchive after:', currentArchive);
    console.log('selectedTags preserved:', Array.from(selectedTags));
    
    // Apply combined filters (quick filters + hashtag selections)
    applyAllFilters();
}

async function applyAllFilters() {
    const query = document.getElementById('search-input').value;
    const filters = {};
    
    // Process quick filters - find the EARLIEST date from all active filters
    let earliestDate = null;
    
    activeQuickFilters.forEach(filterType => {
        const now = new Date();
        
        switch(filterType) {
    case 'week':
        const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        if (!earliestDate || weekAgo < earliestDate) {
            earliestDate = weekAgo;
        }
        break;
        
    case 'month':
        const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        if (!earliestDate || monthAgo < earliestDate) {
            earliestDate = monthAgo;
        }
        break;
        
    case '6months':
        const sixMonthsAgo = new Date(now.getTime() - 182 * 24 * 60 * 60 * 1000);
        if (!earliestDate || sixMonthsAgo < earliestDate) {
            earliestDate = sixMonthsAgo;
        }
        break;
        
    case 'year':
        const yearAgo = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
        if (!earliestDate || yearAgo < earliestDate) {
            earliestDate = yearAgo;
        }
        break;
                
            case 'images':
                filters.hasImages = true;
                break;
                
            case 'youtube':
                filters.hasYouTube = true;
                break;
                
            case 'long':
                filters.minLength = 500;
                break;
        }
    });
    
    // Set the earliest date if any date filters are active
    if (earliestDate) {
        filters.dateFrom = earliestDate;
    }
    
    // Manual date range filters - these OVERRIDE quick filters if set
    const dateFromValue = document.getElementById('date-from').value;
    const dateToValue = document.getElementById('date-to').value;
    
    if (dateFromValue) {
        // Create date at start of day
        const fromDate = new Date(dateFromValue + 'T00:00:00');
        filters.dateFrom = fromDate;
    }
    
    if (dateToValue) {
        // Create date at end of day
        const toDate = new Date(dateToValue + 'T23:59:59');
        filters.dateTo = toDate;
    }
    
    performSearchWithFilters(query, filters);
}

function clearAllFilters() {
    // Clear quick filters
    activeQuickFilters.clear();
    document.querySelectorAll('.quick-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Clear date filters
    document.getElementById('date-from').value = '';
    document.getElementById('date-to').value = '';
    
    // Clear search
    document.getElementById('search-input').value = '';
    searchQuery = '';
    
    // Reset ALL state variables
    selectedTags.clear();
    currentTag = '';
    currentArchive = 'default';
    window.inAdvancedSearchMode = false;
    
    // Clear all UI states
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    document.querySelectorAll('.tag-filter').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.tag === '') {
            btn.classList.add('active');
        }
    });
    
    // CRITICAL: Force reset to exact original count
    filteredNotes = allNotes.slice();
    resetPagination();
    renderNotes();
    
    // Reset title and count to exact original values
    document.getElementById('notes-title').textContent = 'All Notes';
    document.getElementById('notes-count').textContent = `${allNotes.length} notes`;
}

// TEMPORARY: Add this function to debug the cache issue
async function forceResetUserCache() {
    if (!currentPubkey) {
        console.log('No user connected');
        return;
    }
    
    try {
        console.log(`Force resetting cache for user: ${currentPubkey.substring(0, 8)}...`);
        
        // Close database
        if (db && db.isOpen()) {
            await db.close();
        }
        
        // Delete the specific IndexedDB for this user
        const dbName = `nostr-notes-${currentPubkey}`;
        await new Promise((resolve) => {
            const deleteReq = indexedDB.deleteDatabase(dbName);
            deleteReq.onsuccess = () => {
                console.log(`Deleted IndexedDB: ${dbName}`);
                resolve();
            };
            deleteReq.onerror = () => {
                console.log(`Failed to delete IndexedDB: ${dbName}`);
                resolve();
            };
            deleteReq.onblocked = () => {
                console.log(`IndexedDB deletion blocked: ${dbName}`);
                setTimeout(resolve, 2000);
            };
        });
        
        // Clear localStorage entries for this user
        localStorage.removeItem(`nostr-archived-notes-${currentPubkey}`);
        localStorage.removeItem(`nostr-named-archives-${currentPubkey}`);
        localStorage.removeItem(`nostr-cached-notes-${currentPubkey}`);
        localStorage.removeItem(`nostr-cache-updated-at-${currentPubkey}`);
        localStorage.removeItem(`nostr-last-pubkey-${currentPubkey}`);
        
        // Reset database connection
        db = null;
        
        console.log('Cache reset complete - reconnect to fetch fresh data');
        showToast('User cache cleared - please reconnect', 'success');
        
        // Disconnect user to force fresh connection
        disconnect();
        
    } catch (error) {
        console.error('Error resetting cache:', error);
    }
}

async function performSearchWithFilters(query, filters) {
    const results = await performAdvancedSearch(query, filters);
    
    // Apply hashtag filtering AFTER the advanced search results
    let finalResults = results;
    
    // Apply hashtag/tag filtering if any tags are selected
    if (selectedTags.size > 0) {
        const tags = Array.from(selectedTags);
        finalResults = finalResults.filter(note =>
            tags.some(tag => noteMatchesTag(note, tag))
        );
    }
    
    // Store the final filtered results
    filteredNotes = finalResults;
    searchQuery = query;
    renderNotes();
    
    // Build comprehensive filter description
    const activeFilters = [];
    

    // Add quick filters
if (activeQuickFilters.has('week')) activeFilters.push('This Week');
if (activeQuickFilters.has('month')) activeFilters.push('This Month');
if (activeQuickFilters.has('6months')) activeFilters.push('6 Months');
if (activeQuickFilters.has('year')) activeFilters.push('This Year');
if (activeQuickFilters.has('images')) activeFilters.push('Images');
if (activeQuickFilters.has('youtube')) activeFilters.push('Videos');
if (activeQuickFilters.has('long')) activeFilters.push('Long');
    
    // Add selected hashtags from multi-selection
    selectedTags.forEach(tag => {
        if (tag === '__original') {
            activeFilters.push('Original Notes');
        } else if (tag === '__replies') {
            activeFilters.push('Replies');
        } else if (tag === '__reposts') {
            activeFilters.push('Reposts');
        } else if (tag === '__quotes') {
            activeFilters.push('Quotes');
        } else if (tag === '__archived') {
            activeFilters.push('Archived');
        } else if (tag.startsWith('#')) {
            activeFilters.push(tag);
        }
    });
    
    // Add search terms from text search
    if (query && query.trim()) {
        const searchTerms = query.trim().split(/\s+/);
        searchTerms.forEach(term => {
            if (term.startsWith('#')) {
                // Only add if it's not already in the list from selectedTags
                if (!activeFilters.includes(term)) {
                    activeFilters.push(term);
                }
            } else {
                activeFilters.push(`"${term}"`);
            }
        });
    }
    
    // Manual date filters (only show if no quick date filters)
if (filters.dateFrom && !activeQuickFilters.has('week') && !activeQuickFilters.has('month') && !activeQuickFilters.has('6months') && !activeQuickFilters.has('year')) {
    activeFilters.push('Date Filtered');
}
    
    // Update UI
    const title = document.getElementById('notes-title');
    const count = document.getElementById('notes-count');
    
    if (activeFilters.length > 0) {
        title.textContent = `Filtered Notes (${activeFilters.join(' + ')})`;
    } else {
        title.textContent = 'All Notes';
    }
    
    count.textContent = `${finalResults.length} notes`;
    
    // Store that we're in advanced search mode
    window.inAdvancedSearchMode = true;
}

function debugRepostContent(noteId) {
    const note = allNotes.find(n => n.id.startsWith(noteId));
    if (!note) {
        console.log('Note not found');
        return;
    }
    
    console.log('=== REPOST DEBUG ===');
    console.log('isRepost:', note.isRepost);
    console.log('Original content:', note.content);
    console.log('After escapeHtml:', escapeHtml(note.content));
    console.log('After processImageLinks:', processImageLinks(escapeHtml(note.content)));
    console.log('After processYouTubeLinks:', processYouTubeLinks(processImageLinks(escapeHtml(note.content))));
    console.log('Final result:', makeLinksClickable(processYouTubeLinks(processImageLinks(escapeHtml(note.content)))));
}

window.debugRepostContent = debugRepostContent;

// Add this diagnostic function
async function diagnoseLoadingIssue() {
    console.log('=== LOADING DIAGNOSTICS ===');
    
    const results = {
        environment: {
            protocol: window.location.protocol,
            hostname: window.location.hostname,
            isHosted: window.location.protocol === 'https:' && window.location.hostname !== 'localhost'
        },
        relayTests: {},
        storage: {},
        currentState: {
            allNotesCount: allNotes.length,
            filteredNotesCount: filteredNotes.length,
            currentPubkey: currentPubkey ? currentPubkey.substring(0, 16) + '...' : 'none'
        }
    };
    
    // Test storage
    if ('storage' in navigator && 'estimate' in navigator.storage) {
        const estimate = await navigator.storage.estimate();
        results.storage = {
            used: `${((estimate.usage || 0) / 1024 / 1024).toFixed(1)}MB`,
            quota: `${((estimate.quota || 0) / 1024 / 1024).toFixed(1)}MB`,
            indexedDB: useIndexedDB ? 'enabled' : 'disabled'
        };
    }
    
    // Test first 3 relays quickly
    const testRelays = RELAYS.slice(0, 3);
    for (const relay of testRelays) {
        try {
            const startTime = Date.now();
            const ws = new WebSocket(relay);
            
            const testResult = await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    ws.close();
                    resolve({ success: false, error: 'timeout' });
                }, 5000);
                
                ws.onopen = () => {
                    clearTimeout(timeout);
                    ws.close();
                    resolve({ success: true, duration: Date.now() - startTime });
                };
                
                ws.onerror = () => {
                    clearTimeout(timeout);
                    resolve({ success: false, error: 'connection failed' });
                };
            });
            
            results.relayTests[relay] = testResult;
        } catch (error) {
            results.relayTests[relay] = { success: false, error: error.message };
        }
    }
    
    console.log(JSON.stringify(results, null, 2));
    return results;
}

// Make it globally available
window.diagnoseLoadingIssue = diagnoseLoadingIssue;



// Make functions globally available
window.toggleQuickFilter = toggleQuickFilter;
window.applyDateFilters = applyDateFilters;
window.clearAllFilters = clearAllFilters;


// Add global event listeners for hashtag selection
document.addEventListener('mouseup', endHashtagSelection);
document.addEventListener('mouseleave', endHashtagSelection);


// Make functions globally available for onclick handlers
// Core functionality
window.filterByTag = filterByTag;
window.toggleArchiveNote = toggleArchiveNote;
window.viewArchive = viewArchive;
window.deleteArchive = deleteArchive;
window.toggleNoteSelection = toggleNoteSelection;
window.showStorageInfo = showStorageInfo;
window.closeStorageInfo = closeStorageInfo;
window.optimizeStorage = optimizeStorage;
window.exportStorageReport = exportStorageReport;

// UI and modals
window.showNoteInfo = showNoteInfo;
window.selectArchiveOption = selectArchiveOption;
window.closeArchiveModal = closeArchiveModal;
window.showAppInfo = showAppInfo;
window.closeAppInfo = closeAppInfo;

// Archive management
window.removeFromSpecificArchive = removeFromSpecificArchive;

// Media loading
window.loadYouTubeThumbnail = loadYouTubeThumbnail;
window.loadImage = loadImage;
window.closeImage = closeImage;
window.closeYouTube = closeYouTube;

// Utilities
window.copyToClipboard = copyToClipboard;
window.clearAllCache = clearAllCache;
window.showToast = showToast;

// Make hashtag selection functions globally available
window.startHashtagSelection = startHashtagSelection;
window.continueHashtagSelection = continueHashtagSelection;
window.endHashtagSelection = endHashtagSelection;

// Theme functionality - immediate execution when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    const themeSelector = document.getElementById('theme-selector');
    if (!themeSelector) return; // Exit if element doesn't exist yet
    
    // Load saved theme on startup
    const savedTheme = localStorage.getItem('nostr-theme') || 'default';
    
    // IMPORTANT: Always set the data-theme attribute, even for default
    document.body.setAttribute('data-theme', savedTheme);
    themeSelector.value = savedTheme;
    
    themeSelector.addEventListener('change', function(e) {
        document.body.setAttribute('data-theme', e.target.value);
        localStorage.setItem('nostr-theme', e.target.value);
    });
});

// One-time cleanup of old global archives - remove after running once
if (!localStorage.getItem('archives-cleanup-done')) {
    localStorage.removeItem('nostr-archived-notes');
    localStorage.removeItem('nostr-named-archives');
    localStorage.setItem('archives-cleanup-done', 'true');
}

    </script>
</body>
</html>
