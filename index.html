<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.4/dexie.min.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr Notes Archive</title>
   <script type="module">
  import * as NostrTools from 'https://cdn.jsdelivr.net/npm/nostr-tools@2.7.1/+esm';
  window.NostrTools = NostrTools;
</script>
    <style>
        /* CSS Variables for Theme Colors */
:root {
    /* Default Theme */
    --primary-color: #3498db;
    --primary-hover: #2980b9;
    --success-color: #27ae60;
    --danger-color: #e74c3c;
    --purple-color: #9b59b6;
    --background-color: #f5f5f5;
    --card-background: white;
    --text-color: #333;
    --text-muted: #666;
    --border-color: #ddd;
}

/* Nostr Purple – stronger + primary=purple */
[data-theme="nostr-purple"] {
  --primary-color: #7c3aed;      /* purple used by non-reply cards */
  --primary-hover: #6d28d9;
  --secondary-color: #f59e0b;
  --secondary-hover: #d97706;
  --success-color: #059669;
  --danger-color: #dc2626;
  --purple-color: #7c3aed;       /* replies & accents */
  --background-color: #f3e8ff;
  --card-background: #f3e8ff;
  --text-color: #3b0764;
  --text-muted: #6d28d9;
  --border-color: #c084fc;
}


/* INTENSE Dark Nostr */
[data-theme="dark-nostr"] {
  --primary-color: #8b5cf6;      /* vivid purple */
  --primary-hover: #7c3aed;      /* deeper hover */
  --secondary-color: #f59e0b;    /* warm gold */
  --secondary-hover: #d97706;
  --success-color: #22c55e;
  --danger-color:  #ef4444;
  --purple-color:  #a78bfa;      /* soft lavender for replies */
  --background-color: #070712;   /* near-black */
  --card-background: #0f1020;    /* darker cards */
  --text-color: #e6edf7;         /* bright but not pure white */
  --text-muted: #8b82aa; 
  --border-color: #232742;       /* strong edge */
}

/* Dark theme input fixes - higher specificity */
[data-theme="dark-nostr"] #search-input::placeholder,
[data-theme="dark-nostr"] #keyword-input::placeholder,
[data-theme="dark-nostr"] #new-archive-name::placeholder {
    color: #cbd5e1 !important;
}

[data-theme="dark-nostr"] #search-input,
[data-theme="dark-nostr"] #keyword-input,
[data-theme="dark-nostr"] #new-archive-name {
    border-color: #64748b;
    color: #e2e8f0;
}

/* INTENSE Bitcoin Gold */
[data-theme="bitcoin-gold"] {
  --primary-color: #f7931a;      /* official Bitcoin orange */
  --primary-hover: #c76a00;      /* deeper hover shade */
  --secondary-color: #6b4e16;    /* coin bronze */
  --secondary-hover: #4a3410;
  --success-color: #2e8b57;      /* strong green */
  --danger-color: #b22222;       /* vivid red */
  --purple-color: #9b59b6;       /* royal purple accent */
  --background-color: #1a1208;   /* dark brown/black backdrop */
  --card-background: #2b1b0b;    /* warm dark card tone */
  --text-color: #fef3c7;         /* pale gold text */
  --text-muted: #d97706;         /* amber-muted for secondary text */
  --border-color: rgba(247, 147, 26, 0.5); /* semi-transparent Bitcoin orange */
}

/* neon-green Neon Green Theme */
[data-theme="neon-green"] {
  --primary-color: #00ff00;
  --primary-hover: #33ff33;
  --secondary-color: #00ff00;
  --secondary-hover: #33ff33;
  --success-color: #00ff00;
  --danger-color: #ff3333;
  --purple-color: #00ff00;
  --background-color: #000000;
  --card-background: #0a0a0a;
  --text-color: #00ff00;
  --text-muted: #00ff00;
  --border-color: #00aa00;

  /* NEW soft tokens for toned surfaces */
  --accent: #00ff00;
  --accent-border: #00aa00;
  --accent-weak: color-mix(in srgb, var(--accent) 18%, #000);
  --accent-weak-2: color-mix(in srgb, var(--accent) 10%, #000);
}

/* Hide emojis for neon-green theme only - MORE SPECIFIC */
[data-theme="neon-green"] .emoji,
[data-theme="neon-green"] button .emoji,
[data-theme="neon-green"] .tag-filter .emoji {
    display: none !important;
}

/* But keep them visible in other themes */
.emoji {
    display: inline !important;
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

     body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--background-color);
    color: var(--text-color);
    line-height: 1.6;
    font-size: 15px; /* Slightly larger base font */
}

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

     .header h1 {
    font-size: 2.8em;
    margin-bottom: 15px;
    color: var(--primary-color);
    font-weight: 600;
    letter-spacing: -0.02em;
}

        .connection-box {
    background: var(--card-background);
    padding: 40px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    max-width: 500px;
    margin: 0 auto;
}

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }

      .form-group input {
    width: 100%;
    padding: 12px;
    border: 2px solid var(--border-color);
    border-radius: 5px;
    font-size: 14px;
    font-family: monospace;
    background: var(--card-background);
    color: var(--text-color);
}

.form-group input:focus {
    border-color: var(--primary-color);
    outline: none;
}

   /* Loading and transition improvements */
.btn {
    background: var(--primary-color);
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 15px;
    font-weight: 500;
    width: 100%;
    margin-bottom: 12px;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
}

.btn.loading::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
    0% { left: -100%; }
    100% { left: 100%; }
}

.fade-in {
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.slide-up {
    animation: slideUp 0.2s ease-out;
}

/* Toast notifications */
.toast {
    position: fixed;
    top: 20px;
    right: 20px;
    background: var(--card-background);
    color: var(--text-color);
    padding: 16px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border-left: 4px solid var(--success-color);
    z-index: 1001;
    transform: translateX(400px);
    transition: transform 0.3s ease;
}

.toast.show {
    transform: translateX(0);
}

.toast.error {
    border-left-color: var(--danger-color);
}

.toast.warning {
    border-left-color: #f39c12;
}

@keyframes slideUp {
    from { transform: translateY(5px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}


.btn:hover {
    background: var(--primary-hover);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .btn-small {
    padding: 8px 14px;
    font-size: 13px;
    width: auto;
    margin: 0 4px;
    font-weight: 500;
}

.btn-secondary {
    background: var(--text-muted);
    color: white;
}

.btn-secondary:hover {
    background: var(--text-color);
}



        .btn-tiny {
            padding: 2px 6px;
            font-size: 11px;
            min-width: auto;
            width: auto;
            margin: 0;
        }

 /* Better delete button styling for all themes */
.btn-delete {
    background: var(--danger-color) !important;
    color: white !important;
    border: none !important;
    width: 24px !important;
    height: 24px !important;
    border-radius: 50% !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    font-size: 14px !important;
    font-weight: bold !important;
    line-height: 1 !important;
}

/* Neon-green delete button */
[data-theme="neon-green"] .btn-delete {
    background: var(--accent) !important;
    color: #000 !important;
    box-shadow: 0 0 6px rgba(0, 255, 0, 0.4) !important;
}

        .btn-delete:hover {
            background: #c0392b;
        }

        .error {
            background: #e74c3c;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            display: none;
        }

        .success {
            background: #27ae60;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.btn:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
}

.btn-small:hover {
    transform: translateY(-1px);
}

.btn-small:active {
    transform: translateY(0);
}

.quick-filter-btn.active {
    background: var(--primary-color) !important;
    color: white !important;
    transform: translateY(-1px);
    box-shadow: 0 3px 8px rgba(52, 152, 219, 0.3);
}

/* Theme-specific active states */
[data-theme="dark-nostr"] .quick-filter-btn.active {
    background: var(--primary-color) !important;
    box-shadow: 0 3px 8px rgba(139, 92, 246, 0.4);
}

[data-theme="bitcoin-gold"] .quick-filter-btn.active {
    background: var(--primary-color) !important;
    box-shadow: 0 3px 8px rgba(247, 147, 26, 0.4);
}

[data-theme="nostr-purple"] .quick-filter-btn.active {
    background: var(--primary-color) !important;
    box-shadow: 0 3px 8px rgba(124, 58, 237, 0.4);
}

[data-theme="neon-green"] .quick-filter-btn.active {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.6) !important;
}
        
        /* Fix layout so tabs (Original Notes / Replies) don’t overflow */
.app-layout {
  display: grid;
  grid-template-columns: 300px 1fr;
  gap: 20px;
  margin-top: 20px;
}


      .sidebar h4 {
    font-size: 14px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
    margin: 25px 0 12px 0;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}

.sidebar h4:first-of-type {
    margin-top: 0;
}

.sidebar {
    background: var(--card-background);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    height: fit-content;
}

.sidebar-section {
    margin-bottom: 32px;
    padding-bottom: 24px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
}

.sidebar-section:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

.main-content {
    background: var(--card-background);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.note-card {
    background: var(--card-background);
    padding: 24px;
    margin-bottom: 18px;
    border-radius: 12px;
    position: relative;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    transition: all 0.2s ease;
    border: 1px solid rgba(0,0,0,0.06);
    /* Default: Blue border for original notes */
    border-left: 4px solid var(--primary-color);
}

.note-card:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 16px rgba(0,0,0,0.12);
}

/* High specificity rules to override everything */
.note-card.reply-card:not(.archived) {
    border-left: 4px solid var(--purple-color) !important;
}

.note-card:not(.reply-card):not(.archived) {
    border-left: 4px solid var(--primary-color) !important;
}

.note-card.archived {
    border-left: 4px solid var(--success-color) !important;
}

     .note-header {
    font-size: 12px;
    color: var(--text-muted);
    margin-bottom: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

        .note-actions {
            display: flex;
            gap: 5px;
        }

     .note-content {
    white-space: pre-wrap;
    line-height: 1.6;
    margin-bottom: 16px;
    font-size: 14px;
    color: var(--text-color);
}

        .hashtags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

/* Hashtag pills — follow current theme */
.hashtag {
  background: color-mix(in srgb, var(--primary-color) 18%, var(--card-background));
  border: 1px solid color-mix(in srgb, var(--primary-color) 40%, var(--card-background));
  color: var(--primary-color);
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  cursor: pointer;
}
.hashtag:hover {
  background: color-mix(in srgb, var(--primary-color) 32%, var(--card-background));
  border-color: var(--primary-hover);
  color: #fff; /* better contrast on hover */
}

/* Hashtags in reply cards = purple theme */
.note-card.reply-card .hashtag {
  background: color-mix(in srgb, var(--purple-color) 18%, var(--card-background));
  border-color: color-mix(in srgb, var(--purple-color) 40%, var(--card-background));
  color: var(--purple-color);
}
.note-card.reply-card .hashtag:hover {
  background: color-mix(in srgb, var(--purple-color) 32%, var(--card-background));
  border-color: var(--purple-color);
  color: #fff;
}

/* Hashtags in archived cards = success theme */
.note-card.archived .hashtag {
  background: color-mix(in srgb, var(--success-color) 18%, var(--card-background));
  border-color: color-mix(in srgb, var(--success-color) 40%, var(--card-background));
  color: var(--success-color);
}
.note-card.archived .hashtag:hover {
  background: color-mix(in srgb, var(--success-color) 32%, var(--card-background));
  border-color: var(--success-color);
  color: #fff;
}

       .tag-filter {
    display: block;
    width: 100%;
    padding: 8px;
    margin-bottom: 5px;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    text-align: left;
    color: var(--text-color);
}


.tag-filter.active {
    background: var(--primary-color);
    color: white;
}

.tag-filter:hover {
  background: color-mix(in srgb, var(--primary-color) 24%, #fff);
  border-color: var(--primary-color);
}

/* Active state */
.tag-filter.active {
  background: var(--primary-color);
  border-color: var(--primary-color);
  color: #fff;
}

/* Special pills that match your theme variables */
.tag-filter[data-tag="__original"] {
  background: var(--primary-color);
  border-color: var(--primary-color);
  color: #fff;
}
.tag-filter[data-tag="__replies"] {
  background: var(--purple-color);
  border-color: var(--purple-color);
  color: #fff;
}
.tag-filter[data-tag="__replies"].active {
  background: var(--purple-color);
}
.tag-filter[data-tag="__archived"],
.tag-filter[data-tag^="__archive_"] {
  background: var(--success-color);
  border-color: var(--success-color);
  color: #fff;
}


 .archive-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    margin-bottom: 8px;
    background: var(--background-color);
    border-radius: 8px;
    border: 1px solid var(--border-color);
    transition: all 0.2s ease;
}

.archive-item:hover:not(.active) {
    background: var(--card-background);
    border-color: var(--primary-color);
}

.archive-item.active {
    background: var(--success-color);
    border-color: var(--success-color);
    color: white;
}

.archive-name {
    cursor: pointer;
    flex: 1;
    font-size: 14px;
}

.archive-count {
    font-size: 12px;
    color: var(--text-muted);
    margin-right: 8px;
}

        .archive-actions {
            display: flex;
            gap: 5px;
        }

      .loading {
    text-align: center;
    padding: 50px;
    color: var(--text-muted);
}

        .hidden { display: none;
        }

    .search-box {
    width: 100%;
    padding: 12px 16px;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 18px;
    background: var(--card-background);
    color: var(--text-color);
    font-size: 14px;
    transition: border-color 0.2s ease;
}

.search-box:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

       .keyword-input {
    width: 100%;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    margin-bottom: 10px;
    font-size: 14px;
    background: var(--card-background);
    color: var(--text-color);
}

        .info-box {
    background: var(--background-color);
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    font-size: 13px;
    border-left: 3px solid var(--primary-color);
}

       .progress-bar {
  width: 100%;
  height: 20px;
  background: color-mix(in srgb, var(--primary-color) 12%, #ecf0f1);
  border: 1px solid color-mix(in srgb, var(--primary-color) 35%, #ecf0f1);
  border-radius: 10px;
  overflow: hidden;
  margin: 10px 0;
}

.progress-fill {
  height: 100%;
  background: var(--primary-color);             /* follows theme */
  transition: width 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 12px;
}

.archive-options {
    margin: 20px 0;
}

.archive-option {
    padding: 12px 16px;
    margin: 8px 0;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.archive-option:hover {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

/* neon-green archive options */
[data-theme="neon-green"] .archive-option {
    background: var(--accent-weak-2) !important;
    border-color: var(--accent-border) !important;
    color: var(--accent) !important;
}

[data-theme="neon-green"] .archive-option:hover {
    background: var(--accent-weak) !important;
    border-color: var(--accent) !important;
}

        .note-checkbox {
            margin-right: 10px;
            transform: scale(1.2);
        }

       .bulk-controls {
    background: var(--background-color);
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    border: 1px solid var(--border-color);
}

        .bulk-controls.hidden {
            display: none;
        }

    .status-info {
    font-size: 12px;
    color: var(--text-muted);
    margin: 5px 0;
}

/* Prevent sideways scroll caused by long strings */
#pubkey-display,
.note-content,
.note-header,
.archive-name {
  overflow-wrap: anywhere;   /* allow breaks anywhere */
  word-break: break-word;    /* fallback */
  max-width: 100%;
}

/* Keep panels from exceeding container width */
.sidebar,
.main-content {
  max-width: 100%;
}

.archive-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    margin-bottom: 8px;
    background: var(--background-color);
    border-radius: 8px;
    border: 1px solid var(--border-color);
    transition: all 0.2s ease;
    cursor: pointer;
    position: relative;
}

.archive-name {
    flex: 1;
    font-size: 14px;
    pointer-events: none;
}

.archive-count {
    font-size: 12px;
    color: var(--text-muted);
    margin-right: 8px;
    pointer-events: none;
}

.archive-actions {
    display: flex;
    gap: 5px;
    z-index: 10;
}

.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(4px);
    animation: fadeIn 0.2s ease;
}

.modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    padding: 32px;
    border-radius: 12px;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    border: 1px solid var(--border-color);
    transform: scale(0.9);
    animation: modalSlideIn 0.2s ease forwards;
}

@keyframes modalSlideIn {
    to {
        transform: scale(1);
    }
}

.modal-close {
    float: right;
    background: var(--primary-color) !important;
    color: white !important;
    border: none !important;
    padding: 10px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s ease;
}

.modal-close:hover {
    background: var(--primary-hover) !important;
    transform: translateY(-1px);
}

/* Stack on small screens */
@media (max-width: 768px) {
  .app-layout {
    grid-template-columns: 1fr;
  }
}
/* Consistent spacing system */
.mb-1 { margin-bottom: 8px; }
.mb-2 { margin-bottom: 16px; }
.mb-3 { margin-bottom: 24px; }
.mb-4 { margin-bottom: 32px; }

.mt-1 { margin-top: 8px; }
.mt-2 { margin-top: 16px; }
.mt-3 { margin-top: 24px; }
.mt-4 { margin-top: 32px; }

kbd {
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 3px;
    padding: 1px 4px;
    font-size: 11px;
    font-family: monospace;
    color: var(--text-color);
}

.copy-btn {
  border: none;
  padding: 4px 8px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 12px;
}

/* Default (light themes, etc.) */
.copy-btn {
  background: #3498db;
  color: #fff;
}

/* Neon green override */
[data-theme="neon-green"] .copy-btn {
  background: var(--accent-weak-2);
  border: 1px solid var(--accent-border);
  color: var(--accent);
}

[data-theme="neon-green"] .copy-btn:hover {
  background: var(--accent-weak);
  box-shadow: 0 0 6px rgba(0,255,0,0.35);
}

/* Stack Import button + hint with tight spacing */
.import-archive-block {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0 !important;                 /* kill any flex gap */
  margin-bottom: 14px;
}

/* ensure the button above doesn't add extra space */
.import-archive-block > .btn {
  margin: 0 !important;              /* some .btn styles add margin-bottom */
}

/* pull the hint closer to the button */
.import-hint {
  color: var(--text-muted);
  font-size: 11px;
  text-align: center;
  margin-top: 4px !important;        /* force a small, tight gap */
  line-height: 1.15;                 /* compact line height */
}

/* if any generic rule targets .sidebar-section .btn + small, override it */
.sidebar-section .btn + .import-hint {
  margin-top: 4px !important;
}

/* Lazy loading styles */
.note-image {
    max-width: 100%;
    height: auto;
    margin: 10px 0;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: transform 0.2s ease;
}

.note-image:hover {
    transform: scale(1.02);
}

.youtube-thumbnail {
    position: relative;
    display: inline-block;
    margin: 10px 0;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    cursor: pointer;
    transition: transform 0.2s ease;
}

.youtube-thumbnail:hover {
    transform: scale(1.02);
}

.youtube-thumbnail img {
    width: 320px;
    height: 180px;
    object-fit: cover;
    display: block;
}

.youtube-thumbnail .play-button {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8);
    color: white;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
}

.youtube-thumbnail .play-button::before {
    content: "▶";
    margin-left: 3px;
}

[data-theme="dark-nostr"] .modal {
    background: rgba(0, 0, 0, 0.8) !important;
}

[data-theme="dark-nostr"] .modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="dark-nostr"] .modal-close {
    background: var(--primary-color) !important;
    color: white !important;
}

[data-theme="dark-nostr"] .modal-close:hover {
    background: var(--primary-hover) !important;
}

[data-theme="bitcoin-gold"] .modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="bitcoin-gold"] .modal-close {
    background: var(--primary-color) !important;
    color: white !important;
}

[data-theme="bitcoin-gold"] .modal-close:hover {
    background: var(--primary-hover) !important;
}

[data-theme="nostr-purple"] .modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="nostr-purple"] .modal-close {
    background: var(--primary-color) !important;
    color: white !important;
}

[data-theme="nostr-purple"] .modal-close:hover {
    background: var(--primary-hover) !important;
}

/* Search input theming for all themes */
#search-input {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

#search-input::placeholder {
    color: var(--text-muted) !important;
}

#search-input:focus {
    border-color: var(--primary-color) !important;
    outline: none;
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
}

/* Dark themes search input fixes */
[data-theme="dark-nostr"] #search-input,
[data-theme="bitcoin-gold"] #search-input,
[data-theme="nostr-purple"] #search-input {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="dark-nostr"] #search-input::placeholder,
[data-theme="bitcoin-gold"] #search-input::placeholder,
[data-theme="nostr-purple"] #search-input::placeholder {
    color: var(--text-muted) !important;
}

/* Date input theming */
[data-theme="dark-nostr"] input[type="date"],
[data-theme="bitcoin-gold"] input[type="date"],
[data-theme="nostr-purple"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="neon-green"] input[type="date"] {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
}

/* More comprehensive date input theming */
input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    border-radius: 4px;
    padding: 6px 8px;
    font-size: 12px;
}

/* Theme-specific date input styling */
[data-theme="dark-nostr"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: dark; /* This helps with native controls */
}

[data-theme="bitcoin-gold"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: dark;
}

[data-theme="nostr-purple"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: dark;
}

[data-theme="neon-green"] input[type="date"] {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    color-scheme: dark;
}

/* Enhanced calendar picker indicator styling */
input[type="date"]::-webkit-calendar-picker-indicator {
    background: transparent;
    bottom: 0;
    cursor: pointer;
    height: auto;
    left: 0;
    position: absolute;
    right: 0;
    top: 0;
    width: auto;
    opacity: 0.8;
}

/* Theme-specific calendar indicators */
[data-theme="dark-nostr"] input[type="date"]::-webkit-calendar-picker-indicator,
[data-theme="bitcoin-gold"] input[type="date"]::-webkit-calendar-picker-indicator,
[data-theme="nostr-purple"] input[type="date"]::-webkit-calendar-picker-indicator {
    filter: invert(1) brightness(0.8);
}

[data-theme="neon-green"] input[type="date"]::-webkit-calendar-picker-indicator {
    filter: invert(1) hue-rotate(120deg) saturate(2) brightness(1.2);
}

/* Focus states */
input[type="date"]:focus {
    border-color: var(--primary-color) !important;
    outline: none;
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
}

[data-theme="neon-green"] input[type="date"]:focus {
    border-color: var(--accent) !important;
    box-shadow: 0 0 0 2px rgba(0, 255, 0, 0.3);
}

/* Fix Nostr Purple theme - should use light color scheme */
[data-theme="nostr-purple"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: light; /* Changed from dark to light */
}

[data-theme="nostr-purple"] input[type="date"]::-webkit-calendar-picker-indicator {
    filter: none; /* Remove the invert filter for light theme */
    opacity: 0.7;
}

/* Neon green search input */
[data-theme="neon-green"] #search-input {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
}

[data-theme="neon-green"] #search-input::placeholder {
    color: color-mix(in srgb, var(--accent) 60%, transparent) !important;
}

[data-theme="neon-green"] #search-input:focus {
    border-color: var(--accent) !important;
    box-shadow: 0 0 0 2px rgba(0, 255, 0, 0.3) !important;
}

/* FINAL OVERRIDES — Nostr Purple theme */
body[data-theme="nostr-purple"] .note-card .hashtag,
[data-theme="nostr-purple"] .note-card .hashtag {
  background: color-mix(in srgb, var(--purple-color) 18%, #fff) !important;
  border-color: color-mix(in srgb, var(--purple-color) 35%, #fff) !important;
  color: var(--purple-color) !important;
}
body[data-theme="nostr-purple"] .note-card .hashtag:hover,
[data-theme="nostr-purple"] .note-card .hashtag:hover {
  background: color-mix(in srgb, var(--purple-color) 28%, #fff) !important;
}

/* FINAL OVERRIDES — Neon Green hashtag pills (wins everywhere) */
body[data-theme="neon-green"] .note-card .hashtag,
[data-theme="neon-green"] .note-card.reply-card .hashtag,
[data-theme="neon-green"] .note-card.archived .hashtag {
  background: var(--accent-weak-2) !important;
  border: 1px solid var(--accent-border) !important;
  color: var(--accent) !important;
  border-radius: 12px; /* keep pill shape */
}
body[data-theme="neon-green"] .note-card .hashtag:hover,
[data-theme="neon-green"] .note-card.reply-card .hashtag:hover,
[data-theme="neon-green"] .note-card.archived .hashtag:hover {
  background: var(--accent-weak) !important;
}

/* neon-green: buttons */
[data-theme="neon-green"] .btn {
  background: var(--accent-weak);
  color: var(--accent);
  border: 1px solid var(--accent-border);
  text-shadow: 0 0 4px var(--accent);
}
[data-theme="neon-green"] .btn:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000);
  border-color: var(--accent);
}

/* neon-green: hashtags inside notes */
[data-theme="neon-green"] .hashtag {
  background: var(--accent-weak-2);
  border: 1px solid var(--accent-border);
  color: var(--accent);
  border-radius: 12px;
}
[data-theme="neon-green"] .hashtag:hover {
  background: var(--accent-weak);
}

/* neon-green: tag filters in sidebar */
[data-theme="neon-green"] .tag-filter {
  background: var(--accent-weak-2);
  border-color: var(--accent-border);
  color: var(--accent);
}
[data-theme="neon-green"] .tag-filter:hover,
[data-theme="neon-green"] .tag-filter.active {
  background: var(--accent-weak);
  border-color: var(--accent);
  color: var(--accent);
}

/* neon-green: progress bar */
[data-theme="neon-green"] .progress-bar {
  background: var(--accent-weak-2);
  border-color: var(--accent-border);
}
[data-theme="neon-green"] .progress-fill {
  background: var(--accent);
  color: #000;
  text-shadow: none;
}

/* neon-green: utility buttons (refresh, disconnect, clear cache, info, etc.) */
[data-theme="neon-green"] #refresh-btn,
[data-theme="neon-green"] #disconnect-btn,
[data-theme="neon-green"] #clear-cache-btn,
[data-theme="neon-green"] .modal-close {
  background: var(--accent-weak) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 4px var(--accent) !important;
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #refresh-btn:hover,
[data-theme="neon-green"] #disconnect-btn:hover,
[data-theme="neon-green"] #clear-cache-btn:hover,
[data-theme="neon-green"] .modal-close:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000) !important;
  border-color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* neon-green: All remaining buttons - comprehensive fix */
[data-theme="neon-green"] #search-keyword-btn,
[data-theme="neon-green"] #select-all-visible,
[data-theme="neon-green"] #deselect-all,
[data-theme="neon-green"] #select-all-keyword,
[data-theme="neon-green"] #deselect-all-keyword,
[data-theme="neon-green"] #bulk-add-to-archive,
[data-theme="neon-green"] #bulk-remove-from-archive,
[data-theme="neon-green"] #bulk-archive-btn,
[data-theme="neon-green"] #bulk-delete-btn {
  background: var(--accent-weak) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 4px var(--accent) !important;
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #search-keyword-btn:hover,
[data-theme="neon-green"] #select-all-visible:hover,
[data-theme="neon-green"] #deselect-all:hover,
[data-theme="neon-green"] #select-all-keyword:hover,
[data-theme="neon-green"] #deselect-all-keyword:hover,
[data-theme="neon-green"] #bulk-add-to-archive:hover,
[data-theme="neon-green"] #bulk-remove-from-archive:hover,
[data-theme="neon-green"] #bulk-archive-btn:hover,
[data-theme="neon-green"] #bulk-delete-btn:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000) !important;
  border-color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* neon-green: Dropdown selects */
[data-theme="neon-green"] #bulk-archive-dropdown,
[data-theme="neon-green"] #bulk-target-archive {
  background: var(--accent-weak-2) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
}

/* neon-green: Info buttons with inline styles */
[data-theme="neon-green"] button[onclick*="showNoteInfo"] {
  background: var(--accent-weak-2) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 3px var(--accent) !important;
}

/* neon-green: small info buttons */
[data-theme="neon-green"] .btn-small {
background: var(--accent-weak-2) !important;
color: var(--accent) !important;
border: 1px solid var(--accent-border) !important;
text-shadow: 0 0 3px var(--accent) !important;
}
[data-theme="neon-green"] .btn-small:hover {
background: var(--accent-weak) !important;
border-color: var(--accent) !important;
}

/* neon-green: Regular archives (non-active) */
[data-theme="neon-green"] .archive-item {
  background: var(--accent-weak-2) !important;
  border: 1px solid var(--accent-border) !important;
  color: var(--accent) !important;
  box-shadow: none !important;
}

/* neon-green: Only the active archive gets the glow */
[data-theme="neon-green"] .archive-item.active {
  background: var(--accent-weak) !important;
  border: 2px solid var(--accent) !important;
  color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* neon-green: Load More button */
[data-theme="neon-green"] #load-more-btn {
  background: var(--accent-weak) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 4px var(--accent) !important;
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #load-more-btn:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000) !important;
  border-color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

[data-theme="neon-green"] .modal {
    background: rgba(0, 0, 0, 0.8) !important;
}

[data-theme="neon-green"] .modal-content {
    background: var(--card-background) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3) !important;
}

[data-theme="neon-green"] .modal-close {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    text-shadow: 0 0 4px var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] .modal-close:hover {
    background: color-mix(in srgb, var(--accent) 28%, #000) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* Neon green theme override for Import Archive */
[data-theme="neon-green"] #import-btn {
  background: #003300 !important;       /* darker green base */
  border: 1px solid var(--accent-border);
  color: var(--accent);
}

[data-theme="neon-green"] #import-btn:hover {
  background: #006600 !important;       /* brightens on hover */
  box-shadow: 0 0 12px rgba(0,255,0,0.35);
}

/* Hashtag group header hover effects */
.hashtag-group-header:hover {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Fix text color for dark themes */
[data-theme="dark-nostr"] .hashtag-group-header:hover,
[data-theme="bitcoin-gold"] .hashtag-group-header:hover {
    color: var(--card-background) !important;
}

/* Fix hashtag button hover text color for dark themes */
[data-theme="dark-nostr"] .tag-filter:hover,
[data-theme="bitcoin-gold"] .tag-filter:hover {
    color: var(--card-background) !important;
}

/* Neon green theme stays the same */
[data-theme="neon-green"] .hashtag-group-header {
    background: var(--accent-weak-2) !important;
    border-color: var(--accent-border) !important;
    color: var(--accent) !important;
}

[data-theme="neon-green"] .hashtag-group-header:hover {
    background: var(--accent-weak) !important;
    border-color: var(--accent) !important;
    color: var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.3) !important;
}

/* Fix Clear All Filters button theming */
[data-theme="neon-green"] .search-container button[onclick="clearAllFilters()"] {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    text-shadow: 0 0 4px var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] .search-container button[onclick="clearAllFilters()"]:hover {
    background: color-mix(in srgb, var(--accent) 28%, #000) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* Fix hashtag hover colors for dark themes */
[data-theme="dark-nostr"] .tag-filter:hover {
    color: var(--text-color) !important;
    background: color-mix(in srgb, var(--primary-color) 40%, transparent) !important;
}

[data-theme="bitcoin-gold"] .tag-filter:hover {
    color: var(--text-color) !important;
    background: color-mix(in srgb, var(--primary-color) 40%, transparent) !important;
}

/* Hashtag drag selection styles */
.hashtag-selecting {
    cursor: grabbing !important;
}

.hashtag-selecting .hashtag {
    cursor: grabbing !important;
}

/* Improve hashtag hover states during selection */
.hashtag {
    transition: all 0.15s ease;
    user-select: none;
}

.hashtag:hover {
    transform: translateY(-1px);
}

/* Active hashtag styling */
.hashtag[data-selected="true"] {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Selected hashtag highlighting for Nostr Purple theme */
body[data-theme="nostr-purple"] .note-card .hashtag[data-selected="true"],
[data-theme="nostr-purple"] .note-card .hashtag[data-selected="true"] {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Selected hashtag highlighting for Neon Green theme */
body[data-theme="neon-green"] .note-card .hashtag[data-selected="true"],
[data-theme="neon-green"] .note-card.reply-card .hashtag[data-selected="true"],
[data-theme="neon-green"] .note-card.archived .hashtag[data-selected="true"] {
    background: var(--accent) !important;
    color: #000 !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.6) !important;
}

    </style>
</head>
<body>
    <div class="container">
        <!-- Connection Screen -->
        <div id="connection-screen">
            <div class="header">
                <h1><span class="emoji">📝</span> Nostr Notes Archive</h1>
                <p>View and organize your Nostr notes</p>
            </div>

            <div class="connection-box">
                <h3 style="text-align: center; margin-bottom: 20px;">Connect Your Account</h3>
                
                <div class="form-group">
               <label>Your Public Key (npub):</label>
<input type="text" id="pubkey-input" placeholder="Enter your npub..." style="font-family:monospace;">
<small style="color: var(--text-muted); font-size:12px;">
                </div>
                
                 <button id="connect-btn" class="btn"><span class="emoji">🔍</span> Load My Notes</button>
                
                <div class="info-box">
                    <strong>How to find your public key:</strong><br>
                    • Damus: Profile → Settings → Account → Public Key<br>
                    • Primal: Settings → Account → Copy public key<br>
                    • Iris: Profile → Copy public key<br>
                    <br>
                    Paste your npub (NIP-19) above.
                </div>

                <div id="connection-error" class="error"></div>
            </div>
        </div>

        <!-- Main App -->
        <div id="main-app" class="hidden">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <div>
                    <h2><span class="emoji">📝</span> My Nostr Archive</h2>
                  <small id="pubkey-display" style="color: var(--text-muted); font-family: monospace;">
                </div>
               <button id="disconnect-btn" style="background: #95a5a6; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
    Disconnect
</button>
            </div>

            <div class="app-layout">
    <div class="sidebar">
        <div class="search-container" style="margin-bottom: 16px;">
    <!-- Main search bar -->
    <div style="margin-bottom: 12px;">
        <input type="text" id="search-input" placeholder="Search notes... (/ to focus)" 
               style="width: 100%; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 4px;">
    </div>
    
    <!-- Quick filters - now toggleable -->
<div class="quick-filters" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; margin-bottom: 12px;">
    <button class="btn btn-tiny quick-filter-btn" data-filter="week" onclick="toggleQuickFilter('week')">This Week</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="month" onclick="toggleQuickFilter('month')">This Month</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="year" onclick="toggleQuickFilter('year')">This Year</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="images" onclick="toggleQuickFilter('images')">Images</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="youtube" onclick="toggleQuickFilter('youtube')">Videos</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="long" onclick="toggleQuickFilter('long')">Long</button>
</div>
    
    <!-- Date range filters -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
        <div>
            <label style="font-size: 11px; color: var(--text-muted); margin-bottom: 2px; display: block;">FROM DATE</label>
            <input type="date" id="date-from" onchange="applyDateFilters()" 
                   style="width: 100%; padding: 4px 6px; border: 1px solid var(--border-color); border-radius: 3px; font-size: 12px; background: var(--background-color); color: var(--text-color);">
        </div>
        <div>
            <label style="font-size: 11px; color: var(--text-muted); margin-bottom: 2px; display: block;">TO DATE</label>
            <input type="date" id="date-to" onchange="applyDateFilters()"
                   style="width: 100%; padding: 4px 6px; border: 1px solid var(--border-color); border-radius: 3px; font-size: 12px; background: var(--background-color); color: var(--text-color);">
        </div>
    </div>
    
    <!-- Clear filters button -->
    <button class="btn btn-tiny" onclick="clearAllFilters()" style="width: 100%; background: #95a5a6; color: white; border: none;">
        Clear All Filters
    </button>
</div>
        
        <div class="sidebar-section">
            <h4>My Archives</h4>
            <div id="archive-list">
                <!-- Archives will be populated here -->
            </div>
            <div style="margin-top: 15px;">
                <input type="text" id="new-archive-name" class="keyword-input" placeholder="New archive name..." maxlength="30">
               <button id="create-archive-btn" class="btn" style="font-size: 14px; padding: 8px;"><span class="emoji">🗂</span> Create Archive</button>
              </div>
        </div>

        <div class="sidebar-section">
            <h4>Filter by Tags</h4>
            <div id="tag-filters">
                <button class="tag-filter active" data-tag="">All Notes (0)</button>
               <button class="tag-filter" data-tag="__original" style="background: #3498db; color: white;"><span class="emoji">📝</span> Original Notes (0)</button>
               <button class="tag-filter" data-tag="__replies" style="background: #9b59b6; color: white;"><span class="emoji">💬</span> Replies (0)</button>
            </div>
        </div>

        <div class="sidebar-section">
            <h4>Export</h4>
            <button id="export-json" class="btn" style="font-size: 14px; padding: 8px;">Export JSON</button>
            <button id="export-md" class="btn" style="font-size: 14px; padding: 8px;">Export Markdown</button>
        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
        <input type="file" id="import-file" accept=".json,.md,.txt" style="display: none;">
        <div class="import-archive-block">
  <button id="import-btn" class="btn" style="font-size: 14px; padding: 8px; background: #27ae60;">
    <span class="emoji">📁</span> Import Archive
  </button>
  <small class="import-hint">Supports JSON exports from this app</small>
</div>
    </div>
    
    <button id="clear-cache-btn" class="btn" style="font-size: 14px; padding: 8px; background: #e74c3c;"><span class="emoji">🗑️</span> Clear Cache</button>
</div>

        <div class="sidebar-section">
    <h4>Keyboard Shortcuts</h4>
    <div style="font-size: 12px; color: var(--text-muted); line-height: 1.4;">
        <div><kbd>/</kbd> or <kbd>Ctrl+K</kbd> Focus search</div>
        <div><kbd>Esc</kbd> Clear search/selections</div>
        <div><kbd>A</kbd> Select all visible</div>
        <div><kbd>Del</kbd> Remove selected</div>
    </div>
</div>
        
    <div class="sidebar-section">
            <h4>Theme</h4>
            <select id="theme-selector" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--card-background); color: var(--text-color);">
                <option value="default">Default Blue</option>
                <option value="nostr-purple">Nostr Purple</option>
                <option value="dark-nostr">Dark Nostr</option>
                <option value="bitcoin-gold">Bitcoin Gold</option>
                <option value="neon-green">Neon Green</option>
            </select>
    </div>
</div>


    <div class="main-content">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 32px; padding-bottom: 16px; border-bottom: 1px solid var(--border-color);">
    <div>
        <h3 id="notes-title">All Notes</h3>
        <small id="notes-count" style="color: var(--text-muted);">0 notes</small>
    </div>
   <button id="refresh-btn" style="background: #3498db; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
    <span class="emoji">🔄</span> Refresh
</button>
</div>



                    <div id="bulk-controls" class="bulk-controls hidden">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <span id="selected-count" style="font-weight: bold;">0 notes selected</span>
                            <div>
                                <button id="select-all-visible" class="btn btn-small" style="background: #34495e;">Select All Visible</button>
                                <button id="deselect-all" class="btn btn-small" style="background: #7f8c8d;">Deselect All</button>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                           <select id="bulk-archive-dropdown" style="flex: 1; min-width: 150px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--card-background); color: var(--text-color);">
                                <option value="">Select archive...</option>
                            </select>
                           <button id="bulk-add-to-archive" class="btn btn-small" style="background: #27ae60;"><span class="emoji">📂</span> Add to Archive</button>
                           <button id="bulk-remove-from-archive" class="btn btn-small" style="background: #e74c3c;"><span class="emoji">🗑️</span> Remove from Archive</button>
                        </div>
                    </div>
                  <!-- Loader: ALL loader UI goes inside #loading -->
<div id="loading" class="loading hidden">
<div style="font-size: 24px; margin-bottom: 10px;"><span class="emoji">🔄</span></div>
  <p id="loading-text">Loading your notes...</p>
  <div class="progress-bar">
    <div id="progress-fill" class="progress-fill" style="width: 0%;">0%</div>
  </div>
  <div id="status-info" class="status-info"></div>
</div>


<!-- Notes list lives OUTSIDE the loading box -->
<div id="notes-container"></div>

<div id="load-more-container" class="hidden" style="text-align: center; margin: 20px 0;">
  <button id="load-more-btn" class="btn">Load More Notes</button>
  <div id="pagination-info" style="font-size:14px;">
    Showing 0 of 0 notes
  </div>
</div>


<!-- Empty state also OUTSIDE the loading box -->
<div id="empty-state" class="hidden" style="text-align: center; padding: 50px; color: #666;">
<div style="font-size: 48px; margin-bottom: 20px;"><span class="emoji">📝</span></div>
  <h3>No notes found</h3>
  <p>Make sure you've posted notes to Nostr, or check your public key.</p>
</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentPubkey = null;
        let allNotes = [];
        let filteredNotes = [];
        let archivedNotes = new Set(); // Keep for backward compatibility
        let namedArchives = {}; // New: stores multiple archives { archiveName: Set(noteIds) }
        let currentTag = '';
        let searchQuery = '';
        let currentArchive = 'default'; // Track which archive we're viewing
        let selectedNotes = new Set(); // Track selected notes for bulk operations
        let selectedTags = new Set(); // NEW: multi-select tags
        let notesPerPage = 100;
let currentPage = 1;

// IndexedDB setup with Dexie
let db = null;

          // ADD THIS FUNCTION HERE:
        function npubToHex(npub) {
            try {
                if (!window.NostrTools || !window.NostrTools.nip19) {
                    throw new Error('NostrTools library not loaded');
                }
                
                const decoded = window.NostrTools.nip19.decode(npub);
                if (decoded.type !== 'npub') {
                    throw new Error('Not a valid npub');
                }
                
                return decoded.data;
            } catch (error) {
                console.error('Error converting npub to hex:', error);
                return null;
            }
        }

// Normalize pasted npub (strip spaces, prefix, hidden chars)
function normalizeNpub(input) {
  let s = (input || '').trim().toLowerCase();

  // remove spaces/newlines
  s = s.replace(/\s+/g, '');

  // remove nostr: URI prefix if present
  s = s.replace(/^nostr:/, '');

  // remove zero-width characters and BOM
  s = s.replace(/[\u200B-\u200D\uFEFF]/g, '');

  // replace “smart quotes” with plain quotes (just in case)
  s = s.replace(/[‘’]/g, "'").replace(/[“”]/g, '"');

  return s;
}

        // Enhanced relay list with better reliability
    const RELAYS = [
    'wss://relay.snort.social',
    'wss://relay.nostrplebs.com',
    'wss://relay.damus.io',
    'wss://offchain.pub',
    'wss://nostr.wine',
    'wss://nostr.land',
    'wss://nos.lol',
    'wss://relay.nostr.band'
];

        // Initialize the app
      document.addEventListener('DOMContentLoaded', function () {
    setupEventListeners();
    setupKeyboardShortcuts();
    setupHashtagDragSelection();

  // Auto-login if we have a saved npub
  const savedNpub = localStorage.getItem('nostr-saved-npub');
  if (savedNpub) {
    document.getElementById('pubkey-input').value = savedNpub;
    connectWithPubkey();
  }
});

        function setupEventListeners() {
            document.getElementById('connect-btn').addEventListener('click', connectWithPubkey);
            document.getElementById('disconnect-btn').addEventListener('click', disconnect);

           // Add null checks for import elements
    const importBtn = document.getElementById('import-btn');
    const importFile = document.getElementById('import-file');
    
    if (importBtn) importBtn.addEventListener('click', triggerFileImport);
    if (importFile) importFile.addEventListener('change', handleFileImport);

            // NEW: allow pressing Enter in the npub box to connect
const pubkeyInput = document.getElementById('pubkey-input');
pubkeyInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    connectWithPubkey();
  }
});

           // IMPROVEMENT 3: Debounced search for better performance
let searchTimeout;
document.getElementById('search-input').addEventListener('input', function(e) {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => handleSearch(e), 300);
});
            document.getElementById('refresh-btn').addEventListener('click', refreshNotes);
            document.getElementById('export-json').addEventListener('click', exportAsJSON);
            document.getElementById('export-md').addEventListener('click', exportAsMarkdown);
            document.getElementById('create-archive-btn').addEventListener('click', createNewArchive);
            document.getElementById('new-archive-name').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        createNewArchive();
    }
});
            document.getElementById('clear-cache-btn').addEventListener('click', clearAllCache);
            document.getElementById('load-more-btn').addEventListener('click', loadMoreNotes);
            
            
            // Bulk controls for main view
            document.getElementById('select-all-visible').addEventListener('click', selectAllVisible);
            document.getElementById('deselect-all').addEventListener('click', deselectAll);
            document.getElementById('bulk-add-to-archive').addEventListener('click', bulkAddToArchive);
            document.getElementById('bulk-remove-from-archive').addEventListener('click', bulkRemoveFromArchive);
        }

        function setupHashtagDragSelection() {
    const tagFiltersEl = document.getElementById('tag-filters');
    if (!tagFiltersEl) return;
    
    // Remove any existing listeners to prevent duplicates
    if (tagFiltersEl.__dragSetup) return;
    
    // Handle mousedown on hashtag buttons only
    tagFiltersEl.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // Left mouse button only
        
        const btn = e.target.closest('.tag-filter');
        if (!btn) return;
        
        const tag = btn.dataset.tag;
        if (!tag || !tag.startsWith('#')) return; // Only hashtags, not special buttons
        
        startHashtagSelection(tag, e);
    });
    
    // Handle mouseover for dragging
    tagFiltersEl.addEventListener('mouseover', (e) => {
        if (!isSelecting) return;
        
        const btn = e.target.closest('.tag-filter');
        if (!btn) return;
        
        const tag = btn.dataset.tag;
        if (!tag || !tag.startsWith('#')) return;
        
        continueHashtagSelection(tag, e);
    });
    
    tagFiltersEl.__dragSetup = true; // Prevent duplicate setup
}

        function loadArchivedNotes() {
    if (!currentPubkey) return; // Don't load if no user connected
    
    try {
        // Load legacy archive for backward compatibility
        const saved = localStorage.getItem(`nostr-archived-notes-${currentPubkey}`);
        if (saved) {
            archivedNotes = new Set(JSON.parse(saved));
        } else {
            archivedNotes = new Set();
        }
        
        // Load named archives
        const savedArchives = localStorage.getItem(`nostr-named-archives-${currentPubkey}`);
        if (savedArchives) {
            const parsed = JSON.parse(savedArchives);
            namedArchives = {};
            Object.keys(parsed).forEach(name => {
                namedArchives[name] = new Set(parsed[name]);
            });
        } else {
            namedArchives = {};
        }
        
        // Migration logic (only for this specific user)
        if (archivedNotes.size > 0 && !namedArchives['My Archive']) {
            namedArchives['My Archive'] = new Set([...archivedNotes]);
            archivedNotes.clear();
            saveArchivedNotes();
        }
    } catch (error) {
        console.error('Error loading archived notes:', error);
        namedArchives = {};
        archivedNotes = new Set();
    }
}

// IMPROVEMENT: Keyboard shortcuts
function setupKeyboardShortcuts() {
    document.addEventListener('keydown', function(e) {
        // Don't trigger shortcuts when typing in inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            // Exception: Escape should work even in inputs
            if (e.key === 'Escape') {
                e.target.blur();
                if (e.target.id === 'search-input') {
                    e.target.value = '';
                    handleSearch();
                }
            }
            return;
        }

         // NEW: allow Enter to submit npub on the connection screen
  if (e.key === 'Enter') {
    const connectionScreen = document.getElementById('connection-screen');
    const pubkeyInput = document.getElementById('pubkey-input');

    if (
      connectionScreen && pubkeyInput &&
      !connectionScreen.classList.contains('hidden') &&
      (document.activeElement === pubkeyInput || pubkeyInput.value.trim())
    ) {
      e.preventDefault();
      connectWithPubkey();
      return; // handled
    }
  }


        // Prevent default for handled shortcuts
        const handled = true;

        switch(e.key) {
            case '/':
                e.preventDefault();
                document.getElementById('search-input').focus();
                break;
                
            case 'Escape':
                // Clear search
                const searchInput = document.getElementById('search-input');
                if (searchInput.value) {
                    searchInput.value = '';
                    handleSearch();
                } else {
                    // Clear selections
                    deselectAll();
                }
                break;
                
            case 'k':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    document.getElementById('search-input').focus();
                }
                break;
                
            case 'a':
                if (!e.ctrlKey && !e.metaKey) {
                    // Toggle select all visible notes
                    if (selectedNotes.size > 0) {
                        deselectAll();
                    } else {
                        selectAllVisible();
                    }
                }
                break;
                
            case 'Delete':
            case 'Backspace':
                if (selectedNotes.size > 0) {
                    e.preventDefault();
                    if (confirm(`Remove ${selectedNotes.size} selected notes from all archives?`)) {
                        bulkRemoveFromArchive();
                    }
                }
                break;
                
                
            default:
                return; // Don't prevent default for unhandled keys
        }
    });
}

function saveArchivedNotes() {
    if (!currentPubkey) return; // Don't save if no user connected
    try {
        // Save legacy for backward compatibility
        localStorage.setItem(`nostr-archived-notes-${currentPubkey}`, JSON.stringify([...archivedNotes]));

        // Save named archives (convert Sets to arrays for JSON)
        const toSave = {};
        Object.keys(namedArchives).forEach(name => {
            toSave[name] = [...namedArchives[name]];
        });
        localStorage.setItem(`nostr-named-archives-${currentPubkey}`, JSON.stringify(toSave));
    } catch (error) {
        console.error('Error saving archived notes:', error);
    }
}

        function createNewArchive() {
    const name = document.getElementById('new-archive-name').value.trim();
    if (!name) {
        showToast('Please enter an archive name', 'error');
        return;
    }
    
    if (namedArchives[name]) {
        showToast('Archive with this name already exists', 'error');
        return;
    }
    
    namedArchives[name] = new Set();
    saveArchivedNotes();
    updateArchiveList();
    updateTargetArchiveDropdown();
    
    document.getElementById('new-archive-name').value = '';
    showToast(`Archive "${name}" created successfully!`, 'success');
}

        function deleteArchive(archiveName) {
            if (confirm(`Are you sure you want to delete the archive "${archiveName}"? This cannot be undone.`)) {
                delete namedArchives[archiveName];
                saveArchivedNotes();
                updateArchiveList();
                updateTargetArchiveDropdown();
                
                // If we were viewing the deleted archive, switch to all notes
                if (currentArchive === archiveName) {
                    filterByTag('');
                }
            }
        }

       function viewArchive(archiveName) {
    // Check if we're already viewing this archive - if so, go back to All Notes
    if (currentArchive === archiveName) {
        // Reset to All Notes view
        currentArchive = 'default';
        currentTag = '';
        selectedTags.clear(); // ADDED: Clear hashtag selections
        
        // Clear all active states
        document.querySelectorAll('.archive-item').forEach(item => {
            item.classList.remove('active');
        });
        
        // Set "All Notes" as active in tag filters
        document.querySelectorAll('.tag-filter').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.tag === '') {
                btn.classList.add('active');
            }
        });
        
        // Use the existing filterByTag function to properly reset to all notes
        filterByTag('');
        
        return; // Exit early
    }
    
    // Normal archive selection
    currentArchive = archiveName;
    currentTag = '__archive_' + archiveName;
    selectedTags.clear(); // ADDED: Clear hashtag selections when switching to archive
    
    // Clear all active states first
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Clear tag filters active states
    document.querySelectorAll('.tag-filter').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Use the existing filterByTag function
    filterByTag('__archive_' + archiveName);
    
    // Force update the archive list to show correct active state
    updateArchiveList();
}

        function updateArchiveList() {
    const container = document.getElementById('archive-list');
    if (!container) return;
    
    if (Object.keys(namedArchives).length === 0) {
        container.innerHTML = '<div style="color: #666; font-style: italic; font-size: 13px;">No archives created yet</div>';
        return;
    }
    
    container.innerHTML = Object.keys(namedArchives).map(name => {
        const count = namedArchives[name].size;
        const isActive = currentArchive === name;
        
        return `
            <div class="archive-item ${isActive ? 'active' : ''}" onclick="viewArchive('${name}')">
                <div class="archive-name">${escapeHtml(name)}</div>
                <div class="archive-count">(${count})</div>
                <div class="archive-actions" onclick="event.stopPropagation();">
                    <button class="btn btn-tiny btn-delete" onclick="deleteArchive('${name}')">×</button>
                </div>
            </div>
        `;
    }).join('');
}

        function updateTargetArchiveDropdown() {
    const bulkArchiveDropdown = document.getElementById('bulk-archive-dropdown');
    
    const archiveOptions = '<option value="">Select archive...</option>' +
        Object.keys(namedArchives).map(name => 
            `<option value="${name}">${escapeHtml(name)}</option>`
        ).join('');
    
    if (bulkArchiveDropdown) bulkArchiveDropdown.innerHTML = archiveOptions;
}

        function toggleArchiveNote(noteId, archiveName = null) {
            // If no specific archive is provided, show archive selection
            if (!archiveName && Object.keys(namedArchives).length > 0) {
                showArchiveSelectionModal(noteId);
                return;
            }
            
            // Legacy behavior - add to default archive
            if (archivedNotes.has(noteId)) {
                archivedNotes.delete(noteId);
                // Also remove from all named archives
                Object.keys(namedArchives).forEach(name => {
                    namedArchives[name].delete(noteId);
                });
            } else {
                archivedNotes.add(noteId);
                // Add to "My Archive" if it exists, otherwise create it
                if (!namedArchives['My Archive']) {
                    namedArchives['My Archive'] = new Set();
                }
                namedArchives['My Archive'].add(noteId);
            }
            
            saveArchivedNotes();
            renderNotes();
            updateTagFilters();
            updateArchiveList();
        }

        function addToArchive(noteId, archiveName) {
            if (!namedArchives[archiveName]) {
                namedArchives[archiveName] = new Set();
            }
            
            namedArchives[archiveName].add(noteId);
            
            saveArchivedNotes();
            renderNotes();
            updateTagFilters();
            updateArchiveList();
        }

        function showArchiveSelectionModal(noteId) {
    const archiveNames = Object.keys(namedArchives);
    if (archiveNames.length === 0) {
       showToast('Please create an archive first');
        return;
    }
    
    // Create custom modal HTML
    const optionsList = archiveNames.map((name, index) => 
        `<div class="archive-option" data-index="${index}" onclick="selectArchiveOption(${index}, '${noteId}')">
            ${index + 1}. ${escapeHtml(name)}
        </div>`
    ).join('');
    
    const modalHtml = `
        <div class="modal" onclick="closeArchiveModal(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeArchiveModal()">×</button>
                <h3>Select archive for this note:</h3>
                <div class="archive-options">
                    ${optionsList}
                </div>
                <div style="margin-top: 20px; text-align: center;">
                    <button class="btn btn-small" onclick="closeArchiveModal()">Cancel</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function selectArchiveOption(index, noteId) {
    const archiveNames = Object.keys(namedArchives);
    if (index >= 0 && index < archiveNames.length) {
        addToArchive(noteId, archiveNames[index]);
        showToast(`Note added to "${archiveNames[index]}" archive!`, 'success');
    }
    closeArchiveModal();
}

function closeArchiveModal(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

        // Bulk operations for main view
        function toggleNoteSelection(noteId) {
            if (selectedNotes.has(noteId)) {
                selectedNotes.delete(noteId);
            } else {
                selectedNotes.add(noteId);
            }
            updateSelectionUI();
        }

        function selectAllVisible() {
            filteredNotes.forEach(note => selectedNotes.add(note.id));
            updateSelectionUI();
            renderNotes();
        }

        function deselectAll() {
            selectedNotes.clear();
            updateSelectionUI();
            renderNotes();
        }

        function bulkAddToArchive() {
            const targetArchive = document.getElementById('bulk-archive-dropdown').value;
           if (!targetArchive) {
    showToast('Please select a target archive', 'error');
    return;
}

            if (selectedNotes.size === 0) {
                showToast('Please select some notes first');
                return;
            }

            let addedCount = 0;
            selectedNotes.forEach(noteId => {
                if (!namedArchives[targetArchive].has(noteId)) {
                    namedArchives[targetArchive].add(noteId);
                    addedCount++;
                }
            });

            saveArchivedNotes();
            updateArchiveList();
            updateTagFilters();
            selectedNotes.clear();
            updateSelectionUI();
            renderNotes();

            showToast(`Added ${addedCount} notes to "${targetArchive}" archive`, 'success');
        }

        function bulkRemoveFromArchive() {
            if (selectedNotes.size === 0) {
               showToast('Please select some notes first');
                return;
            }

            let removedCount = 0;
            selectedNotes.forEach(noteId => {
                Object.keys(namedArchives).forEach(archiveName => {
                    if (namedArchives[archiveName].has(noteId)) {
                        namedArchives[archiveName].delete(noteId);
                        removedCount++;
                    }
                });
                archivedNotes.delete(noteId);
            });

            saveArchivedNotes();
            updateArchiveList();
            updateTagFilters();
            selectedNotes.clear();
            updateSelectionUI();
            renderNotes();

            showToast(`Removed ${removedCount} notes from all archives`, 'success');
        }

        function updateSelectionUI() {
            const bulkControls = document.getElementById('bulk-controls');
            const selectedCount = document.getElementById('selected-count');
            
            if (selectedNotes.size > 0) {
                bulkControls.classList.remove('hidden');
                selectedCount.textContent = `${selectedNotes.size} notes selected`;
            } else {
                bulkControls.classList.add('hidden');
            }
        }

       async function connectWithPubkey() {
    // Move these to the very start
    const connectBtn = document.getElementById('connect-btn');
    connectBtn.classList.add('loading');
    connectBtn.disabled = true;
    connectBtn.textContent = 'Connecting...';

    // Check if NostrTools is available
    if (!window.NostrTools) {
        showError('NostrTools library not loaded. Please refresh the page.');
        // Reset button on error
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = ' Load My Notes';
        return;
    }
    
    const raw = document.getElementById('pubkey-input').value;
    const npub = normalizeNpub(raw);

    if (!npub) {
        showError('Please enter your npub');
      connectBtn.classList.remove('loading');
    connectBtn.disabled = false;
    connectBtn.textContent = ' Load My Notes';
    return;
}
    if (!npub.startsWith('npub1')) {
        showError('Invalid npub (must start with "npub1")');
      connectBtn.classList.remove('loading');
    connectBtn.disabled = false;
    connectBtn.textContent = ' Load My Notes';
    return;
}

    if (!/^npub1[02-9ac-hj-np-z]+$/.test(npub)) {
        showError('Invalid npub format');
       connectBtn.classList.remove('loading');
    connectBtn.disabled = false;
    connectBtn.textContent = ' Load My Notes';
    return;
}

    const hexPubkey = npubToHex(npub);
    if (!hexPubkey || hexPubkey.length !== 64) {
        showError('Invalid npub format - could not convert to hex');
       connectBtn.classList.remove('loading');
    connectBtn.disabled = false;
    connectBtn.textContent = ' Load My Notes';
    return;
}

    currentPubkey = hexPubkey.toLowerCase();

// Clear any previous data when switching users
allNotes = [];
filteredNotes = [];
selectedTags.clear();
currentTag = '';

// Clear all filters when switching users
activeQuickFilters.clear();
document.querySelectorAll('.quick-filter-btn').forEach(btn => {
    btn.classList.remove('active');
});

// Clear date filters
document.getElementById('date-from').value = '';
document.getElementById('date-to').value = '';

// Clear search
document.getElementById('search-input').value = '';
searchQuery = '';

// Clear hashtag active states
document.querySelectorAll('.tag-filter').forEach(btn => {
    btn.classList.remove('active');
});

// Reset archive states
currentArchive = 'default';
document.querySelectorAll('.archive-item').forEach(item => {
    item.classList.remove('active');
});

    document.getElementById('tag-filters').innerHTML = '<button class="tag-filter active" data-tag="">Loading...</button>';

    // Load archives for this specific user
loadArchivedNotes();
updateArchiveList();

    // Save the npub for next time
localStorage.setItem('nostr-saved-npub', npub);

document.getElementById('connection-screen').classList.add('hidden');
document.getElementById('main-app').classList.remove('hidden');

    document.getElementById('pubkey-display').textContent = 
   npub.substring(0, 12) + '...' + npub.substring(npub.length - 8);
    
    updateArchiveList();
    updateTargetArchiveDropdown();
    
    await loadNotes(false, false); // false = not silent, false = not refresh (initial load)

   // Reset button after success
connectBtn.classList.remove('loading');
connectBtn.disabled = false;
connectBtn.textContent = ' Load My Notes';
}
    

        function disconnect() {
    // Store the old pubkey before clearing
    const oldPubkey = currentPubkey;
    
    // Reset all variables
    currentPubkey = null;
    allNotes = [];
    filteredNotes = [];
    currentArchive = 'default';
    selectedTags.clear();
    currentTag = '';
    selectedNotes.clear();
    searchQuery = '';

    // Clear all filters on disconnect
activeQuickFilters.clear();
document.querySelectorAll('.quick-filter-btn').forEach(btn => {
    btn.classList.remove('active');
});
document.getElementById('date-from').value = '';
document.getElementById('date-to').value = '';
document.getElementById('search-input').value = '';
searchQuery = '';
    
    // Clear ONLY cache data, NOT user archives
    localStorage.removeItem('nostr-last-pubkey');
    localStorage.removeItem('nostr-cached-notes'); 
    localStorage.removeItem('nostr-cache-updated-at');
    localStorage.removeItem('nostr-saved-npub');
    // DO NOT clear: nostr-archived-notes-* and nostr-named-archives-*
    
    // Clear the UI immediately
    document.getElementById('notes-container').innerHTML = '';
    document.getElementById('tag-filters').innerHTML = '<button class="tag-filter active" data-tag="">All Notes (0)</button>';
    document.getElementById('notes-count').textContent = '0 notes';
    document.getElementById('archive-list').innerHTML = '<div style="color: #666; font-style: italic; font-size: 13px;">No archives created yet</div>';

    // Clear pagination state when switching users
    document.getElementById('load-more-container').classList.add('hidden');
    document.getElementById('pagination-info').textContent = 'Showing 0 of 0 notes';
    
    document.getElementById('main-app').classList.add('hidden');
    document.getElementById('connection-screen').classList.remove('hidden');
    document.getElementById('pubkey-input').value = '';

    hideError();
}

// IndexedDB fallback handler
let useIndexedDB = true;

function disableIndexedDB(error) {
    console.warn('IndexedDB disabled due to error:', error);
    useIndexedDB = false;
    showToast('Using memory-only mode due to storage limitation', 'warning');
}

async function initDatabase(pubkey) {
    if (!useIndexedDB) return null;
    
    try {
        const dbName = `nostr-notes-${pubkey}`;
        
        if (db && db.isOpen()) {
            db.close();
        }
        
        db = new Dexie(dbName);
        db.version(1).stores({
            notes: 'id, pubkey, created_at, content, *hashtags, isReply',
            settings: 'key, value'
        });
        
        await db.open();
        return db;
    } catch (error) {
        disableIndexedDB(error);
        return null;
    }
}

function clearLegacyCache(pubkey) {
    try {
        localStorage.removeItem(`nostr-last-pubkey-${pubkey}`);
        localStorage.removeItem(`nostr-cached-notes-${pubkey}`);
        localStorage.removeItem(`nostr-cache-updated-at-${pubkey}`);
    } catch (error) {
        console.warn('Could not clear legacy cache:', error);
    }
}

async function fetchNotesFromRelays(pubkey) {
    const allEvents = [];
    const completedRelays = [];
    
    // Better progress feedback with relay status tracking
    const relayStatuses = new Map();
    const relayPromises = RELAYS.map(async (relay, index) => {
        const relayName = relay.replace('wss://', '');
        relayStatuses.set(relay, 'connecting');
        
        try {
            updateStatus(`<span class="emoji">🔄</span> ${relayName}: Connecting.`);
            
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => {
                    relayStatuses.set(relay, 'timeout');
                    reject(new Error('Timeout after 60s'));
                }, 60000);  // Changed from 30s to 60s
            });
            
            const fetchPromise = fetchAllNotesFromRelay(relay, pubkey, (progress, status) => {
                relayStatuses.set(relay, 'fetching');
                const completedCount = Array.from(relayStatuses.values()).filter(s => s === 'completed' || s === 'failed').length;
                updateProgress(
                    20 + ((completedCount / RELAYS.length) * 60), 
                    `${relayName}: ${status} | ${completedCount}/${RELAYS.length} relays done`
                );
            });
            
            const events = await Promise.race([fetchPromise, timeoutPromise]);
            
            relayStatuses.set(relay, 'completed');
            const completedCount = Array.from(relayStatuses.values()).filter(s => s === 'completed').length;
            updateStatus(`<span class="emoji">✅</span> ${relayName}: ${events.length} notes (${completedCount}/${RELAYS.length} relays completed)`);
            
            completedRelays.push(relay);
            return { relay, events, success: true };
            
        } catch (error) {
            relayStatuses.set(relay, 'failed');
            const failedCount = Array.from(relayStatuses.values()).filter(s => s === 'failed').length;
            updateStatus(`❌ ${relayName}: ${error.message} (${failedCount} failed)`);
            return { relay, events: [], success: false, error: error.message };
        }
    });
    
    // Wait for ALL relays to finish (they run simultaneously)
    const results = await Promise.allSettled(relayPromises);
    
    // Collect all events
    results.forEach((result, index) => {
        if (result.status === 'fulfilled' && result.value.success) {
            allEvents.push(...result.value.events);
        }
    });
    
    updateProgress(100, 'Deduplicating notes...');

    // Memory-conscious deduplication with progress tracking
    const uniqueEventsMap = new Map();
    let duplicatesFound = 0;
    let memoryWarningShown = false;

    // Check memory usage periodically
    const checkMemoryUsage = () => {
        if (performance.memory && performance.memory.usedJSHeapSize > 500 * 1024 * 1024) { // 500MB
            if (!memoryWarningShown) {
                updateStatus('⚠️ High memory usage detected - processing in smaller chunks');
                memoryWarningShown = true;
            }
            return true;
        }
        return false;
    };

    const processChunk = async (events, startIndex, chunkSize = 10000) => {
        const highMemory = checkMemoryUsage();
        const adjustedChunkSize = highMemory ? Math.min(chunkSize, 2000) : chunkSize;
        
        const endIndex = Math.min(startIndex + adjustedChunkSize, events.length);
        
        for (let i = startIndex; i < endIndex; i++) {
            const event = events[i];
            if (!event?.id) continue;
            
            const existing = uniqueEventsMap.get(event.id);
            if (!existing) {
                uniqueEventsMap.set(event.id, event);
            } else {
                duplicatesFound++;
                // Keep the event with more complete data
                if ((event.tags?.length || 0) > (existing.tags?.length || 0) || 
                    event.content.length > existing.content.length) {
                    uniqueEventsMap.set(event.id, event);
                }
            }
        }
        
        // Update progress every 10k notes or at completion
        if (endIndex % 10000 === 0 || endIndex === events.length) {
            const progress = (endIndex / events.length) * 100;
            updateStatus(`Deduplicating: ${endIndex}/${events.length} processed (${duplicatesFound} duplicates found)`);
        }
        
        if (endIndex < events.length) {
            // Longer pause if memory is high
            const pauseMs = highMemory ? 10 : 1;
            await new Promise(resolve => setTimeout(resolve, pauseMs));
            await processChunk(events, endIndex, adjustedChunkSize);
        }
    };

    await processChunk(allEvents, 0);

    const uniqueEvents = Array.from(uniqueEventsMap.values());
    updateStatus(`✅ Deduplication complete: ${uniqueEvents.length} unique notes (removed ${duplicatesFound} duplicates)`);

    return uniqueEvents;
}

async function fetchNotesFromRelaysSince(pubkey, sinceTimestamp) {
    const allEvents = [];
    const completedRelays = [];
    
    updateStatus('🔄 Checking relays for new notes...');
    
    const relayPromises = RELAYS.map(async (relay, index) => {
        const relayName = relay.replace('wss://', '');
        
        try {
            // Only fetch notes newer than our newest stored note
            const newNotes = await fetchNewNotesFromRelay(relay, pubkey, sinceTimestamp);
            
            updateStatus(`✅ ${relayName}: ${newNotes.length} new notes`);
            return { relay, events: newNotes, success: true };
            
        } catch (error) {
            updateStatus(`❌ ${relayName}: ${error.message}`);
            return { relay, events: [], success: false };
        }
    });
    
    const results = await Promise.allSettled(relayPromises);
    
    // Collect new events
    results.forEach((result) => {
        if (result.status === 'fulfilled' && result.value.success) {
            allEvents.push(...result.value.events);
        }
    });
    
    // Simple deduplication for new notes
    const uniqueEvents = [];
    const seenIds = new Set();
    
    allEvents.forEach(event => {
        if (event.id && !seenIds.has(event.id)) {
            seenIds.add(event.id);
            uniqueEvents.push(event);
        }
    });
    
    return uniqueEvents;
}

async function fetchNewNotesFromRelay(relayUrl, pubkey, sinceTimestamp) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        const events = [];
        let timeoutId;
        
        ws.onopen = function() {
            const filter = {
                kinds: [1],
                authors: [pubkey],
                since: sinceTimestamp + 1, // Only notes newer than this
                limit: 1000 // Reasonable limit for new notes
            };
            
            const subscription = ['REQ', 'incremental-' + Date.now(), filter];
            ws.send(JSON.stringify(subscription));
            
            timeoutId = setTimeout(() => {
                ws.close();
                resolve(events);
            }, 10000); // 10 second timeout
        };
        
        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const [type, subId, eventData] = message;
                
                if (type === 'EVENT') {
                    const note = processNote(eventData);
                    if (note) {
                        events.push(note);
                    }
                } else if (type === 'EOSE') {
                    clearTimeout(timeoutId);
                    ws.close();
                    resolve(events);
                }
            } catch (error) {
                console.error('Error parsing message:', error);
            }
        };
        
        ws.onerror = function() {
            clearTimeout(timeoutId);
            reject(new Error('Connection failed'));
        };
        
        ws.onclose = function() {
            clearTimeout(timeoutId);
            resolve(events);
        };
    });
}

async function fetchAllNotesFromRelay(relayUrl, pubkey, progressCallback) {
    const allEvents = [];
    let until = null;
    let batchNumber = 1;
   const batchSize = 2000
    
    while (true) {
        progressCallback(
            Math.min(95, (batchNumber - 1) * 15), 
            `batch ${batchNumber} (${allEvents.length} notes)`
        );
        
        try {
            
            const batchEvents = await fetchBatchFromRelay(relayUrl, pubkey, until, batchSize);
            
            allEvents.push(...batchEvents);
            
            const oldestEvent = batchEvents[batchEvents.length - 1];
            until = oldestEvent.created_at - 1;
            
            
            batchNumber++;
            
            // Only stop if we get no events or encounter errors
if (batchEvents.length === 0) {
    break;
}

// Rate limiting - longer delay for aggressive fetching
await new Promise(resolve => setTimeout(resolve, 150)); // Increased to 100ms

// Safety check - if we've been fetching for too long, break
if (batchNumber > 100) { // Allow up to 100 batches (200k notes max)
    console.log(`Reached safety limit of ${batchNumber} batches for ${relayUrl}`);
    break;
}
            
        } catch (error) {
            console.error(`Error fetching batch ${batchNumber} from ${relayUrl}:`, error);
            break;
        }
    }
    
    progressCallback(100, `complete (${allEvents.length} notes)`);
    return allEvents;
}

      // Add this function before loadNotes
async function loadNotesHybrid(pubkey, silent = false) {
    try {
        // Try to initialize IndexedDB
        const database = await initDatabase(pubkey);
        
        if (!database || !useIndexedDB) {
            // Fall back to original method
            return await fetchNotesFromRelays(pubkey);
        }
        
        // Check for existing data and last sync time
        const storedCount = await db.notes.count();
        const lastSync = await db.settings.get('last_sync_time');
        
        if (!silent) {
            updateStatus(`Database ready. Found ${storedCount} stored notes.`);
        }
        
        // If we have recent data (less than 1 hour old), use it
        const oneHour = 60 * 60 * 1000;
        if (lastSync && (Date.now() - lastSync.value) < oneHour && storedCount > 0) {
            if (!silent) {
                updateStatus('Loading from IndexedDB...');
            }
            
           // Load ALL notes from IndexedDB
const allStoredNotes = await db.notes
    .orderBy('created_at')
    .reverse()
    .toArray();

return allStoredNotes;
        }
        
        // Otherwise, fetch fresh data from relays
        const freshNotes = await fetchNotesFromRelays(pubkey);
        
        // Store the fresh data
        if (freshNotes.length > 0) {
            await db.notes.clear(); // Clear old data
            await db.notes.bulkAdd(freshNotes);
            await db.settings.put({ key: 'last_sync_time', value: Date.now() });
            
            if (!silent) {
                updateStatus(`Stored ${freshNotes.length} notes in IndexedDB`);
            }
        }
        
        return freshNotes;
        
    } catch (error) {
        console.error('Hybrid loading error:', error);
        disableIndexedDB(error);
        // Fallback to memory-only
        return await fetchNotesFromRelays(pubkey);
    }
}

async function incrementalSync(pubkey, silent = true) {
    if (!db || !useIndexedDB) {
        return await fetchNotesFromRelays(pubkey); // Fallback to full fetch
    }
    
    try {
        // Get the newest note we have stored
        const newestStoredNote = await db.notes
            .orderBy('created_at')
            .reverse()
            .first();
        
        if (!newestStoredNote) {
            // No stored notes, do full fetch
            return await fetchNotesFromRelays(pubkey);
        }
        
        const lastTimestamp = newestStoredNote.created_at;
        
        if (!silent) {
            updateStatus(`Checking for notes newer than ${new Date(lastTimestamp * 1000).toLocaleString()}...`);
        }
        
        // Fetch only newer notes from relays
        const newNotes = await fetchNotesFromRelaysSince(pubkey, lastTimestamp);
        
        if (newNotes.length > 0) {
            // Add new notes to IndexedDB
            await db.notes.bulkAdd(newNotes);
            await db.settings.put({ key: 'last_sync_time', value: Date.now() });
            
            if (!silent) {
                updateStatus(`Found and stored ${newNotes.length} new notes`);
            }
            
            // Return all notes (existing + new) for display
            const allNotes = await db.notes
                .orderBy('created_at')
                .reverse()
                .toArray();
            
            return allNotes;
        } else {
            if (!silent) {
                updateStatus('No new notes found');
            }
            
            // Return existing notes
            return await db.notes
                .orderBy('created_at')
                .reverse()
                .toArray();
        }
        
    } catch (error) {
        console.error('Incremental sync error:', error);
        // Fallback to full fetch
        return await fetchNotesFromRelays(pubkey);
    }
}

async function loadNotes(silent = false, isRefresh = false) {
    const previousNotesCount = allNotes.length; // Track what we had before
    
    if (!silent) {
        showLoading(true);
        updateProgress(0, 'Connecting to relays.');
        updateStatus('Starting fresh load...', true);
    } else {
        // small indicator only
        updateStatus('Refreshing notes…');
    }
            
    try {

        const notes = await loadNotesHybrid(currentPubkey, silent);

// Clear old localStorage cache since we're using IndexedDB now
if (useIndexedDB) {
    clearLegacyCache(currentPubkey);
}
        
        updateStatus(`Sorting ${notes.length} notes by date...`);
        await new Promise(resolve => setTimeout(resolve, 10)); // Brief pause
        
        allNotes = notes.sort((a, b) => b.created_at - a.created_at);
        
        updateStatus('Updating archives list...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Initialize archives UI after loading
        updateArchiveList();
        updateTargetArchiveDropdown();
        
        updateStatus('Updating tag filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        updateTagFilters();
        
        updateStatus('Applying filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        applyFilters();
        
        updateStatus('Rendering notes...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        renderNotes();
        
        // FIXED: Calculate what was actually new
        const newNotesCount = allNotes.length - previousNotesCount;
        updateStatus(`✅ Successfully loaded ${allNotes.length} notes!`);
        
        if (!silent && isRefresh === true) {
            if (newNotesCount > 0) {
                showToast(`Refresh complete - ${newNotesCount} new notes loaded (${allNotes.length} total)`, 'success');
            } else {
                showToast(`Refresh complete - no new notes found (${allNotes.length} total)`, 'success');
            }
        } else {
        }
        
    } catch (error) {
        console.error('Error loading notes:', error);
        showError('Failed to load notes: ' + error.message);
    } finally {
    if (!silent) {
        showLoading(false);
    }
}
}// <-- closes async function loadNotes
      
async function fetchBatchFromRelay(relayUrl, pubkey, until, limit, retryCount = 0) {
    const maxRetries = 3;
    
    try {
        return await fetchBatchFromRelayCore(relayUrl, pubkey, until, limit);
    } catch (error) {
        if (retryCount < maxRetries) {
            const backoffDelay = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s
            console.log(`Retry ${retryCount + 1}/${maxRetries} for ${relayUrl} after ${backoffDelay}ms`);
            await new Promise(resolve => setTimeout(resolve, backoffDelay));
            return fetchBatchFromRelay(relayUrl, pubkey, until, limit, retryCount + 1);
        }
        throw error;
    }
}

function fetchBatchFromRelayCore(relayUrl, pubkey, until, limit) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        const events = [];
        let timeoutId;
        let isResolved = false;
        let connectionStartTime = Date.now();
        
        const cleanup = (reason = 'unknown') => {
            if (timeoutId) clearTimeout(timeoutId);
            if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
                ws.close(1000, 'Batch complete');
            }
        };
        
        const resolveOnce = (result) => {
            if (!isResolved) {
                isResolved = true;
                const duration = Date.now() - connectionStartTime;
                cleanup(`resolved with ${result.length} events in ${duration}ms`);
                resolve(result);
            }
        };
        
        const rejectOnce = (error) => {
            if (!isResolved) {
                isResolved = true;
                cleanup('error: ' + error.message);
                reject(error);
            }
        };
        
        ws.onopen = function() {
            const filter = {
                kinds: [1],
                authors: [pubkey],
                limit: limit
            };
            
            if (until) {
                filter.until = until;
            }
            
            const subscription = ['REQ', 'batch-' + Date.now(), filter];
            ws.send(JSON.stringify(subscription));
            
            timeoutId = setTimeout(() => {
    resolveOnce(events);
}, 30000); // Increased to 30s for older notes
        };
        
        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const [type, subId, eventData] = message;
                
                if (type === 'EVENT') {
                    const note = processNote(eventData);
                    if (note) {
                        events.push(note);
                    }
                } else if (type === 'EOSE') {
                    resolveOnce(events);
                } else if (type === 'NOTICE') {
                    if (message[1] && message[1].toLowerCase().includes('error')) {
                        console.warn(`Notice from ${relayUrl}:`, message[1]);
                    }
                }
            } catch (error) {
                console.error('Error parsing message from', relayUrl, ':', error);
            }
        };
        
        ws.onerror = function(error) {
            console.error(`WebSocket error on ${relayUrl}:`, error);
            rejectOnce(new Error('Connection failed'));
        };
        
        ws.onclose = function(event) {
            if (!isResolved) {
                resolveOnce(events);
            }
        };
    });
}

        function processNote(event) {
    // Remove all console.log calls - they're killing performance
    if (!event || !event.content || !event.id) {
        return null;
    }
    
    const hashtags = extractHashtags(event.content);
    
    // Check if this is a reply by looking for 'e' or 'p' tags in the event
    const isReply = event.tags && event.tags.some(tag => 
        (tag[0] === 'e') || // 'e' tags reference other events (replies)
        (tag[0] === 'p' && tag[1] !== event.pubkey) || // 'p' tags reference other users
        event.content.startsWith('@') || // Content starts with mention
        event.content.includes('nostr:') // Contains nostr references
    );    
    
    return {
        id: event.id,
        pubkey: event.pubkey,
        created_at: event.created_at,
        content: event.content,
        hashtags: hashtags,
        isReply: isReply,
        tags: event.tags || []
    };
}

        function extractHashtags(content) {
            const matches = content.match(/#\w+/g);
            return matches ? matches.map(tag => tag.toLowerCase()) : [];
        }

        function updateTagFilters() {
            const tagCounts = {};
            
          // Process hashtags - removed performance-killing logs
allNotes.forEach(note => {
    if (note.hashtags && Array.isArray(note.hashtags)) {
        note.hashtags.forEach(tag => {
            tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        });
    }
});
            
            const archivedCount = allNotes.filter(note => archivedNotes.has(note.id)).length;
            const originalNotesCount = allNotes.filter(note => !note.isReply).length;
            const repliesCount = allNotes.filter(note => note.isReply).length;
            
            const container = document.getElementById('tag-filters');
            if (!container) {
                console.error('tag-filters container not found!');
                return;
            }
            
            container.innerHTML = `
  <button class="tag-filter active" data-tag="">All Notes (${allNotes.length})</button>
  <button class="tag-filter" data-tag="__original"><span class="emoji">📝</span> Original Notes (${originalNotesCount})</button>
  <button class="tag-filter" data-tag="__replies"><span class="emoji">💬</span> Replies (${repliesCount})</button>
`;
            

// Group hashtags alphabetically
const hashtagGroups = {};
Object.keys(tagCounts).sort((a, b) => a.localeCompare(b)).forEach(tag => {
    const firstLetter = tag.charAt(1).toUpperCase(); // Skip the # symbol
    if (!hashtagGroups[firstLetter]) {
        hashtagGroups[firstLetter] = [];
    }
    hashtagGroups[firstLetter].push(tag);
});

// Add grouped hashtags with collapsible sections
Object.keys(hashtagGroups).sort().forEach(letter => {
    const groupCount = hashtagGroups[letter].length;
    
    // Add clickable letter header
    const letterHeader = document.createElement('button');
    letterHeader.className = 'hashtag-group-header';
    letterHeader.style.cssText = `
        width: 100%;
        text-align: left;
        background: var(--background-color);
        border: 1px solid var(--border-color);
        padding: 8px 12px;
        margin: 8px 0 0 0;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        color: var(--text-color);
        font-size: 13px;
        transition: background-color 0.2s ease;
    `;
    letterHeader.textContent = `${letter} (${groupCount} hashtags)`;
    letterHeader.onclick = () => toggleHashtagGroup(letter);
    container.appendChild(letterHeader);
    
    // Add container for hashtags (initially hidden)
const hashtagContainer = document.createElement('div');
hashtagContainer.id = `hashtag-group-${letter}`;
hashtagContainer.style.cssText = `
    display: none;
    margin: 0 0 8px 0;
    padding: 4px 0;
    border-left: 2px solid var(--border-color);
    padding-left: 8px;
`;
    
    hashtagGroups[letter].forEach(tag => {
    const button = document.createElement('button');
    button.className = 'tag-filter';
    button.dataset.tag = tag;
    button.textContent = `${tag} (${tagCounts[tag]})`;
    button.addEventListener('click', () => toggleTag(tag));
    hashtagContainer.appendChild(button);
});
    
    container.appendChild(hashtagContainer);
    
});
            
            // Add click handlers
            const allNotesBtn = container.querySelector('[data-tag=""]');
            const originalBtn = container.querySelector('[data-tag="__original"]');
            const repliesBtn = container.querySelector('[data-tag="__replies"]');
            
           if (allNotesBtn) allNotesBtn.addEventListener('click', () => toggleTag(''));
if (originalBtn) originalBtn.addEventListener('click', () => toggleTag('__original'));
if (repliesBtn)  repliesBtn.addEventListener('click', () => toggleTag('__replies'));

            setActiveTagButtons();
        
            // --- one-time drag-select listeners for tag filters ---
(function initTagDragOnce() {
  const tagFiltersEl = document.getElementById('tag-filters');
  if (!tagFiltersEl || tagFiltersEl.__dragInit) return;

  // Start drag only with LEFT button and only on real hashtags (e.g., "#coffee")
  tagFiltersEl.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return;                         // left click only
    const btn = e.target.closest('.tag-filter');
    if (!btn) return;
    const tag = btn.dataset.tag;
    if (!tag || !tag.startsWith('#')) return;           // ignore All/Original/Replies
    startHashtagSelection(tag, e);                      // decides add/remove mode
  });

  // Continue while holding the button, over real hashtags only
  tagFiltersEl.addEventListener('mouseover', (e) => {
    if (!isSelecting) return;                           // set by startHashtagSelection
    const btn = e.target.closest('.tag-filter');
    if (!btn) return;
    const tag = btn.dataset.tag;
    if (!tag || !tag.startsWith('#')) return;
    continueHashtagSelection(tag, e);
  });

  // End drag anywhere
  document.addEventListener('mouseup', endHashtagSelection);

  tagFiltersEl.__dragInit = true;                       // guard against rebinding
})();
        }
        

        function filterByTag(tag) {
            currentTag = tag;
            
            // Update active button
            document.querySelectorAll('.tag-filter').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tag === tag) {
                    btn.classList.add('active');
                }
            });
            
            applyFilters();
            renderNotes();
            setActiveTagButtons();
        }

        function toggleHashtagGroup(letter) {
    const container = document.getElementById(`hashtag-group-${letter}`);
    
    if (container.style.display === 'none') {
        container.style.display = 'block';
    } else {
        container.style.display = 'none';
    }
}

function setActiveTagButtons() {
  const buttons = document.querySelectorAll('#tag-filters .tag-filter');
  buttons.forEach(btn => {
    const t = btn.dataset.tag || '';
    
    // Clear existing active state
    btn.classList.remove('active');
    
    // "All Notes" is active only when nothing is selected AND we're not in archive view
    if (t === '' && selectedTags.size === 0 && !currentTag.startsWith('__archive_')) {
      btn.classList.add('active');
    } 
    // Hashtag buttons are active when they're in selectedTags (regardless of archive view)
    else if (t !== '' && selectedTags.has(t)) {
      btn.classList.add('active');
    }
    // Special buttons (Original Notes, Replies) are active when selected
    else if (t === '__original' && selectedTags.has('__original')) {
      btn.classList.add('active');
    }
    else if (t === '__replies' && selectedTags.has('__replies')) {
      btn.classList.add('active');
    }
  });
}

function applyDateFilters() {
    // Clear archive selection when manually setting dates
    const dateFrom = document.getElementById('date-from').value;
    const dateTo = document.getElementById('date-to').value;
    
    if (dateFrom || dateTo) {
        currentArchive = 'default';
        currentTag = '';
        selectedTags.clear();
        
        // Clear archive active states
        document.querySelectorAll('.archive-item').forEach(item => {
            item.classList.remove('active');
        });
        
        // Clear tag filter active states
        document.querySelectorAll('.tag-filter').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Set "All Notes" as active
        document.querySelector('.tag-filter[data-tag=""]').classList.add('active');
    }
    
    applyAllFilters();
}


// Make it globally available
window.toggleHashtagGroup = toggleHashtagGroup;
        // === Multi-tag selection helpers ===
function toggleTag(tag) {
    // ALWAYS clear archive active states when selecting any tag
    currentArchive = 'default';
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    if (!tag) {
        // "All Notes" clears all selections AND resets currentTag
        selectedTags.clear();
        currentTag = '';
    } else if (selectedTags.has(tag)) {
        selectedTags.delete(tag);
    } else {
        selectedTags.add(tag);
    }
    
    // Check if both original and replies are selected
    const hasOriginal = selectedTags.has('__original');
    const hasReplies = selectedTags.has('__replies');
    
    if (hasOriginal && hasReplies && selectedTags.size === 2) {
        // If both are selected, clear them and activate "All Notes"
        selectedTags.clear();
        currentTag = '';
    }
    
    setActiveTagButtons();
    applyFilters();
    renderNotes();
}

// Check if a single tag matches a note
function noteMatchesTag(note, tag) {
  if (tag === '__original') return !note.isReply;
  if (tag === '__replies') return note.isReply;
  if (tag === '__archived') return archivedNotes.has(note.id);
  if (tag.startsWith('__archive_')) {
    const name = tag.replace('__archive_', '');
    return namedArchives[name] && namedArchives[name].has(note.id);
  }
  // regular hashtag
  return note.hashtags && note.hashtags.includes(tag);
}

        function handleSearch() {
            searchQuery = document.getElementById('search-input').value.toLowerCase();
            applyFilters();
            renderNotes();
        }

      function applyFilters() {
  // Start from all notes
  filteredNotes = allNotes.slice();

  // If multiple tags are selected, keep notes that match ANY selected tag
  if (selectedTags.size > 0) {
    const tags = Array.from(selectedTags);
    filteredNotes = filteredNotes.filter(note =>
      tags.some(tag => noteMatchesTag(note, tag))
    );
  } else {
    // Fall back to old single-select behavior (currentTag)
    if (currentTag === '__archived') {
      filteredNotes = filteredNotes.filter(note => archivedNotes.has(note.id));
    } else if (currentTag === '__original') {
      filteredNotes = filteredNotes.filter(note => !note.isReply);
    } else if (currentTag === '__replies') {
      filteredNotes = filteredNotes.filter(note => note.isReply);
    } else if (currentTag && currentTag.startsWith('__archive_')) {
      const archiveName = currentTag.replace('__archive_', '');
      if (namedArchives[archiveName]) {
        filteredNotes = filteredNotes.filter(note => namedArchives[archiveName].has(note.id));
      }
    } else if (currentTag) {
      filteredNotes = filteredNotes.filter(note => note.hashtags.includes(currentTag));
    }
  }

  // Text search still applies
  if (searchQuery) {
    const q = searchQuery.toLowerCase();
    filteredNotes = filteredNotes.filter(note =>
      note.content.toLowerCase().includes(q) ||
      (note.hashtags && note.hashtags.some(tag => tag.includes(q)))
    );
  }

   // Reset pagination when filters change
  resetPagination();
}



        function renderNotes() {
     
    
    const container = document.getElementById('notes-container');
    const emptyState = document.getElementById('empty-state');
    const loadMoreContainer = document.getElementById('load-more-container');
    const paginationInfo = document.getElementById('pagination-info');
    const title = document.getElementById('notes-title');
    const count = document.getElementById('notes-count');
    
    if (!container) {
        console.error('notes-container not found!');
        return;
    }
    
    // Calculate how many notes to show
    const totalToShow = Math.min(currentPage * notesPerPage, filteredNotes.length);
    const notesToRender = filteredNotes.slice(0, totalToShow);
            
    // Update title and count
if (selectedTags.size > 0) {
    // Check if both original and replies are selected - that's equivalent to "All Notes"
    const hasOriginal = selectedTags.has('__original');
    const hasReplies = selectedTags.has('__replies');
    
    if (hasOriginal && hasReplies && selectedTags.size === 2) {
        // If only original and replies are selected, show "All Notes"
        title.textContent = 'All Notes';
    } else {
        // Multi-tag selection takes priority
        const tagNames = Array.from(selectedTags).map(tag => {
            if (tag === '__original') return 'Original Notes';
            if (tag === '__replies') return 'Replies';
            if (tag === '__archived') return 'Archived';
            return tag;
        });
        title.textContent = tagNames.join(' + ');
    }
} else if (currentTag === '__archived') {
    title.textContent = 'All Archived Notes';
} else if (currentTag === '__original') {
    title.textContent = 'Original Notes';
} else if (currentTag === '__replies') {
    title.textContent = 'Replies';
} else if (currentTag.startsWith('__archive_')) {
    const archiveName = currentTag.replace('__archive_', '');
   // Check if neon-green theme is active
const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
title.textContent = isNeonGreen ? `Archive: ${archiveName}` : `📂 Archive: ${archiveName}`;
    title.style.color = 'var(--text-muted)';
} else if (currentTag) {
    title.textContent = `Notes tagged ${currentTag}`;
    title.style.color = '';     // Reset color
    title.style.fontWeight = ''; // Reset weight
} else {
    title.textContent = 'All Notes';
    title.style.color = '';     // Reset color
    title.style.fontWeight = ''; // Reset weight
}
            count.textContent = `${filteredNotes.length} notes`;

if (filteredNotes.length === 0) {
    container.innerHTML = '';
    loadMoreContainer.classList.add('hidden');
    if (emptyState) emptyState.classList.remove('hidden');
    updateSelectionUI();
    return;
}

// Update export button text to show what will be exported
const exportJsonBtn = document.getElementById('export-json');
const exportMdBtn = document.getElementById('export-md');
// Define isNeonGreen here so it can be used below
const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';

if (currentTag.startsWith('__archive_')) {
  const archiveName = currentTag.replace('__archive_', '');
  if (exportJsonBtn) exportJsonBtn.textContent = `Export "${archiveName}" JSON`;
  if (exportMdBtn)   exportMdBtn.textContent   = `Export "${archiveName}" Markdown`;
} else {
  if (exportJsonBtn) exportJsonBtn.textContent = 'Export JSON';
  if (exportMdBtn)   exportMdBtn.textContent   = 'Export Markdown';
}

if (emptyState) emptyState.classList.add('hidden');

// Only show load more button if we're not currently loading AND there are more notes to show
const isCurrentlyLoading = !document.getElementById('loading').classList.contains('hidden');
if (!isCurrentlyLoading && totalToShow < filteredNotes.length) {
    loadMoreContainer.classList.remove('hidden');
    paginationInfo.textContent = `Showing ${totalToShow} of ${filteredNotes.length} notes`;
} else {
    loadMoreContainer.classList.add('hidden');
    if (!isCurrentlyLoading && filteredNotes.length > notesPerPage) {
        paginationInfo.textContent = `Showing all ${filteredNotes.length} notes`;
    }
}
            
            
            // Render notes in chunks to prevent blocking
            const renderInChunks = async () => {
                const chunkSize = 50; // Smaller chunks for rendering
                let html = '';
                
               for (let i = 0; i < notesToRender.length; i += chunkSize) {
                  const chunk = notesToRender.slice(i, i + chunkSize);
                    
                    chunk.forEach(note => {
    const date = new Date(note.created_at * 1000).toLocaleString();
    const isArchived = archivedNotes.has(note.id);
    const isReply = note.isReply;
    const isSelected = selectedNotes.has(note.id);
    
    const hashtagsHtml = note.hashtags && note.hashtags.length > 0 ? 
note.hashtags.map(tag => 
    `<span class="hashtag" 
           onmousedown="startHashtagSelection('${tag}', event)" 
           onmouseenter="continueHashtagSelection('${tag}', event)"
           ontouchstart="startHashtagSelection('${tag}', event)"
           data-tag="${tag}"
           ${selectedTags.has(tag) ? 'data-selected="true"' : ''}>${tag}</span>`
).join(' ') : '';
    
    // Different styling for replies
    const cardClass = `note-card ${isArchived ? 'archived' : ''} ${isReply ? 'reply-card' : ''}`;
    const replyIndicator = isReply ? '<span class="emoji">💬</span> ' : '<span class="emoji">📄</span> ';
    
    // IMPROVED: Check if we're in a specific archive view
    const isInSpecificArchive = currentTag.startsWith('__archive_');
    const currentArchiveName = isInSpecificArchive ? currentTag.replace('__archive_', '') : '';
    const isNoteInCurrentArchive = isInSpecificArchive && namedArchives[currentArchiveName] && namedArchives[currentArchiveName].has(note.id);
    
    // Create the appropriate archive button
    let archiveButtonHtml = '';
    if (isInSpecificArchive && isNoteInCurrentArchive) {
        // We're viewing a specific archive and this note is in it - show "Remove from [archive]"
        archiveButtonHtml = `
            <button class="btn btn-small" style="background: #e74c3c; color: white;" 
                    onclick="removeFromSpecificArchive('${note.id}', '${currentArchiveName}')">
                <span class="emoji">🗑️</span> Remove
            </button>`;
    } else {
        // Normal archive/unarchive button
        archiveButtonHtml = `
            <button class="btn btn-small btn-archive ${isArchived ? 'archived' : ''}" 
                    onclick="toggleArchiveNote('${note.id}')">
                ${isArchived ? '✓ Archived' : '<span class="emoji">📂</span> Archive'}
            </button>`;
    }
    
    html += `
        <div class="${cardClass}">
            <div class="note-header">
                <div style="display: flex; align-items: center;">
                    <input type="checkbox" class="note-checkbox" ${isSelected ? 'checked' : ''} 
                           onchange="toggleNoteSelection('${note.id}')">
                    <span>${replyIndicator}${date}</span>
                </div>
                <div class="note-actions">
                    ${archiveButtonHtml}
                    <button class="btn btn-small" style="background: #95a5a6;" 
                            onclick="showNoteInfo('${note.id}')">
                        <span class="emoji">ℹ️</span> Info
                    </button>
                </div>
            </div>
            <div class="note-content">${processYouTubeLinks(processImageLinks(escapeHtml(note.content)))}</div>
            ${hashtagsHtml ? `<div class="hashtags">${hashtagsHtml}</div>` : ''}
        </div>
    `;
});

                    
                    // Update progress and yield control
                    if (i % 100 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                container.innerHTML = html;
                setupLazyLoading();
                updateSelectionUI();
                setupHashtagDragSelection();
                
            };
            
            renderInChunks();
        }


        function refreshNotes() {
    if (!currentPubkey) {
        showToast('No user connected - cannot refresh', 'error');
        return;
    }
    
    // Use incremental sync instead of full reload
    loadNotesIncremental(true); // true = is refresh
}

async function loadNotesIncremental(isRefresh = false) {
    const previousNotesCount = allNotes.length;
    
    try {
        if (!isRefresh) {
            showLoading(true);
            updateStatus('Loading notes...', true);
        }
        
        const notes = await incrementalSync(currentPubkey, false);
        
        allNotes = notes.sort((a, b) => b.created_at - a.created_at);
        
        updateArchiveList();
        updateTargetArchiveDropdown();
        updateTagFilters();
        applyFilters();
        renderNotes();
        
        const newNotesCount = allNotes.length - previousNotesCount;
        
        if (isRefresh) {
            if (newNotesCount > 0) {
                showToast(`Found ${newNotesCount} new notes!`, 'success');
            } else {
                showToast('No new notes found', 'success');
            }
        }
        
        updateStatus(`✅ Loaded ${allNotes.length} notes (${newNotesCount} new)`);
        
    } catch (error) {
        showError('Refresh failed: ' + error.message);
    } finally {
        if (!isRefresh) {
            showLoading(false);
        }
    }
}

        function exportAsJSON() {
            const dataToExport = filteredNotes;
            
            let filterType;
let displayName; // Add this to show user-friendly names

if (currentTag.startsWith('__archive_')) {
    const archiveName = currentTag.replace('__archive_', '');
    filterType = archiveName;
    displayName = `Archive: ${archiveName}`;
} else if (currentTag === '__original') {
    filterType = 'original-notes';
    displayName = 'Original Notes';
} else if (currentTag === '__replies') {
    filterType = 'replies';
    displayName = 'Replies';
} else if (currentTag) {
    filterType = currentTag;
    displayName = `Tag: ${currentTag}`;
} else {
    filterType = 'all-notes';
    displayName = 'All Notes';
}
            
            const data = {
                exported_at: new Date().toISOString(),
                filter_type: filterType,
                total_notes: dataToExport.length,
                notes: dataToExport.map(note => ({
                    id: note.id,
                    date: new Date(note.created_at * 1000).toISOString(),
                    content: note.content,
                    hashtags: note.hashtags,
                   archived: archivedNotes.has(note.id) || Object.keys(namedArchives).some(archiveName => namedArchives[archiveName].has(note.id)),
                    isReply: note.isReply
                }))
            };
            
            downloadFile(
                JSON.stringify(data, null, 2),
                `nostr-notes-${filterType}-${new Date().toISOString().split('T')[0]}.json`,
                'application/json'
            );
        }

        function exportAsMarkdown() {
            const dataToExport = filteredNotes;
            
            const filterType = currentTag.startsWith('__archive_') 
                ? currentTag.replace('__archive_', '') 
                : currentTag === '__archived' ? 'My Archive' 
                : currentTag || 'All Notes';
            
            let markdown = `# My Nostr Notes\n\n`;
            markdown += `Exported: ${new Date().toISOString()}\n`;
            markdown += `Filter: ${filterType}\n`;
            markdown += `Total Notes: ${dataToExport.length}\n\n---\n\n`;
            
            dataToExport.forEach(note => {
                const date = new Date(note.created_at * 1000).toLocaleString();
                const isArchived = archivedNotes.has(note.id);
                const isReply = note.isReply;
                const noteType = isReply ? '💬' : '📝';
                markdown += `## ${noteType} ${date}${isArchived ? ' 🗂️' : ''}\n\n`;
                markdown += `${note.content}\n\n`;
                if (note.hashtags.length > 0) {
                    markdown += `**Tags:** ${note.hashtags.join(', ')}\n\n`;
                }
                markdown += `---\n\n`;
            });
            
            downloadFile(
                markdown,
                `nostr-notes-${filterType.replace(/[^a-z0-9]/gi, '-').toLowerCase()}-${new Date().toISOString().split('T')[0]}.md`,
                'text/markdown'
            );
        }

        function showNoteInfo(noteId) {
    const note = allNotes.find(n => n.id === noteId);
    if (!note) return;
    
    const date = new Date(note.created_at * 1000);
    const archiveStatus = Object.keys(namedArchives).filter(name => 
        namedArchives[name].has(noteId)
    );
    const nevent = createNevent(note);
    
    const modalHtml = `
        <div class="modal" onclick="closeModal(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeModal()">Close</button>
                <h3>Note Information</h3> 
                <p><strong>Nevent:</strong> <button onclick="copyToClipboard('${nevent}')" class="copy-btn">Copy</button><br><small style="word-break: break-all;">${nevent}</small></p>
                <p><strong>ID:</strong><br><small style="word-break: break-all;">${note.id}</small></p>
                <p><strong>Author:</strong><br><small style="word-break: break-all;">${note.pubkey}</small></p>
                <p><strong>Created:</strong> ${date.toLocaleString()}</p>
                <p><strong>Type:</strong> ${note.isReply ? 'Reply' : 'Original Note'}</p>
                <p><strong>Content Length:</strong> ${note.content.length} characters</p>
                <p><strong>Hashtags:</strong> ${note.hashtags.length > 0 ? note.hashtags.join(', ') : 'None'}</p>
                <p><strong>Archives:</strong> ${archiveStatus.length > 0 ? archiveStatus.join(', ') : 'Not archived'}</p>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeModal(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

        function createNevent(note) {
    try {
        if (!window.NostrTools || !window.NostrTools.nip19) {
            return 'NostrTools not available';
        }
        
        // Create nevent data
        const neventData = {
            id: note.id,
            relays: RELAYS.slice(0, 2), // Include first 2 relays
            author: note.pubkey
        };
        
        return window.NostrTools.nip19.neventEncode(neventData);
    } catch (error) {
        console.error('Error creating nevent:', error);
        return 'Error creating nevent';
    }
}

function clearAllCache() {
    if (confirm('This will clear all cached data, archives, and force a fresh reload. Continue?')) {
        // Only clear data for the current user, not all users
        if (currentPubkey) {
            // Clear cache data for current user
            localStorage.removeItem(`nostr-last-pubkey-${currentPubkey}`);
            localStorage.removeItem(`nostr-cached-notes-${currentPubkey}`);
            localStorage.removeItem(`nostr-cache-updated-at-${currentPubkey}`);
            
            // Clear archives for current user
            localStorage.removeItem(`nostr-archived-notes-${currentPubkey}`);
            localStorage.removeItem(`nostr-named-archives-${currentPubkey}`);
        }
        
        // Clear global settings (theme, etc.) but NOT other users' data
        localStorage.removeItem('nostr-saved-npub');
        localStorage.removeItem('archives-cleanup-done');
        
        // Reset all global variables
        currentPubkey = null;
        allNotes = [];
        filteredNotes = [];
        archivedNotes = new Set();
        namedArchives = {};
        currentTag = '';
        searchQuery = '';
        currentArchive = 'default';
        selectedNotes = new Set();
        selectedTags = new Set();
        
        // Clear the UI immediately
        document.getElementById('notes-container').innerHTML = '';
        document.getElementById('tag-filters').innerHTML = '<button class="tag-filter active" data-tag="">All Notes (0)</button>';
        document.getElementById('notes-count').textContent = '0 notes';
        document.getElementById('notes-title').textContent = 'All Notes';
        document.getElementById('archive-list').innerHTML = '<div style="color: #666; font-style: italic; font-size: 13px;">No archives created yet</div>';
        
        // Hide bulk controls and other UI elements
        document.getElementById('bulk-controls').classList.add('hidden');
        document.getElementById('load-more-container').classList.add('hidden');
        document.getElementById('empty-state').classList.add('hidden');
        
        // Go back to connection screen
        document.getElementById('main-app').classList.add('hidden');
        document.getElementById('connection-screen').classList.remove('hidden');
        document.getElementById('pubkey-input').value = '';
        
        showToast('Cache cleared for current user! Please reconnect.', 'success');
    }
}

                function loadMoreNotes() {
            currentPage++;
            renderNotes();
        }

        function resetPagination() {
    currentPage = 1;
}

        function updateProgress(percent, text) {
            const progressFill = document.getElementById('progress-fill');
            const loadingText = document.getElementById('loading-text');
            
            if (progressFill) {
                progressFill.style.width = `${percent}%`;
                progressFill.textContent = `${Math.round(percent)}%`;
            }
            if (loadingText && text) {
                loadingText.textContent = text;
            }
        }

       function updateStatus(text, clearPrevious = false) {
    const statusInfo = document.getElementById('status-info');
    if (statusInfo) {
        if (clearPrevious) {
            statusInfo.innerHTML = text + '<br>';
        } else {
            statusInfo.innerHTML += text + '<br>';
        }
    }
}

// Toast notification system
// Add these variables at the top of your script
let activeToasts = new Set();
let toastTimeout = null;

// Replace your existing showToast function with this:
function showToast(message, type = 'success', duration = 3000) {
    // Prevent duplicate toasts
    if (activeToasts.has(message)) {
        return;
    }
    
    // Clear any pending toast timeout
    if (toastTimeout) {
        clearTimeout(toastTimeout);
    }
    
    // Add to active toasts
    activeToasts.add(message);
    
    // Remove existing toasts of the same type
    document.querySelectorAll(`.toast.${type}`).forEach(existingToast => {
        existingToast.remove();
    });
    
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    
    document.body.appendChild(toast);
    
    // Trigger animation
    setTimeout(() => toast.classList.add('show'), 10);
    
    // Remove after duration
    toastTimeout = setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            if (document.body.contains(toast)) {
                document.body.removeChild(toast);
            }
            activeToasts.delete(message);
        }, 300);
    }, duration);
}

        // Utility functions
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showLoading(show) {
            document.getElementById('loading').classList.toggle('hidden', !show);
        }

        function showError(message) {
            const errorEl = document.getElementById('connection-error');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function hideError() {
            document.getElementById('connection-error').style.display = 'none';
        }

        function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(function() {
        // Show a brief success message
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        button.style.background = '#27ae60';
        
        setTimeout(() => {
            button.textContent = originalText;
            button.style.background = '#3498db';
        }, 1500);
    }).catch(function(err) {
        // Fallback for older browsers
        console.error('Could not copy text: ', err);
       showToast('Copy failed. Please select and copy manually.');
    });
}

function triggerFileImport() {
    document.getElementById('import-file').click();
}



async function handleFileImport(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const fileName = file.name.toLowerCase();
    
    try {
        const content = await file.text();
        
        if (fileName.endsWith('.json')) {
            await importFromJSON(content);
        } else {
            showToast('Only JSON files are supported for import', 'error');
        }
    } catch (error) {
        console.error('Import error:', error);
        showToast('Error reading file: ' + error.message, 'error');
    }
    
    // Reset file input
    event.target.value = '';
}

async function importFromJSON(jsonContent) {
    try {
        const data = JSON.parse(jsonContent);
        
        // Validate the JSON structure
        if (!data.notes || !Array.isArray(data.notes)) {
            throw new Error('Invalid JSON format - missing notes array');
        }
        
        let importedCount = 0;
        let archivesToCreate = new Set();
        let notesToArchive = [];
        
        // Process each note from the import
        // Process each note from the import with debugging
let foundById = 0;
let foundByContent = 0;
let notFound = 0;
let archivedTrue = 0;
let archivedFalse = 0;

data.notes.forEach(importedNote => {
    const existingNote = allNotes.find(note => 
    note.id === importedNote.id
    // Temporarily comment out content matching
    // || note.content.replace(/\s+/g, ' ').trim() === importedNote.content.replace(/\s+/g, ' ').trim()
);
    
    if (existingNote) {
        if (existingNote.id === importedNote.id) foundById++;
        else foundByContent++;
        
        if (importedNote.archived || importedNote.archiveName) {
            archivedTrue++;
            const archiveName = data.filter_type && data.filter_type !== 'all' 
                ? data.filter_type 
                : 'Imported Archive';
            
            archivesToCreate.add(archiveName);
            notesToArchive.push({
                noteId: existingNote.id,
                archiveName: archiveName
            });
            importedCount++;
        } else {
            archivedFalse++;
        }
    } else {
        notFound++;
    }
});
        
        if (importedCount === 0) {
            showToast('No matching notes found to import', 'warning');
            return;
        }
        
        // Create archives if they don't exist
        archivesToCreate.forEach(archiveName => {
            if (!namedArchives[archiveName]) {
                namedArchives[archiveName] = new Set();
            }
        });
        
        // Add notes to archives
        notesToArchive.forEach(({ noteId, archiveName }) => {
            namedArchives[archiveName].add(noteId);
        });
        
        // Save and update UI
        saveArchivedNotes();
        updateArchiveList();
        updateTagFilters();
        renderNotes();
        
        showToast(`Successfully imported ${importedCount} archived notes!`, 'success');
        
    } catch (error) {
        console.error('JSON import error:', error);
        showToast('Error importing JSON: ' + error.message, 'error');
    }
}

function removeFromSpecificArchive(noteId, archiveName) {
    if (!namedArchives[archiveName]) return;
    
    namedArchives[archiveName].delete(noteId);
    saveArchivedNotes();
    updateArchiveList();
    updateTagFilters();
    renderNotes();
    
    showToast(`Removed note from "${archiveName}" archive`, 'success');
}

let isSelecting = false;
let selectionStarted = false;
let selectionMode = null; // 'add' or 'remove'

function startHashtagSelection(tag, event) {
    event.preventDefault();
    event.stopPropagation();
    
    // Store initial mouse position to detect if this is a drag or click
    const startX = event.clientX;
    const startY = event.clientY;
    const startTime = Date.now();
    
    // Set up temporary mouse move listener to detect drag
    let hasMoved = false;
    const mouseMoveHandler = (moveEvent) => {
        const deltaX = Math.abs(moveEvent.clientX - startX);
        const deltaY = Math.abs(moveEvent.clientY - startY);
        
        // If mouse moved more than 5 pixels, consider it a drag
        if (deltaX > 5 || deltaY > 5) {
            hasMoved = true;
            startDragMode(tag);
        }
    };
    
    // Set up temporary mouse up listener
    const mouseUpHandler = (upEvent) => {
        document.removeEventListener('mousemove', mouseMoveHandler);
        document.removeEventListener('mouseup', mouseUpHandler);
        
        const timeDiff = Date.now() - startTime;
        
        // If it was a quick click without movement, treat as single click
        if (!hasMoved && timeDiff < 300) {
            handleSingleTagClick(tag);
        }
        
        // End any drag operation
        endHashtagSelection();
    };
    
    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', mouseUpHandler);
}

function startDragMode(tag) {
    if (isSelecting) return; // Already in drag mode
    
    isSelecting = true;
    selectionStarted = true;
    
    // Clear any existing archive/filter selections when starting hashtag selection
    currentArchive = 'default';
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Determine selection mode based on current state of clicked tag
    if (selectedTags.has(tag)) {
        selectionMode = 'remove';
        selectedTags.delete(tag);
    } else {
        selectionMode = 'add';
        selectedTags.add(tag);
    }
    
    // Update visuals immediately without full render
    updateHashtagVisualsOnly();
    updateCountOnly();
    setActiveTagButtons();
    
    // Prevent text selection during drag
    document.body.style.userSelect = 'none';
    document.body.style.webkitUserSelect = 'none';
    document.body.style.mozUserSelect = 'none';
    
    // Add visual feedback for drag mode
    document.body.classList.add('hashtag-selecting');
}

function handleSingleTagClick(tag) {
    // This handles normal single-click behavior
    toggleTag(tag);
}

function continueHashtagSelection(tag, event) {
    if (isSelecting && selectionStarted && selectionMode) {
        event.preventDefault();
        event.stopPropagation();
        
        let changed = false;
        
        if (selectionMode === 'add') {
            // Add tags that aren't already selected
            if (!selectedTags.has(tag)) {
                selectedTags.add(tag);
                changed = true;
            }
        } else if (selectionMode === 'remove') {
            // Remove tags that are currently selected
            if (selectedTags.has(tag)) {
                selectedTags.delete(tag);
                changed = true;
            }
        }
        
        if (changed) {
            updateHashtagVisualsOnly();
            updateCountOnly();
            setActiveTagButtons();
        }
    }
}

function endHashtagSelection() {
    if (selectionStarted) {
        isSelecting = false;
        selectionStarted = false;
        selectionMode = null;
        
        // Restore text selection
        document.body.style.userSelect = '';
        document.body.style.webkitUserSelect = '';
        document.body.style.mozUserSelect = '';
        document.body.classList.remove('hashtag-selecting');
        
        // Now do the full render and filter update
        applyFilters();
        renderNotes();
    }
}

// Helper function to update only hashtag visuals without full re-render
function updateHashtagVisualsOnly() {
    document.querySelectorAll('.hashtag').forEach(hashtagElement => {
        const tag = hashtagElement.dataset.tag || hashtagElement.textContent;
        if (selectedTags.has(tag)) {
            hashtagElement.setAttribute('data-selected', 'true');
            hashtagElement.style.backgroundColor = 'var(--primary-color)';
            hashtagElement.style.color = 'white';
            hashtagElement.style.borderColor = 'var(--primary-color)';
        } else {
            hashtagElement.removeAttribute('data-selected');
            hashtagElement.style.backgroundColor = '';
            hashtagElement.style.color = '';
            hashtagElement.style.borderColor = '';
        }
    });
}

// Helper function to update count without full render
function updateCountOnly() {
    // Quick filter update without full processing
    let quickCount = 0;
    if (selectedTags.size > 0) {
        const tags = Array.from(selectedTags);
        quickCount = allNotes.filter(note =>
            tags.some(tag => noteMatchesTag(note, tag))
        ).length;
    } else {
        quickCount = allNotes.length;
    }
    
    document.getElementById('notes-count').textContent = `${quickCount} notes`;
}

function extractVideoId(url) {
    const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
        /youtube\.com\/watch\?.*v=([^&\n?#]+)/
    ];
    
    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) return match[1];
    }
    return null;
}

function processYouTubeLinks(content) {
    const youtubeRegex = /(https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)[^\s]+)/g;
    
    return content.replace(youtubeRegex, (url) => {
        const videoId = extractVideoId(url);
        if (!videoId) return url;
        
        return `<div class="youtube-preview" onclick="loadYouTubeThumbnail(this, '${url}', '${videoId}')" style="
            border: 1px dashed var(--border-color);
            padding: 20px;
            margin: 8px 0;
            border-radius: 6px;
            background: var(--background-color);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        " onmouseover="this.style.borderColor='var(--primary-color)'; this.style.color='var(--primary-color)'" 
           onmouseout="this.style.borderColor='var(--border-color)'; this.style.color='var(--text-muted)'">
            Click to load YouTube video
        </div>`;
    });
}

function processImageLinks(content) {
    const imageRegex = /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp)(?:\?[^\s]*)?)/gi;
    
    return content.replace(imageRegex, (url) => {
        return `<div class="image-preview" onclick="loadImage(this, '${url}')" style="
            border: 1px dashed var(--border-color);
            padding: 20px;
            margin: 8px 0;
            border-radius: 6px;
            background: var(--background-color);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        " onmouseover="this.style.borderColor='var(--primary-color)'; this.style.color='var(--primary-color)'" 
           onmouseout="this.style.borderColor='var(--border-color)'; this.style.color='var(--text-muted)'">
            Click to load image
        </div>`;
    });
}

function loadImage(element, url) {
  // render the image
  element.innerHTML = `
    <div style="position: relative; text-align: center; display: flex; justify-content: center;">
      <img class="note-image"
           src="${url}"
           alt="Image"
           loading="lazy"
           onerror="this.style.display='none'"
           style="max-width: 100%; height: auto; border-radius: 8px; display: block;">
    </div>`;
  // make the WHOLE dotted box clickable to close
  element.setAttribute('onclick', `closeImage(this, '${url}')`);
}

function closeImage(element, url) {
  // restore the preview state on the SAME dotted box
  element.innerHTML = `Click to load image`;
  element.setAttribute('onclick', `loadImage(this, '${url}')`);
  // (mouseover/out styles were already on the outer box, so they keep working)
}

function loadYouTubeThumbnail(element, url, videoId) {
  const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
  element.innerHTML = `
    <div style="position: relative; text-align: center; display: flex; justify-content: center;">
      <div class="youtube-thumbnail"
           onclick="event.stopPropagation(); window.open('${url}', '_blank')">
        <img src="${thumbnailUrl}" alt="YouTube Video" loading="lazy"
             onerror="this.src='https://img.youtube.com/vi/${videoId}/hqdefault.jpg'">
        <div class="play-button"></div>
      </div>
    </div>`;
  // make the WHOLE dotted box clickable to close
  element.setAttribute('onclick', `closeYouTube(this, '${url}', '${videoId}')`);
}

function closeYouTube(element, url, videoId) {
  // restore the preview state on the SAME dotted box
  element.innerHTML = `Click to load YouTube video`;
  element.setAttribute('onclick', `loadYouTubeThumbnail(this, '${url}', '${videoId}')`);
}

async function performAdvancedSearch(query, filters = {}) {
    if (!db || !useIndexedDB) {
        // Fallback to in-memory search
        return performInMemorySearch(query, filters);
    }
    
    try {
        let results = db.notes.orderBy('created_at').reverse();
        
        // Date range filtering
        if (filters.dateFrom) {
            const fromTimestamp = Math.floor(filters.dateFrom.getTime() / 1000);
            results = results.filter(note => note.created_at >= fromTimestamp);
        }
        
        if (filters.dateTo) {
            const toTimestamp = Math.floor(filters.dateTo.getTime() / 1000);
            results = results.filter(note => note.created_at <= toTimestamp);
        }
        
        // Content type filtering
        if (filters.contentType === 'original') {
            results = results.filter(note => !note.isReply);
        } else if (filters.contentType === 'replies') {
            results = results.filter(note => note.isReply);
        }
        
        // Length filtering
        if (filters.minLength) {
            results = results.filter(note => note.content.length >= filters.minLength);
        }
        
        if (filters.maxLength) {
            results = results.filter(note => note.content.length <= filters.maxLength);
        }
        
        // Media filtering
        if (filters.hasImages) {
            results = results.filter(note => {
                const imageRegex = /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp))/gi;
                return imageRegex.test(note.content);
            });
        }
        
        if (filters.hasYouTube) {
            results = results.filter(note => {
                const youtubeRegex = /(youtube\.com\/watch\?v=|youtu\.be\/)/gi;
                return youtubeRegex.test(note.content);
            });
        }
        
        const allResults = await results.toArray();
        
        // Text search (full-text)
        if (query && query.trim()) {
            const searchTerms = query.toLowerCase().split(/\s+/);
            return allResults.filter(note => {
                const searchText = (note.content + ' ' + (note.hashtags || []).join(' ')).toLowerCase();
                return searchTerms.every(term => searchText.includes(term));
            });
        }
        
        return allResults;
        
    } catch (error) {
        console.error('Advanced search error:', error);
        return performInMemorySearch(query, filters);
    }
}

function performInMemorySearch(query, filters) {
    let results = allNotes.slice();
    
    // Apply date filters
    if (filters.dateFrom) {
        const fromTimestamp = Math.floor(filters.dateFrom.getTime() / 1000);
        results = results.filter(note => note.created_at >= fromTimestamp);
    }
    
    if (filters.dateTo) {
        const toTimestamp = Math.floor(filters.dateTo.getTime() / 1000);
        results = results.filter(note => note.created_at <= toTimestamp);
    }
    
    // Rest of your existing filter logic...
    if (filters.contentType === 'original') {
        results = results.filter(note => !note.isReply);
    } else if (filters.contentType === 'replies') {
        results = results.filter(note => note.isReply);
    }
    
    if (filters.minLength) {
        results = results.filter(note => note.content.length >= filters.minLength);
    }
    
    if (filters.maxLength) {
        results = results.filter(note => note.content.length <= filters.maxLength);
    }
    
    if (filters.hasImages) {
        const imageRegex = /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp))/gi;
        results = results.filter(note => imageRegex.test(note.content));
    }
    
    if (filters.hasYouTube) {
        const youtubeRegex = /(youtube\.com\/watch\?v=|youtu\.be\/)/gi;
        results = results.filter(note => youtubeRegex.test(note.content));
    }
    
    if (query && query.trim()) {
        const searchTerms = query.toLowerCase().split(/\s+/);
        results = results.filter(note => {
            const searchText = (note.content + ' ' + (note.hashtags || []).join(' ')).toLowerCase();
            return searchTerms.every(term => searchText.includes(term));
        });
    }
    
    return results;
}


// Track active quick filters
let activeQuickFilters = new Set();

function toggleQuickFilter(type) {
    console.log('toggleQuickFilter called:', type);
    console.log('currentArchive before:', currentArchive);
    console.log('activeQuickFilters before:', Array.from(activeQuickFilters));
    
    const button = document.querySelector(`[data-filter="${type}"]`);
    
    if (activeQuickFilters.has(type)) {
        // Remove filter
        activeQuickFilters.delete(type);
        button.classList.remove('active');
    } else {
        // Add filter
        activeQuickFilters.add(type);
        button.classList.add('active');
    }
    
    console.log('activeQuickFilters after toggle:', Array.from(activeQuickFilters));
    
    // ALWAYS clear archive selection when ANY quick filter operation happens
    // This ensures that turning filters on OR off exits archive mode
    currentArchive = 'default';
    currentTag = '';
    selectedTags.clear();
    
    // Clear archive active states
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Clear tag filter active states
    document.querySelectorAll('.tag-filter').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Set "All Notes" as active
    document.querySelector('.tag-filter[data-tag=""]').classList.add('active');
    
    console.log('currentArchive after:', currentArchive);
    applyAllFilters();
}

async function applyAllFilters() {
    const query = document.getElementById('search-input').value;
    const filters = {};
    
    // Process quick filters - find the EARLIEST date from all active filters
    let earliestDate = null;
    
    activeQuickFilters.forEach(filterType => {
        const now = new Date();
        
        switch(filterType) {
            case 'week':
                const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                if (!earliestDate || weekAgo < earliestDate) {
                    earliestDate = weekAgo;
                }
                break;
                
            case 'month':
                const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                if (!earliestDate || monthAgo < earliestDate) {
                    earliestDate = monthAgo;
                }
                break;
                
            case 'year':
                const yearAgo = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
                if (!earliestDate || yearAgo < earliestDate) {
                    earliestDate = yearAgo;
                }
                break;
                
            case 'images':
                filters.hasImages = true;
                break;
                
            case 'youtube':
                filters.hasYouTube = true;
                break;
                
            case 'long':
                filters.minLength = 500;
                break;
        }
    });
    
    // Set the earliest date if any date filters are active
    if (earliestDate) {
        filters.dateFrom = earliestDate;
    }
    
    // Manual date range filters - these OVERRIDE quick filters if set
    const dateFromValue = document.getElementById('date-from').value;
    const dateToValue = document.getElementById('date-to').value;
    
    if (dateFromValue) {
        // Create date at start of day
        const fromDate = new Date(dateFromValue + 'T00:00:00');
        filters.dateFrom = fromDate;
    }
    
    if (dateToValue) {
        // Create date at end of day
        const toDate = new Date(dateToValue + 'T23:59:59');
        filters.dateTo = toDate;
    }
    
    performSearchWithFilters(query, filters);
}

function clearAllFilters() {
    // Clear quick filters
    activeQuickFilters.clear();
    document.querySelectorAll('.quick-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Clear hashtag filters - but keep tag filter buttons
    document.querySelectorAll('.tag-filter').forEach(btn => {
        const tag = btn.dataset.tag;
        // Only clear hashtag buttons, not the main tag filter buttons
        if (tag && tag.startsWith('#')) {
            btn.classList.remove('active');
        }
    });
    
    // Clear date filters
    document.getElementById('date-from').value = '';
    document.getElementById('date-to').value = '';
    
    // Clear search
    document.getElementById('search-input').value = '';
    
    // Reset tag selections and archive states
    selectedTags.clear();
    currentTag = '';
    selectedTags.clear();
    currentArchive = 'default';
    
    // Clear archive active states
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // IMPORTANT: Reset to show all notes and activate "All Notes" button
    searchQuery = '';
    filteredNotes = allNotes.slice(); // Reset filtered notes to all notes
    
    // Manually set "All Notes" as active
    document.querySelectorAll('.tag-filter').forEach(btn => {
        if (btn.dataset.tag === '') {
            btn.classList.add('active');
        } else if (btn.dataset.tag === '__original' || btn.dataset.tag === '__replies') {
            btn.classList.remove('active');
        }
    });
    
    // Update display
    renderNotes();
    
    // Reset title and count
    document.getElementById('notes-title').textContent = 'All Notes';
    document.getElementById('notes-count').textContent = `${allNotes.length} notes`;
}

async function performSearchWithFilters(query, filters) {
    const results = await performAdvancedSearch(query, filters);
    
    // Override normal filtering with search results
    filteredNotes = results;
    searchQuery = query;
    
    renderNotes();
    
    // UPDATE: Fix the title and count display
    const title = document.getElementById('notes-title');
    const count = document.getElementById('notes-count');
    
    // Build filter description - include BOTH quick filters AND search terms
    const activeFilters = [];
    
    // Add quick filters
    if (activeQuickFilters.has('week')) activeFilters.push('This Week');
    if (activeQuickFilters.has('month')) activeFilters.push('This Month');
    if (activeQuickFilters.has('year')) activeFilters.push('This Year');
    if (activeQuickFilters.has('images')) activeFilters.push('Images');
    if (activeQuickFilters.has('youtube')) activeFilters.push('Videos');
    if (activeQuickFilters.has('long')) activeFilters.push('Long');
    
    // Add search terms/hashtags
    if (query && query.trim()) {
        const searchTerms = query.trim().split(/\s+/);
        searchTerms.forEach(term => {
            if (term.startsWith('#')) {
                activeFilters.push(term); // Show hashtags as-is
            } else {
                activeFilters.push(`"${term}"`); // Show search terms in quotes
            }
        });
    }
    
    // Manual date filters (only show if no quick date filters)
    if (filters.dateFrom && !activeQuickFilters.has('week') && !activeQuickFilters.has('month') && !activeQuickFilters.has('year')) {
        activeFilters.push('Date Filtered');
    }
    
    // Set the title based on what's active
    if (activeFilters.length > 0) {
        title.textContent = `Filtered Notes (${activeFilters.join(' + ')})`;
    } else {
        title.textContent = 'All Notes';
    }
    
    count.textContent = `${results.length} notes`;
    
    // Show search results info
    const filterInfo = [];
    if (filters.dateFrom) filterInfo.push(`from ${filters.dateFrom.toLocaleDateString()}`);
    if (filters.dateTo) filterInfo.push(`to ${filters.dateTo.toLocaleDateString()}`);
    if (filters.contentType) filterInfo.push(filters.contentType);
    if (filters.hasImages) filterInfo.push('with images');
    if (filters.hasYouTube) filterInfo.push('with videos');
    if (filters.minLength) filterInfo.push(`min ${filters.minLength} chars`);
    
    const filterText = filterInfo.length > 0 ? ` (${filterInfo.join(', ')})` : '';
    showToast(`Found ${results.length} notes${filterText}`, 'success');
}




// Make functions globally available
window.toggleQuickFilter = toggleQuickFilter;
window.applyDateFilters = applyDateFilters;
window.clearAllFilters = clearAllFilters;


// Add global event listeners for hashtag selection
document.addEventListener('mouseup', endHashtagSelection);
document.addEventListener('mouseleave', endHashtagSelection);


// Make functions globally available for onclick handlers
// Core functionality
window.filterByTag = filterByTag;
window.toggleArchiveNote = toggleArchiveNote;
window.viewArchive = viewArchive;
window.deleteArchive = deleteArchive;
window.toggleNoteSelection = toggleNoteSelection;

// UI and modals
window.showNoteInfo = showNoteInfo;
window.selectArchiveOption = selectArchiveOption;
window.closeArchiveModal = closeArchiveModal;

// Archive management
window.removeFromSpecificArchive = removeFromSpecificArchive;

// Media loading
window.loadYouTubeThumbnail = loadYouTubeThumbnail;
window.loadImage = loadImage;
window.closeImage = closeImage;
window.closeYouTube = closeYouTube;

// Utilities
window.copyToClipboard = copyToClipboard;
window.clearAllCache = clearAllCache;
window.showToast = showToast;

// Make hashtag selection functions globally available
window.startHashtagSelection = startHashtagSelection;
window.continueHashtagSelection = continueHashtagSelection;
window.endHashtagSelection = endHashtagSelection;

          // Theme functionality - add this at the very end of your JavaScript
setTimeout(function() {
    const themeSelector = document.getElementById('theme-selector');
    // Load saved theme on startup
const savedTheme = localStorage.getItem('nostr-theme') || 'default';
if (savedTheme !== 'default') {
    document.body.setAttribute('data-theme', savedTheme);
    themeSelector.value = savedTheme;
}
    if (themeSelector) {
       themeSelector.addEventListener('change', function(e) {
    document.body.setAttribute('data-theme', e.target.value);
    localStorage.setItem('nostr-theme', e.target.value);
});
    }
}, 1000);

// One-time cleanup of old global archives - remove after running once
if (!localStorage.getItem('archives-cleanup-done')) {
    localStorage.removeItem('nostr-archived-notes');
    localStorage.removeItem('nostr-named-archives');
    localStorage.setItem('archives-cleanup-done', 'true');
}

    </script>
</body>
</html>