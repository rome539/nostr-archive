<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.4/dexie.min.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Nostr Notes Archive</title>
    
    <!-- Favicons -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' rx='6' fill='%233498db'/><path d='M 10 6 L 20 6 L 24 10 L 24 26 L 10 26 Z' fill='white' stroke='white' stroke-width='0.5'/><path d='M 20 6 L 20 10 L 24 10' fill='%23e8f4f8' stroke='white' stroke-width='0.5'/><path d='M 18 12 L 14 18 L 16.5 18 L 15 22 L 19 16 L 16.5 16 Z' fill='%23f39c12' stroke='%23e67e22' stroke-width='0.5' stroke-linejoin='round'/></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' rx='6' fill='%233498db'/><path d='M 10 6 L 20 6 L 24 10 L 24 26 L 10 26 Z' fill='white' stroke='white' stroke-width='0.5'/><path d='M 20 6 L 20 10 L 24 10' fill='%23e8f4f8' stroke='white' stroke-width='0.5'/><path d='M 18 12 L 14 18 L 16.5 18 L 15 22 L 19 16 L 16.5 16 Z' fill='%23f39c12' stroke='%23e67e22' stroke-width='0.5' stroke-linejoin='round'/></svg>">
    
   <script type="module">
  import * as NostrTools from 'https://cdn.jsdelivr.net/npm/nostr-tools@2.7.1/+esm';
  window.NostrTools = NostrTools;
</script>
    <style>
        /* CSS Variables for Theme Colors */
:root {
    /* Default Theme */
    --primary-color: #3498db;
    --primary-hover: #2980b9;
    --secondary-color: #7fb3d3;  /* ADD THIS */
    --success-color: #27ae60;
    --danger-color: #e74c3c;
    --purple-color: #9b59b6;
    --background-color: #f5f5f5;
    --card-background: white;
    --text-color: #333;
    --text-muted: #666;
    --border-color: #ddd;
}

/* Nostr Purple – stronger + primary=purple */
[data-theme="nostr-purple"] {
  --primary-color: #6b4eff;
  --primary-hover: #5a3ff0;

  --secondary-color: #8b7df0;
  --secondary-hover: #7a6be6;

  --success-color: #16a34a;
  --danger-color: #dc2626;

  --purple-color: #6b4eff;

  --background-color: #f7f6fc;
  --card-background: #ffffff;

  --text-color: #1f1b3a;
  --text-muted: #6b6a85;

  --border-color: #e4e2f3;
}


/* INTENSE Dark Nostr */
[data-theme="dark-nostr"] {
  --primary-color: #8a7cff;
  --primary-hover: #7668f0;

  --secondary-color: #a29af0;
  --secondary-hover: #b4adff;

  --success-color: #22c55e;
  --danger-color: #ef4444;

  --purple-color: #9a92ff;

  --background-color: #0d1020;
  --card-background: #161a33;

  --text-color: #e6e9f2;
  --text-muted: #9aa0c2;

  --border-color: #2b305a;
}

/* Dark theme input fixes - higher specificity */
[data-theme="dark-nostr"] #search-input::placeholder,
[data-theme="dark-nostr"] #keyword-input::placeholder,
[data-theme="dark-nostr"] #new-archive-name::placeholder {
    color: #cbd5e1 !important;
}

[data-theme="dark-nostr"] #search-input,
[data-theme="dark-nostr"] #keyword-input,
[data-theme="dark-nostr"] #new-archive-name {
    border-color: #64748b;
    color: #e2e8f0;
}

/* INTENSE Bitcoin Gold */
[data-theme="bitcoin-gold"] {
  --primary-color: #f7931a;      /* official Bitcoin orange */
  --primary-hover: #c76a00;      /* deeper hover shade */
  --secondary-color: #6b4e16;    /* coin bronze */
  --secondary-hover: #4a3410;
  --success-color: #2e8b57;      /* strong green */
  --danger-color: #b22222;       /* vivid red */
  --purple-color: #9b59b6;       /* royal purple accent */
  --background-color: #1a1208;   /* dark brown/black backdrop */
  --card-background: #2b1b0b;    /* warm dark card tone */
  --text-color: #fef3c7;         /* pale gold text */
  --text-muted: #d97706;         /* amber-muted for secondary text */
  --border-color: rgba(247, 147, 26, 0.5); /* semi-transparent Bitcoin orange */
}

/* neon-green Neon Green Theme - Toned Down Version */
[data-theme="neon-green"] {
  --primary-color: #00cc00;        /* Slightly darker green */
  --primary-hover: #00ff00;        /* Bright on hover */
  --secondary-color: #00cc00;
  --secondary-hover: #00ff00;
  --success-color: #00cc00;
  --danger-color: #ff3333;
  --purple-color: #00cc00;
  --background-color: #000000;
  --card-background: #0a0a0a;
  --text-color: #00cc00;           /* Slightly darker text */
  --text-muted: #009900;           /* More muted */
  --border-color: #008800;         /* Darker borders */

  /* Soft tokens for toned surfaces */
  --accent: #00cc00;               /* Base green is now darker */
  --accent-border: #008800;
  --accent-weak: color-mix(in srgb, var(--accent) 18%, #000);
  --accent-weak-2: color-mix(in srgb, var(--accent) 10%, #000);
}

/* Hide emojis for neon-green theme only - MORE SPECIFIC */
[data-theme="neon-green"] .emoji,
[data-theme="neon-green"] button .emoji,
[data-theme="neon-green"] .tag-filter .emoji {
    display: none !important;
}

/* But keep them visible in other themes */
.emoji {
    display: inline !important;
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

     body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--background-color);
    color: var(--text-color);
    line-height: 1.6;
    font-size: 15px;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

     .header h1 {
    font-size: 2.8em;
    margin-bottom: 15px;
    color: var(--primary-color);
    font-weight: 600;
    letter-spacing: -0.02em;
}

        .connection-box {
    background: var(--card-background);
    padding: 40px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    max-width: 500px;
    margin: 0 auto;
}

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }

      .form-group input {
    width: 100%;
    padding: 12px;
    border: 2px solid var(--border-color);
    border-radius: 5px;
    font-size: 14px;
    font-family: monospace;
    background: var(--card-background);
    color: var(--text-color);
}

.form-group input:focus {
    border-color: var(--primary-color);
    outline: none;
}

/* Placeholder text styling for all themes */
input::placeholder {
    color: var(--text-muted);
    opacity: 0.6;
}

input::-webkit-input-placeholder {
    color: var(--text-muted);
    opacity: 0.6;
}

input::-moz-placeholder {
    color: var(--text-muted);
    opacity: 0.6;
}

input:-ms-input-placeholder {
    color: var(--text-muted);
    opacity: 0.6;
}

   /* Loading and transition improvements */
.btn {
    background: var(--primary-color);
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 15px;
    font-weight: 500;
    width: 100%;
    margin-bottom: 12px;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
}

.btn.loading::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
    0% { left: -100%; }
    100% { left: 100%; }
}

.fade-in {
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.slide-up {
    animation: slideUp 0.2s ease-out;
}

/* Toast notifications */
.toast {
    position: fixed;
    top: 20px;
    right: 20px;
    background: color-mix(in srgb, var(--primary-color) 20%, var(--card-background));
    color: var(--primary-color);
    padding: 16px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border: 1px solid color-mix(in srgb, var(--primary-color) 40%, var(--card-background));
    border-left: 4px solid var(--primary-color);
    z-index: 1001;
    transform: translateX(400px);
    transition: transform 0.3s ease;
    font-weight: 500;
}

.toast.show {
    transform: translateX(0);
}

.toast.success {
    background: color-mix(in srgb, var(--primary-color) 20%, var(--card-background));
    color: var(--primary-color);
    border-color: color-mix(in srgb, var(--primary-color) 40%, var(--card-background));
    border-left-color: var(--primary-color);
}

.toast.error {
    background: color-mix(in srgb, var(--danger-color) 20%, var(--card-background));
    color: var(--danger-color);
    border-color: color-mix(in srgb, var(--danger-color) 40%, var(--card-background));
    border-left-color: var(--danger-color);
}

.toast.warning {
    background: color-mix(in srgb, var(--primary-color) 20%, var(--card-background));
    color: var(--primary-color);
    border-color: color-mix(in srgb, var(--primary-color) 40%, var(--card-background));
    border-left-color: var(--primary-color);
}

@keyframes slideUp {
    from { transform: translateY(5px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

/* Only apply hover effects on devices with actual hover capability */
@media (hover: hover) {
    .btn:hover {
        background: var(--primary-hover);
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
}

        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

/* Top header with action buttons */
.top-header {
    background: var(--card-background);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 20px 24px;
    margin-bottom: 24px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.header-content {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 16px;
}

.header-left h2 {
    margin: 0 0 6px 0;
    font-size: 1.5em;
    font-weight: 600;
    color: var(--text-color);
}

.npub-display {
    color: var(--text-muted);
    font-family: monospace;
    font-size: 12px;
    display: block;
}

.header-actions {
    display: flex;
    gap: 10px;
    flex-shrink: 0;
}

.btn-action {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 10px 16px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
}

.btn-action .emoji {
    font-size: 16px;
}

.btn-action-primary {
    background: var(--primary-color);
    color: white;
    box-shadow: 0 2px 4px rgba(52, 152, 219, 0.2);
}

.btn-action-secondary {
    background: var(--background-color);
    color: var(--text-muted);
    border: 1px solid var(--border-color);
}

/* Hover effects only for desktop */
@media (hover: hover) {
    .btn-action-primary:hover {
        background: var(--primary-hover);
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
    }
    
    .btn-action-secondary:hover {
        background: var(--border-color);
        color: var(--text-color);
    }
}

/* Active states for mobile */
@media (hover: none) {
    .btn-action:active {
        transform: scale(0.97);
    }
}

        .btn-small {
    padding: 8px 14px;
    font-size: 13px;
    width: auto;
    margin: 0 4px;
    font-weight: 500;
}

.btn-secondary {
    background: var(--text-muted);
    color: white;
}

.btn-secondary:hover {
    background: var(--text-color);
}



        .btn-tiny {
            padding: 2px 6px;
            font-size: 11px;
            min-width: auto;
            width: auto;
            margin: 0;
        }

 /* Better delete button styling for all themes */
.btn-delete {
    background: var(--danger-color) !important;
    color: white !important;
    border: none !important;
    width: 28px !important;
    height: 28px !important;
    border-radius: 50% !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    font-size: 16px !important;
    font-weight: bold !important;
    line-height: 1 !important;
}

/* Neon-green delete button */
[data-theme="neon-green"] .btn-delete {
    background: var(--accent) !important;
    color: #000 !important;
    box-shadow: 0 0 6px rgba(0, 255, 0, 0.4) !important;
}

        .btn-delete:hover {
            background: #c0392b;
        }

        .error {
            background: #e74c3c;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            display: none;
        }

        .success {
            background: #27ae60;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.btn:focus {
    outline: none;
    border: 2px solid var(--primary-color);
}

.btn-small:hover {
    transform: translateY(-1px);
}

.btn-small:active {
    transform: translateY(0);
}

.quick-filter-btn.active {
    background: var(--primary-color) !important;
    color: white !important;
    box-shadow: 0 4px 12px rgba(52, 152, 219, 0.5) !important;
    font-weight: 600 !important;
    border: 2px solid var(--primary-color) !important;
    transform: scale(1.02) !important;
}

/* Remove raise effect on mobile */
@media (max-width: 768px) {
    .quick-filter-btn.active {
        transform: scale(1.0) !important;
        box-shadow: 0 3px 10px rgba(52, 152, 219, 0.6) !important;
    }
}

/* Theme-specific active states */
[data-theme="dark-nostr"] .quick-filter-btn.active {
    background: var(--primary-color) !important;
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.6) !important;
    border: 2px solid var(--primary-color) !important;
    font-weight: 600 !important;
}

[data-theme="bitcoin-gold"] .quick-filter-btn.active {
    background: var(--primary-color) !important;
    box-shadow: 0 4px 12px rgba(247, 147, 26, 0.6) !important;
    border: 2px solid var(--primary-color) !important;
    font-weight: 600 !important;
}

[data-theme="nostr-purple"] .quick-filter-btn.active {
    background: var(--primary-color) !important;
    box-shadow: 0 4px 12px rgba(124, 58, 237, 0.6) !important;
    border: 2px solid var(--primary-color) !important;
    font-weight: 600 !important;
}

[data-theme="neon-green"] .quick-filter-btn.active {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    box-shadow: 0 0 16px rgba(0, 255, 0, 0.8) !important;
    border: 2px solid var(--accent) !important;
    font-weight: 600 !important;
    text-shadow: 0 0 4px var(--accent) !important;
}

/* Theme-specific focus styles for quick filter buttons - no glow */
[data-theme="dark-nostr"] .quick-filter-btn:focus {
    border: 2px solid var(--primary-color) !important;
    background: color-mix(in srgb, var(--primary-color) 10%, var(--card-background)) !important;
}

[data-theme="bitcoin-gold"] .quick-filter-btn:focus {
    border: 2px solid var(--primary-color) !important;
    background: color-mix(in srgb, var(--primary-color) 10%, var(--card-background)) !important;
}

[data-theme="nostr-purple"] .quick-filter-btn:focus {
    border: 2px solid var(--primary-color) !important;
    background: color-mix(in srgb, var(--primary-color) 10%, var(--card-background)) !important;
}

[data-theme="neon-green"] .quick-filter-btn:focus {
    border: 2px solid var(--accent) !important;
    background: var(--accent-weak-2) !important;
}

/* Clear All Filters button - mobile tap feedback */
.clear-filters-btn:active {
    background: #7f8c8d !important;
    transform: scale(0.95) !important;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.2) !important;
}
        
        /* Fix layout so tabs (Original Notes / Replies) don’t overflow */
.app-layout {
  display: grid;
  grid-template-columns: 300px 1fr;
  gap: 20px;
  margin-top: 20px;
}


      .sidebar h4 {
    font-size: 14px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
    margin: 25px 0 12px 0;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}

.sidebar h4:first-of-type {
    margin-top: 0;
}

.sidebar {
    background: var(--card-background);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    height: fit-content;
}

.sidebar-section {
    margin-bottom: 32px;
    padding-bottom: 24px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
}

.sidebar-section:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

.main-content {
    background: var(--card-background);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.note-card {
    position: relative;
    background: var(--card-background);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 16px;
    padding-bottom: 50px; /* Space for the engagement box */
    margin-bottom: 16px;
    transition: box-shadow 0.2s ease;
}

.reactions-box {
    position: absolute;
    bottom: 12px;
    right: 12px;
    display: inline-block;
    padding: 6px 12px;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 12px;
    color: var(--text-muted);
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 120px;
    max-width: 150px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.reactions-box.loading {
    color: var(--primary-color);
    font-style: italic;
}

.reactions-box:hover {
    border-color: var(--primary-color);
    color: var(--primary-color);
}

.reactions-popup {
    position: absolute;
    bottom: 65px; /* Position it above the engagement box (50px padding-bottom + 12px box height + some gap) */
    right: 12px;
    background: var(--card-background);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
    min-width: 200px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 1000;
    display: none;
}

.reactions-popup.show {
    display: block;
    animation: slideUpFade 0.2s ease;
}

@keyframes slideUpFade {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.reactions-popup-header {
    font-weight: 600;
    margin-bottom: 8px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
    color: var(--text-color);
    font-size: 13px;
}

.reaction-item {
    padding: 6px 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: var(--text-color);
    font-size: 13px;
}

.reaction-emoji {
    font-size: 16px;
    margin-right: 8px;
}

.reaction-count {
    font-weight: 500;
    color: var(--text-muted);
}

.no-reactions {
    color: var(--text-muted);
    font-style: italic;
    font-size: 12px;
    padding: 8px 0;
}

.note-card:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 16px rgba(0,0,0,0.12);
}

/* High specificity rules to override everything */
.note-card.reply-card:not(.archived) {
    border-left: 4px solid var(--purple-color) !important;
}

.note-card:not(.reply-card):not(.archived) {
    border-left: 4px solid var(--primary-color) !important;
}

.note-card.archived {
    border-left: 4px solid var(--success-color) !important;
}

     .note-header {
    font-size: 12px;
    color: var(--text-muted);
    margin-bottom: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

        .note-actions {
            display: flex;
            gap: 5px;
        }

     .note-content {
    white-space: pre-wrap;
    line-height: 1.6;
    margin-bottom: 16px;
    font-size: 14px;
    color: var(--text-color);
}

        .hashtags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 10px;
        }

/* Hashtag pills — follow current theme */
/* Unified hashtag styling - follows primary theme color */
.hashtag {
  background: color-mix(in srgb, var(--primary-color) 18%, var(--card-background)) !important;
  border: 1px solid color-mix(in srgb, var(--primary-color) 40%, var(--card-background)) !important;
  color: var(--primary-color) !important;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.15s ease;
  user-select: none;
}

/* Hashtag hover effects - only on devices with actual hover capability */
@media (hover: hover) {
    .hashtag:hover {
      background: color-mix(in srgb, var(--primary-color) 32%, var(--card-background)) !important;
      border-color: var(--primary-hover) !important;
      color: #fff !important;
      transform: translateY(-1px);
    }
    
    .note-card.reply-card .hashtag:hover,
    .note-card.archived .hashtag:hover {
      background: color-mix(in srgb, var(--primary-color) 32%, var(--card-background)) !important;
      border-color: var(--primary-hover) !important;
      color: #fff !important;
    }
    
    .note-card.archived .hashtag:hover {
      background: color-mix(in srgb, var(--success-color) 32%, var(--card-background));
      border-color: var(--success-color);
      color: #fff;
    }
}

/* Remove ALL the old reply/archived specific rules */
.note-card.reply-card .hashtag,
.note-card.archived .hashtag {
  background: color-mix(in srgb, var(--primary-color) 18%, var(--card-background)) !important;
  border-color: color-mix(in srgb, var(--primary-color) 40%, var(--card-background)) !important;
  color: var(--primary-color) !important;
}

/* Hashtags in archived cards = success theme */
.note-card.archived .hashtag {
  background: color-mix(in srgb, var(--success-color) 18%, var(--card-background));
  border-color: color-mix(in srgb, var(--success-color) 40%, var(--card-background));
  color: var(--success-color);
}

       .tag-filter {
    display: block;
    width: 100%;
    padding: 8px;
    margin-bottom: 5px;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    text-align: left;
    color: var(--text-color);
}


.tag-filter.active {
    background: var(--primary-color);
    color: white;
}

/* Only apply hover on devices with actual hover capability */
@media (hover: hover) {
    .tag-filter:hover {
      background: color-mix(in srgb, var(--primary-color) 24%, #fff);
      border-color: var(--primary-color);
    }
}

/* Active state */
.tag-filter.active {
  background: var(--primary-color);
  border-color: var(--primary-color);
  color: #fff;
}

/* Special pills that match your theme variables */
.tag-filter[data-tag="__original"] {
  background: var(--primary-color);
  border-color: var(--primary-color);
  color: #fff;
}
.tag-filter[data-tag="__replies"] {
  background: var(--purple-color);
  border-color: var(--purple-color);
  color: #fff;
}
.tag-filter[data-tag="__replies"].active {
  background: var(--purple-color);
}
.tag-filter[data-tag="__archived"],
.tag-filter[data-tag^="__archive_"] {
  background: var(--success-color);
  border-color: var(--success-color);
  color: #fff;
}


 .archive-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    margin-bottom: 8px;
    background: var(--background-color);
    border-radius: 8px;
    border: 1px solid var(--border-color);
    transition: all 0.2s ease;
}

.archive-item:hover:not(.active) {
    background: var(--card-background);
    border-color: var(--primary-color);
}

.archive-item.active {
    background: var(--success-color);
    border-color: var(--success-color);
    color: white;
}

.archive-name {
    cursor: pointer;
    flex: 1;
    font-size: 14px;
}

.archive-count {
    font-size: 12px;
    color: var(--text-muted);
    margin-right: 8px;
}

        .archive-actions {
            display: flex;
            gap: 5px;
        }

      .loading {
    text-align: center;
    padding: 50px;
    color: var(--text-muted);
}

        .hidden { display: none;
        }

    .search-box {
    width: 100%;
    padding: 12px 16px;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 18px;
    background: var(--card-background);
    color: var(--text-color);
    font-size: 14px;
    transition: border-color 0.2s ease;
}

.search-box:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

       .keyword-input {
    width: 100%;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    margin-bottom: 10px;
    font-size: 14px;
    background: var(--card-background);
    color: var(--text-color);
}

        .info-box {
    background: var(--background-color);
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    font-size: 13px;
    border-left: 3px solid var(--primary-color);
}

       .progress-bar {
  width: 100%;
  height: 20px;
  background: color-mix(in srgb, var(--primary-color) 12%, #ecf0f1);
  border: 1px solid color-mix(in srgb, var(--primary-color) 35%, #ecf0f1);
  border-radius: 10px;
  overflow: hidden;
  margin: 10px 0;
}

.progress-fill {
  height: 100%;
  background: var(--primary-color);             /* follows theme */
  transition: width 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 12px;
}

.archive-options {
    margin: 20px 0;
}

.archive-option {
    padding: 12px 16px;
    margin: 8px 0;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.archive-option:hover {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

/* neon-green archive options */
[data-theme="neon-green"] .archive-option {
    background: var(--accent-weak-2) !important;
    border-color: var(--accent-border) !important;
    color: var(--accent) !important;
}

[data-theme="neon-green"] .archive-option:hover {
    background: var(--accent-weak) !important;
    border-color: var(--accent) !important;
}

        .note-checkbox {
            margin-right: 10px;
            transform: scale(1.2);
        }

       .bulk-controls {
    background: var(--background-color);
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    border: 1px solid var(--border-color);
}

        .bulk-controls.hidden {
            display: none;
        }

    .status-info {
    font-size: 12px;
    color: var(--text-muted);
    margin: 5px 0;
}

/* Prevent sideways scroll caused by long strings */
#pubkey-display,
.note-content,
.note-header,
.archive-name {
  overflow-wrap: anywhere;   /* allow breaks anywhere */
  word-break: break-word;    /* fallback */
  max-width: 100%;
}

/* Keep panels from exceeding container width */
.sidebar,
.main-content {
  max-width: 100%;
}

.archive-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    margin-bottom: 8px;
    background: var(--background-color);
    border-radius: 8px;
    border: 1px solid var(--border-color);
    transition: all 0.2s ease;
    cursor: pointer;
    position: relative;
}

.archive-name {
    flex: 1;
    font-size: 14px;
    pointer-events: none;
}

.archive-count {
    font-size: 12px;
    color: var(--text-muted);
    margin-right: 8px;
    pointer-events: none;
}

.archive-actions {
    display: flex;
    gap: 5px;
    z-index: 10;
}

.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(4px);
    animation: fadeIn 0.2s ease;
}

.modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    padding: 32px;
    border-radius: 12px;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    border: 1px solid var(--border-color);
    transform: scale(0.9);
    animation: modalSlideIn 0.2s ease forwards;
}

@keyframes modalSlideIn {
    to {
        transform: scale(1);
    }
}

.modal-close {
    float: right;
    background: var(--primary-color) !important;
    color: white !important;
    border: none !important;
    padding: 10px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s ease;
}

.modal-close:hover {
    background: var(--primary-hover) !important;
    transform: translateY(-1px);
}

/* Stack on small screens */
@media (max-width: 768px) {
  .app-layout {
    grid-template-columns: 1fr;
  }
}
/* Consistent spacing system */
.mb-1 { margin-bottom: 8px; }
.mb-2 { margin-bottom: 16px; }
.mb-3 { margin-bottom: 24px; }
.mb-4 { margin-bottom: 32px; }

.mt-1 { margin-top: 8px; }
.mt-2 { margin-top: 16px; }
.mt-3 { margin-top: 24px; }
.mt-4 { margin-top: 32px; }

kbd {
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 3px;
    padding: 1px 4px;
    font-size: 11px;
    font-family: monospace;
    color: var(--text-color);
}

.copy-btn {
  border: none;
  padding: 4px 8px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.2s ease;
}

/* Default theme */
.copy-btn {
  background: var(--primary-color);
  color: white;
  border: 1px solid var(--primary-color);
}

.copy-btn:hover {
  background: var(--primary-hover);
  transform: translateY(-1px);
}

/* Dark themes */
[data-theme="dark-nostr"] .copy-btn,
[data-theme="bitcoin-gold"] .copy-btn {
  background: var(--primary-color);
  color: white;
  border: 1px solid var(--primary-color);
}

[data-theme="dark-nostr"] .copy-btn:hover,
[data-theme="bitcoin-gold"] .copy-btn:hover {
  background: var(--primary-hover);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

/* Nostr Purple theme */
[data-theme="nostr-purple"] .copy-btn {
  background: var(--primary-color);
  color: white;
  border: 1px solid var(--primary-color);
}

[data-theme="nostr-purple"] .copy-btn:hover {
  background: var(--primary-hover);
}

/* Neon Green theme */
[data-theme="neon-green"] .copy-btn {
  background: var(--accent-weak-2) !important;
  border: 1px solid var(--accent-border) !important;
  color: var(--accent) !important;
  text-shadow: 0 0 3px var(--accent);
}

[data-theme="neon-green"] .copy-btn:hover {
  background: var(--accent-weak) !important;
  box-shadow: 0 0 6px rgba(0,255,0,0.4) !important;
}

/* Stack Import button + hint with tight spacing */
.import-archive-block {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0 !important;                 /* kill any flex gap */
  margin-bottom: 14px;
}

/* ensure the button above doesn't add extra space */
.import-archive-block > .btn {
  margin: 0 !important;              /* some .btn styles add margin-bottom */
}

/* pull the hint closer to the button */
.import-hint {
  color: var(--text-muted);
  font-size: 11px;
  text-align: center;
  margin-top: 4px !important;        /* force a small, tight gap */
  line-height: 1.15;                 /* compact line height */
}

/* if any generic rule targets .sidebar-section .btn + small, override it */
.sidebar-section .btn + .import-hint {
  margin-top: 4px !important;
}

/* Lazy loading styles */
.note-image {
    max-width: 100%;
    height: auto;
    margin: 10px 0;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: transform 0.2s ease;
}

.note-image:hover {
    transform: scale(1.02);
}

/* Load More button theming */
#load-more-btn {
    background: var(--primary-color) !important;
    color: white !important;
    border: 1px solid var(--primary-color) !important;
}

#load-more-btn:hover {
    background: var(--primary-hover) !important;
    transform: translateY(-1px);
}

/* Neon Green Load More button */
[data-theme="neon-green"] #load-more-btn {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    text-shadow: 0 0 2px var(--accent) !important;  /* Reduced from 4px to 2px */
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #load-more-btn:hover {
    background: color-mix(in srgb, var(--accent) 28%, #000) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

.youtube-thumbnail {
    position: relative;
    display: inline-block;
    margin: 10px 0;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    cursor: pointer;
    transition: transform 0.2s ease;
}

.youtube-thumbnail:hover {
    transform: scale(1.02);
}

.youtube-thumbnail img {
    width: 320px;
    height: 180px;
    object-fit: cover;
    display: block;
}

.youtube-thumbnail .play-button {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8);
    color: white;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
}

.youtube-thumbnail .play-button::before {
    content: "▶";
    margin-left: 3px;
}

[data-theme="dark-nostr"] .modal {
    background: rgba(0, 0, 0, 0.8) !important;
}

[data-theme="dark-nostr"] .modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="dark-nostr"] .modal-close {
    background: var(--primary-color) !important;
    color: white !important;
}

[data-theme="dark-nostr"] .modal-close:hover {
    background: var(--primary-hover) !important;
}

[data-theme="bitcoin-gold"] .modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="bitcoin-gold"] .modal-close {
    background: var(--primary-color) !important;
    color: white !important;
}

[data-theme="bitcoin-gold"] .modal-close:hover {
    background: var(--primary-hover) !important;
}

[data-theme="nostr-purple"] .modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="nostr-purple"] .modal-close {
    background: var(--primary-color) !important;
    color: white !important;
}

[data-theme="nostr-purple"] .modal-close:hover {
    background: var(--primary-hover) !important;
}

/* Search input theming for all themes */
#search-input {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

#search-input::placeholder {
    color: var(--text-muted) !important;
}

#search-input:focus {
    border-color: var(--primary-color) !important;
    outline: none;
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
}

/* Remove blue highlight/focus state for npub button on ALL themes */
.npub-copy-btn {
    display: inline;
    background: var(--primary-color);
    color: white;
    border: none;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 11px;
    font-family: monospace;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 0 4px;
    outline: none !important;
    -webkit-tap-highlight-color: transparent !important;
}

.npub-copy-btn:hover {
    background: var(--primary-hover);
    transform: scale(1.05);
}

.npub-copy-btn:active {
    transform: scale(0.95);
    outline: none !important;
}

/* Checkbox styling for all themes */
.note-checkbox {
    appearance: none;
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    background: var(--card-background);
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
    margin-right: 10px;
}

.note-checkbox:hover {
    border-color: var(--primary-color);
}

.note-checkbox:checked {
    background: var(--primary-color);
    border-color: var(--primary-color);
}

.note-checkbox:checked::after {
    content: '✓';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 10px;
    font-weight: bold;
}

/* Hide scrollbar but keep scrolling functionality */
.thread-scroll {
    scrollbar-width: none !important; /* Firefox */
    -ms-overflow-style: none !important; /* IE and Edge */
}

.thread-scroll::-webkit-scrollbar {
    display: none !important; /* Chrome, Safari, Opera */
}

/* Make date a subtle copy button */
.date-copy-btn {
    cursor: pointer;
    transition: all 0.2s ease;
    padding: 2px 4px;
    border-radius: 4px;
}

.date-copy-btn:hover {
    background: color-mix(in srgb, var(--primary-color) 15%, transparent);
    color: var(--primary-color);
}

.date-copy-btn:active {
    transform: scale(0.98);
}

/* Theme-specific */
[data-theme="neon-green"] .date-copy-btn:hover {
    background: var(--accent-weak-2);
    color: var(--accent);
}

/* Neon Green theme checkboxes */
[data-theme="neon-green"] .note-checkbox {
    border-color: var(--accent-border);
    background: var(--accent-weak-2);
}

[data-theme="neon-green"] .note-checkbox:hover {
    border-color: var(--accent);
    box-shadow: 0 0 6px rgba(0, 255, 0, 0.3);
}

[data-theme="neon-green"] .note-checkbox:checked {
    background: var(--accent-weak);
    border-color: var(--accent);
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.4);
}

[data-theme="neon-green"] .note-checkbox:checked::after {
    color: var(--accent);
    text-shadow: 0 0 4px var(--accent);
}

/* Theme-specific npub button styles */
[data-theme="nostr-purple"] .npub-copy-btn {
    background: var(--purple-color);
    color: white;
    border: 1px solid var(--purple-color);
}

[data-theme="nostr-purple"] .npub-copy-btn:hover {
    background: color-mix(in srgb, var(--purple-color) 80%, #fff);
}

[data-theme="dark-nostr"] .npub-copy-btn {
    background: var(--primary-color);
    color: white;
}

[data-theme="dark-nostr"] .npub-copy-btn:hover {
    background: var(--primary-hover);
}

[data-theme="bitcoin-gold"] .npub-copy-btn {
    background: var(--primary-color);
    color: var(--card-background);
}

[data-theme="bitcoin-gold"] .npub-copy-btn:hover {
    background: var(--primary-hover);
}

[data-theme="neon-green"] .npub-copy-btn {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    font-weight: 600;
    text-shadow: 0 0 3px var(--accent) !important;
}

[data-theme="neon-green"] .npub-copy-btn:hover {
    background: var(--accent-weak) !important;
    border-color: var(--accent) !important;
}

/* Prevent button from staying in stuck state */
.npub-copy-btn:disabled {
    opacity: 0.7;
    cursor: not-allowed;
}


/* Dark themes search input fixes */
[data-theme="dark-nostr"] #search-input,
[data-theme="bitcoin-gold"] #search-input,
[data-theme="nostr-purple"] #search-input {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="dark-nostr"] #search-input::placeholder,
[data-theme="bitcoin-gold"] #search-input::placeholder,
[data-theme="nostr-purple"] #search-input::placeholder {
    color: var(--text-muted) !important;
}

/* Date input theming */
[data-theme="dark-nostr"] input[type="date"],
[data-theme="bitcoin-gold"] input[type="date"],
[data-theme="nostr-purple"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="neon-green"] input[type="date"] {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
}

/* More comprehensive date input theming */
input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    border-radius: 4px;
    padding: 6px 8px;
    font-size: 12px;
}

/* Theme-specific date input styling */
[data-theme="dark-nostr"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: dark; /* This helps with native controls */
}

[data-theme="bitcoin-gold"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: dark;
}

[data-theme="nostr-purple"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: dark;
}

[data-theme="neon-green"] input[type="date"] {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    color-scheme: dark;
}

/* Enhanced calendar picker indicator styling */
input[type="date"]::-webkit-calendar-picker-indicator {
    background: transparent;
    bottom: 0;
    cursor: pointer;
    height: auto;
    left: 0;
    position: absolute;
    right: 0;
    top: 0;
    width: auto;
    opacity: 0.8;
}

/* Theme-specific calendar indicators */
[data-theme="dark-nostr"] input[type="date"]::-webkit-calendar-picker-indicator,
[data-theme="bitcoin-gold"] input[type="date"]::-webkit-calendar-picker-indicator,
[data-theme="nostr-purple"] input[type="date"]::-webkit-calendar-picker-indicator {
    filter: invert(1) brightness(0.8);
}

[data-theme="neon-green"] input[type="date"]::-webkit-calendar-picker-indicator {
    filter: invert(1) hue-rotate(120deg) saturate(2) brightness(1.2);
}

/* Focus states */
input[type="date"]:focus {
    border-color: var(--primary-color) !important;
    outline: none;
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
}

[data-theme="neon-green"] input[type="date"]:focus {
    border-color: var(--accent) !important;
    box-shadow: 0 0 0 2px rgba(0, 255, 0, 0.3);
}

/* Fix Nostr Purple theme - should use light color scheme */
[data-theme="nostr-purple"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: light; /* Changed from dark to light */
}

[data-theme="nostr-purple"] input[type="date"]::-webkit-calendar-picker-indicator {
    filter: none; /* Remove the invert filter for light theme */
    opacity: 0.7;
}

/* Neon green search input */
[data-theme="neon-green"] #search-input {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
}

/* Neon green archive name input placeholder */
[data-theme="neon-green"] #new-archive-name::placeholder {
    color: var(--accent) !important;
}

[data-theme="neon-green"] #new-archive-name {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
}

[data-theme="neon-green"] #search-input::placeholder {
    color: color-mix(in srgb, var(--accent) 60%, transparent) !important;
}

[data-theme="neon-green"] #search-input:focus {
    border-color: var(--accent) !important;
    box-shadow: 0 0 0 2px rgba(0, 255, 0, 0.3) !important;
}

/* Nostr purple hashtag hover - only on hover-capable devices */
@media (hover: hover) {
    body[data-theme="nostr-purple"] .note-card .hashtag:hover,
    [data-theme="nostr-purple"] .note-card .hashtag:hover {
      background: color-mix(in srgb, var(--purple-color) 28%, #fff) !important;
    }
}

/* FINAL OVERRIDES — Neon Green hashtag pills (wins everywhere) */
body[data-theme="neon-green"] .note-card .hashtag,
[data-theme="neon-green"] .note-card.reply-card .hashtag,
[data-theme="neon-green"] .note-card.archived .hashtag {
  background: var(--accent-weak-2) !important;
  border: 1px solid var(--accent-border) !important;
  color: var(--accent) !important;
  border-radius: 12px; /* keep pill shape */
}

/* Neon green hashtag hover - only on hover-capable devices */
@media (hover: hover) {
    body[data-theme="neon-green"] .note-card .hashtag:hover,
    [data-theme="neon-green"] .note-card.reply-card .hashtag:hover,
    [data-theme="neon-green"] .note-card.archived .hashtag:hover {
      background: var(--accent-weak) !important;
    }
}

/* neon-green: buttons */
[data-theme="neon-green"] .btn {
  background: var(--accent-weak);
  color: var(--accent);
  border: 1px solid var(--accent-border);
  text-shadow: 0 0 2px var(--accent);
}
[data-theme="neon-green"] .btn:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000);
  border-color: var(--accent);
}

/* Theme-specific action button styles */
[data-theme="dark-nostr"] .btn-action-primary {
    background: var(--primary-color);
    box-shadow: 0 2px 4px rgba(138, 124, 255, 0.3);
}

[data-theme="bitcoin-gold"] .btn-action-primary {
    background: var(--primary-color);
    color: white;
    box-shadow: 0 2px 4px rgba(247, 147, 26, 0.3);
}

[data-theme="nostr-purple"] .btn-action-primary {
    background: var(--primary-color);
    box-shadow: 0 2px 4px rgba(107, 78, 255, 0.3);
}

[data-theme="neon-green"] .btn-action-primary {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.4) !important;
    text-shadow: 0 0 2px var(--accent) !important;
}

[data-theme="neon-green"] .btn-action-secondary {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
}


/* neon-green: hashtags inside notes */
[data-theme="neon-green"] .hashtag {
  background: var(--accent-weak-2);
  border: 1px solid var(--accent-border);
  color: var(--accent);
  border-radius: 12px;
}

/* Neon green general hashtag hover - only on hover-capable devices */
@media (hover: hover) {
    [data-theme="neon-green"] .hashtag:hover {
      background: var(--accent-weak);
    }
}

/* neon-green: tag filters in sidebar */
[data-theme="neon-green"] .tag-filter {
  background: var(--accent-weak-2);
  border-color: var(--accent-border);
  color: var(--accent);
}

/* Only apply hover on devices with actual hover capability */
@media (hover: hover) {
    [data-theme="neon-green"] .tag-filter:hover {
      background: var(--accent-weak);
      border-color: var(--accent);
      color: var(--accent);
    }
}

[data-theme="neon-green"] .tag-filter.active {
  background: var(--accent-weak);
  border-color: var(--accent);
  color: var(--accent);
}

/* neon-green: progress bar */
[data-theme="neon-green"] .progress-bar {
  background: var(--accent-weak-2);
  border-color: var(--accent-border);
}
[data-theme="neon-green"] .progress-fill {
  background: var(--accent);
  color: #000;
  text-shadow: none;
}

/* Neon green Deep Scan button */
[data-theme="neon-green"] #deep-scan-btn {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    text-shadow: 0 0 2px var(--accent) !important;  /* Reduced from 4px to 2px */
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #deep-scan-btn:hover {
    background: color-mix(in srgb, var(--accent) 28%, #000) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* neon-green: utility buttons (refresh, disconnect, clear cache, info, etc.) */
[data-theme="neon-green"] #refresh-btn,
[data-theme="neon-green"] #disconnect-btn,
[data-theme="neon-green"] #clear-cache-btn,
[data-theme="neon-green"] .modal-close {
  background: var(--accent-weak) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 2px var(--accent) !important;  /* Reduced from 4px to 2px */
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #refresh-btn:hover,
[data-theme="neon-green"] #disconnect-btn:hover,
[data-theme="neon-green"] #clear-cache-btn:hover,
[data-theme="neon-green"] .modal-close:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000) !important;
  border-color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* neon-green: All remaining buttons - comprehensive fix */
[data-theme="neon-green"] #search-keyword-btn,
[data-theme="neon-green"] #select-all-visible,
[data-theme="neon-green"] #deselect-all,
[data-theme="neon-green"] #select-all-keyword,
[data-theme="neon-green"] #deselect-all-keyword,
[data-theme="neon-green"] #bulk-add-to-archive,
[data-theme="neon-green"] #bulk-remove-from-archive,
[data-theme="neon-green"] #bulk-archive-btn,
[data-theme="neon-green"] #bulk-delete-btn {
  background: var(--accent-weak) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
text-shadow: 0 0 2px var(--accent) !important;  /* Reduced from 4px to 2px */
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #search-keyword-btn:hover,
[data-theme="neon-green"] #select-all-visible:hover,
[data-theme="neon-green"] #deselect-all:hover,
[data-theme="neon-green"] #select-all-keyword:hover,
[data-theme="neon-green"] #deselect-all-keyword:hover,
[data-theme="neon-green"] #bulk-add-to-archive:hover,
[data-theme="neon-green"] #bulk-remove-from-archive:hover,
[data-theme="neon-green"] #bulk-archive-btn:hover,
[data-theme="neon-green"] #bulk-delete-btn:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000) !important;
  border-color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* neon-green: Dropdown selects */
[data-theme="neon-green"] #bulk-archive-dropdown,
[data-theme="neon-green"] #bulk-target-archive {
  background: var(--accent-weak-2) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
}

/* neon-green: Info buttons with inline styles */
[data-theme="neon-green"] button[onclick*="showNoteInfo"] {
  background: var(--accent-weak-2) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 3px var(--accent) !important;
}

/* neon-green: small info buttons */
[data-theme="neon-green"] .btn-small {
background: var(--accent-weak-2) !important;
color: var(--accent) !important;
border: 1px solid var(--accent-border) !important;
text-shadow: 0 0 3px var(--accent) !important;
}
[data-theme="neon-green"] .btn-small:hover {
background: var(--accent-weak) !important;
border-color: var(--accent) !important;
}

/* neon-green: Regular archives (non-active) */
[data-theme="neon-green"] .archive-item {
  background: var(--accent-weak-2) !important;
  border: 1px solid var(--accent-border) !important;
  color: var(--accent) !important;
  box-shadow: none !important;
}

/* neon-green: Only the active archive gets the glow */
[data-theme="neon-green"] .archive-item.active {
  background: var(--accent-weak) !important;
  border: 2px solid var(--accent) !important;
  color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* neon-green: Load More button */
[data-theme="neon-green"] #load-more-btn {
  background: var(--accent-weak) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 2px var(--accent) !important;  /* Reduced from 4px to 2px */
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #load-more-btn:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000) !important;
  border-color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

[data-theme="neon-green"] .modal {
    background: rgba(0, 0, 0, 0.8) !important;
}

[data-theme="neon-green"] .modal-content {
    background: var(--card-background) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3) !important;
}

[data-theme="neon-green"] .modal-close {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    text-shadow: 0 0 2px var(--accent) !important;  /* Reduced from 4px to 2px */
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] .modal-close:hover {
    background: color-mix(in srgb, var(--accent) 28%, #000) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* Neon green theme override for Import Archive */
[data-theme="neon-green"] #import-btn {
  background: #003300 !important;       /* darker green base */
  border: 1px solid var(--accent-border);
  color: var(--accent);
}

[data-theme="neon-green"] #import-btn:hover {
  background: #006600 !important;       /* brightens on hover */
  box-shadow: 0 0 12px rgba(0,255,0,0.35);
}

/* Hashtag group header hover effects - only on devices with actual hover capability */
@media (hover: hover) {
    .hashtag-group-header:hover {
        background: var(--primary-color) !important;
        color: white !important;
        border-color: var(--primary-color) !important;
    }
}

/* Mobile tap feedback using :active (shows only while pressing) */
@media (hover: none) {
    .hashtag-group-header:active {
        background: var(--primary-color) !important;
        color: white !important;
        border-color: var(--primary-color) !important;
    }
}

/* Fix text color for dark themes - only on hover-capable devices */
@media (hover: hover) {
    [data-theme="dark-nostr"] .hashtag-group-header:hover,
    [data-theme="bitcoin-gold"] .hashtag-group-header:hover {
        color: var(--card-background) !important;
    }
}

/* Mobile tap feedback for dark themes */
@media (hover: none) {
    [data-theme="dark-nostr"] .hashtag-group-header:active,
    [data-theme="bitcoin-gold"] .hashtag-group-header:active {
        color: var(--card-background) !important;
    }
}

/* Fix hashtag button hover text color for dark themes - only on hover-capable devices */
@media (hover: hover) {
    [data-theme="dark-nostr"] .tag-filter:hover,
    [data-theme="bitcoin-gold"] .tag-filter:hover {
        color: var(--card-background) !important;
    }
}

/* Neon green theme stays the same */
[data-theme="neon-green"] .hashtag-group-header {
    background: var(--accent-weak-2) !important;
    border-color: var(--accent-border) !important;
    color: var(--accent) !important;
}

/* Neon green theme hover - only on hover-capable devices */
@media (hover: hover) {
    [data-theme="neon-green"] .hashtag-group-header:hover {
        background: var(--accent-weak) !important;
        border-color: var(--accent) !important;
        color: var(--accent) !important;
        box-shadow: 0 0 8px rgba(0, 255, 0, 0.3) !important;
    }
}

/* Mobile tap feedback for neon green theme */
@media (hover: none) {
    [data-theme="neon-green"] .hashtag-group-header:active {
        background: var(--accent-weak) !important;
        border-color: var(--accent) !important;
        color: var(--accent) !important;
        box-shadow: 0 0 8px rgba(0, 255, 0, 0.3) !important;
    }
}

/* Fix Clear All Filters button theming */
[data-theme="neon-green"] .search-container button[onclick="clearAllFilters()"] {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    text-shadow: 0 0 2px var(--accent) !important;  /* Reduced from 4px to 2px */
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] .search-container button[onclick="clearAllFilters()"]:hover {
    background: color-mix(in srgb, var(--accent) 28%, #000) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* Fix hashtag hover colors for dark themes - only on hover-capable devices */
@media (hover: hover) {
    [data-theme="dark-nostr"] .tag-filter:hover {
        color: var(--text-color) !important;
        background: color-mix(in srgb, var(--primary-color) 40%, transparent) !important;
    }

    [data-theme="bitcoin-gold"] .tag-filter:hover {
        color: var(--text-color) !important;
        background: color-mix(in srgb, var(--primary-color) 40%, transparent) !important;
    }
}

/* Hashtag drag selection styles */
.hashtag-selecting {
    cursor: grabbing !important;
}

.hashtag-selecting .hashtag {
    cursor: grabbing !important;
}

/* Improve hashtag hover states during selection */
.hashtag {
    transition: all 0.15s ease;
    user-select: none;
}

.hashtag:hover {
    transform: translateY(-1px);
}

/* Selected hashtag highlighting for Default theme */
.hashtag[data-selected="true"],
body .note-card .hashtag[data-selected="true"] {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Selected hashtag highlighting for Dark Nostr theme */
body[data-theme="dark-nostr"] .note-card .hashtag[data-selected="true"],
[data-theme="dark-nostr"] .note-card .hashtag[data-selected="true"],
body[data-theme="dark-nostr"] .note-card.repost-card .hashtag[data-selected="true"],
body[data-theme="dark-nostr"] .note-card.quote-card .hashtag[data-selected="true"] {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Selected hashtag highlighting for Bitcoin Gold theme */
body[data-theme="bitcoin-gold"] .note-card .hashtag[data-selected="true"],
[data-theme="bitcoin-gold"] .note-card .hashtag[data-selected="true"],
body[data-theme="bitcoin-gold"] .note-card.repost-card .hashtag[data-selected="true"],
body[data-theme="bitcoin-gold"] .note-card.quote-card .hashtag[data-selected="true"] {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Selected hashtag highlighting for Nostr Purple theme */
body[data-theme="nostr-purple"] .note-card .hashtag[data-selected="true"],
[data-theme="nostr-purple"] .note-card .hashtag[data-selected="true"],
body[data-theme="nostr-purple"] .note-card.repost-card .hashtag[data-selected="true"],
body[data-theme="nostr-purple"] .note-card.quote-card .hashtag[data-selected="true"] {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Selected hashtag highlighting for Neon Green theme */
body[data-theme="neon-green"] .note-card .hashtag[data-selected="true"],
[data-theme="neon-green"] .note-card.reply-card .hashtag[data-selected="true"],
[data-theme="neon-green"] .note-card.archived .hashtag[data-selected="true"] {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.6) !important;
}

/* Background loading indicator */
.background-loading-indicator {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--card-background);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px 16px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 1000;
    font-size: 13px;
    color: var(--text-color);
    transform: translateX(300px);
    transition: transform 0.3s ease;
}

.background-loading-indicator.show {
    transform: translateX(0);
}

.background-loading-indicator .progress-text {
    margin-bottom: 4px;
    font-weight: 500;
}

.background-loading-indicator .progress-bar-small {
    width: 200px;
    height: 4px;
    background: var(--background-color);
    border-radius: 2px;
    overflow: hidden;
}

.background-loading-indicator .progress-fill-small {
    height: 100%;
    background: var(--primary-color);
    width: 0%;
    transition: width 0.3s ease;
}

/* Smart loading indicators */
.smart-loading-indicator {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--card-background);
    border: 2px solid var(--primary-color);
    border-radius: 12px;
    padding: 24px 32px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    z-index: 2000;
    text-align: center;
    min-width: 300px;
}

.smart-loading-text {
    font-size: 16px;
    font-weight: 500;
    color: var(--text-color);
    margin-bottom: 12px;
}

.smart-loading-details {
    font-size: 13px;
    color: var(--text-muted);
    margin-bottom: 16px;
}

.smart-progress-bar {
    width: 100%;
    height: 6px;
    background: var(--background-color);
    border-radius: 3px;
    overflow: hidden;
}

.smart-progress-fill {
    height: 100%;
    background: var(--primary-color);
    width: 0%;
    transition: width 0.3s ease;
    animation: smartProgress 2s ease-in-out infinite;
}

@keyframes smartProgress {
    0% { width: 0%; }
    50% { width: 70%; }
    100% { width: 100%; }
}

/* Repost card styling - change to use secondary color */
.note-card.repost-card {
    border-left: 4px solid var(--secondary-color) !important;
}

/* Quote card styling - also use secondary color like reposts */
.note-card.quote-card {
    border-left: 4px solid var(--secondary-color) !important;
}

/* Update theme-specific repost colors to use secondary */
[data-theme="dark-nostr"] .note-card.repost-card {
    border-left: 4px solid var(--secondary-color) !important;
}

[data-theme="bitcoin-gold"] .note-card.repost-card {
    border-left: 4px solid var(--secondary-color) !important;
}

[data-theme="nostr-purple"] .note-card.repost-card {
    border-left: 4px solid var(--secondary-color) !important;
}

[data-theme="neon-green"] .note-card.repost-card {
    border-left: 4px solid var(--secondary-color) !important;
}

/* Theme-specific overrides (these will inherit the secondary color from each theme) */
[data-theme="default"] .note-card.repost-card,
[data-theme="default"] .note-card.quote-card,
[data-theme="dark-nostr"] .note-card.repost-card,
[data-theme="dark-nostr"] .note-card.quote-card,
[data-theme="bitcoin-gold"] .note-card.repost-card,
[data-theme="bitcoin-gold"] .note-card.quote-card,
[data-theme="nostr-purple"] .note-card.repost-card,
[data-theme="nostr-purple"] .note-card.quote-card,
[data-theme="neon-green"] .note-card.repost-card,
[data-theme="neon-green"] .note-card.quote-card {
    border-left: 4px solid var(--secondary-color) !important;
}

/* ==================== MOBILE RESPONSIVE STYLES ==================== */

/* Tablets and smaller laptops (1024px and below) */
@media (max-width: 1024px) {
    .container {
        padding: 15px;
    }
    
    .controls-panel {
        padding: 15px;
    }
}

/* Tablets and large phones (768px and below) */
@media (max-width: 768px) {
    body {
        font-size: 14px;
    }
    
    .container {
        padding: 10px;
    }
    
    .header {
        margin-bottom: 20px;
    }
    
    .header h1 {
        font-size: 2em;
        margin-bottom: 10px;
    }
    
    .connection-box {
        padding: 25px 15px;
        border-radius: 8px;
    }
    
    /* Top header responsive - stack on mobile */
    .top-header {
        padding: 16px;
        margin-bottom: 16px;
    }
    
    .header-content {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
    }
    
    .header-left h2 {
        font-size: 1.3em;
    }
    
    .npub-display {
        font-size: 11px;
    }
    
    .header-actions {
        width: 100%;
        flex-wrap: wrap;
        gap: 8px;
    }
    
    .btn-action {
        flex: 1;
        min-width: 100px;
        justify-content: center;
        padding: 12px 14px;
        font-size: 13px;
    }
    
    /* Make inputs more touch-friendly and prevent iOS zoom */
    .form-group input,
    input[type="text"],
    input[type="search"],
    select,
    textarea {
        font-size: 16px !important;
        padding: 14px 12px;
    }
    
    /* Button improvements for touch */
    .btn {
        padding: 14px 20px;
        font-size: 16px;
        min-height: 48px;
    }
    
    /* Controls panel - stack elements */
    .controls-panel {
        padding: 15px;
    }
    
    /* Toast notifications - mobile positioning */
    .toast {
        top: 10px;
        right: 10px;
        left: 10px;
        max-width: calc(100% - 20px);
        padding: 12px 16px;
        font-size: 14px;
    }
    
    .search-container {
        flex-direction: column;
        gap: 10px;
    }
    
    .search-container input {
        width: 100% !important;
        margin-right: 0 !important;
    }
    
    /* Fix bulk controls layout on mobile */
    .bulk-controls {
        padding: 12px;
    }
    
    .bulk-controls > div:first-child {
        flex-direction: column !important;
        align-items: flex-start !important;
        gap: 10px;
    }
    
    .bulk-controls #selected-count {
        font-size: 14px;
        margin-bottom: 5px;
    }
    
    .bulk-controls button {
        font-size: 14px !important;
        padding: 10px 12px !important;
        min-height: 44px;
    }
    
    .bulk-controls > div:last-child {
        flex-direction: column !important;
        gap: 8px !important;
        width: 100%;
    }
    
    #bulk-archive-dropdown {
        width: 100% !important;
        min-width: unset !important;
        font-size: 16px !important;
        padding: 12px !important;
        min-height: 44px;
    }
    
    #bulk-add-to-archive,
    #bulk-remove-from-archive {
        width: 100% !important;
    }
    
    .search-container button {
        width: 100%;
    }
    
    /* Filter sections - improve spacing */
    .filter-section {
        margin-bottom: 15px;
    }
    
    .quick-filters {
        gap: 8px;
    }
    
    .quick-filter-btn {
        padding: 8px 12px;
        font-size: 13px;
    }
    
    /* Note cards - reduce padding */
    .note-card {
        padding: 15px;
        padding-bottom: 55px;
        margin-bottom: 12px;
    }
    
    /* Optimize note card buttons for mobile */
    .note-card .btn-small {
        font-size: 12px !important;
        padding: 8px 12px !important;
        min-height: 38px;
    }
    
    .note-card .note-actions {
        gap: 6px;
    }
    
    /* Make note content more readable on mobile */
    .note-card .note-content {
        font-size: 15px !important;
        line-height: 1.5;
        margin-bottom: 20px !important; /* More space before buttons */
    }
    
    /* Optimize timestamp on mobile */
    .note-card .note-meta {
        font-size: 12px !important;
    }
    
    /* Optimize "Replying to" badge */
    .note-card .reply-badge {
        font-size: 11px !important;
        padding: 3px 8px !important;
    }
    
    .note-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
    }
    
    .note-header > div:first-child {
        flex-wrap: wrap;
        max-width: 100%;
    }
    
    .note-content {
        font-size: 14px;
    }
    
    /* Archive controls - stack on mobile */
    .archive-controls {
        flex-direction: column;
        gap: 10px;
    }
    
    .archive-controls button {
        width: 100%;
    }
    
    /* Modals - improve mobile appearance */
    .modal-content {
        width: 95%;
        max-width: 95%;
        margin: 20px auto;
        max-height: 90vh;
        overflow-y: auto;
    }
    
    .archive-modal-content {
        width: 95%;
        max-width: 95%;
        padding: 20px 15px;
    }
    
    /* Thread view improvements */
    .thread-view {
        width: 100%;
        padding: 15px;
    }
    
    /* Image viewer - full screen on mobile */
    .image-overlay {
        padding: 10px;
    }
    
    .image-overlay img {
        max-width: 100%;
        max-height: 90vh;
    }
    
    /* Fix npub buttons - make them break text properly */
    .reply-indicator {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        flex-wrap: wrap;
        max-width: 100%;
        font-size: 13px;
        line-height: 1.4;
    }
    
    .npub-copy-btn {
        display: inline-block;
        max-width: 180px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        word-break: break-all;
        font-size: 10px;
        padding: 2px 8px;
        line-height: 1.2;
        vertical-align: middle;
        flex-shrink: 0;
        height: auto;
        min-height: 20px;
    }
    
    /* Fix reactions box positioning on mobile */
    .reactions-box {
        position: absolute;
        bottom: 8px;
        right: 8px;
        min-width: 100px;
        max-width: 140px;
        font-size: 11px;
        padding: 5px 10px;
    }
    
    /* Reactions popup - flush right on mobile */
    .reactions-popup {
        position: fixed;
        bottom: auto;
        right: 10px;
        left: auto;
        top: 50%;
        transform: translateY(-50%);
        min-width: 220px;
        max-width: 280px;
        z-index: 10000;
    }
    
    .reactions-popup.show {
        display: block;
        animation: slideInRight 0.2s ease;
    }
    
    @keyframes slideInRight {
        from {
            opacity: 0;
            transform: translateY(-50%) translateX(20px);
        }
        to {
            opacity: 1;
            transform: translateY(-50%) translateX(0);
        }
    }
    
    /* Stats and info display */
    .stats-grid {
        grid-template-columns: 1fr;
        gap: 10px;
    }
    
    /* Make all clickable elements touch-friendly */
    button,
    .clickable,
    .tag-badge,
    .archive-option {
        min-height: 44px;
        min-width: 44px;
        touch-action: manipulation;
    }
    
    /* Remove persistent highlight on mobile tap */
    .tag-filter,
    .quick-filter-btn,
    .hashtag-group-header,
    button {
        -webkit-tap-highlight-color: transparent;
        /* Ensure immediate response to touches */
        touch-action: manipulation;
        /* Prevent 300ms click delay on mobile */
        cursor: pointer;
    }
    
    /* Better focus feedback for quick filter buttons - no glow, just subtle visual change */
    .quick-filter-btn:focus {
        outline: none !important;
        border: 2px solid var(--primary-color) !important;
        background: color-mix(in srgb, var(--primary-color) 10%, white) !important;
    }
    
    .tag-filter:focus,
    .hashtag-group-header:focus {
        outline: none !important;
    }
    
    /* Force immediate visual update for quick filter buttons */
    .quick-filter-btn {
        transition: none !important;
    }
    
    .quick-filter-btn.active {
        /* Ensure the active state is immediately visible */
        background: var(--primary-color) !important;
        color: white !important;
    }
    
    /* Prevent focus from keeping buttons highlighted after tap on mobile */
    @media (max-width: 768px) {
        .hashtag-group-header:focus {
            outline: none;
        }
    }
    
    /* Only apply hover on actual hover, not on focus */
    @media (hover: hover) {
        .tag-filter:hover,
        .quick-filter-btn:hover,
        .hashtag-group-header:hover {
            opacity: 0.8;
        }
    }
    
    /* Active state should always work */
    .tag-filter.active,
    .quick-filter-btn.active {
        opacity: 1 !important;
    }
    
    /* Improve tag badges for touch */
    .tag-badge {
        padding: 6px 12px;
        font-size: 13px;
    }
}

/* Small phones (480px and below) */
@media (max-width: 480px) {
    body {
        font-size: 13px;
    }
    
    .header h1 {
        font-size: 1.6em;
        letter-spacing: -0.01em;
    }
    
    .connection-box {
        padding: 20px 12px;
    }
    
    .container {
        padding: 8px;
    }
    
    .controls-panel {
        padding: 12px;
    }
    
    /* Further reduce button sizes */
    .btn {
        padding: 12px 16px;
        font-size: 15px;
    }
    
    .quick-filter-btn {
        padding: 6px 10px;
        font-size: 12px;
    }
    
    /* Note cards - more compact */
    .note-card {
        padding: 12px;
        padding-bottom: 50px;
        margin-bottom: 10px;
    }
    
    .note-content {
        font-size: 13px;
    }
    
    /* Modal adjustments */
    .modal-content,
    .archive-modal-content {
        width: 98%;
        max-width: 98%;
        padding: 15px 10px;
    }
    
    /* Thread view */
    .thread-view {
        padding: 10px;
    }
    
    /* Reduce spacing overall */
    .filter-section {
        margin-bottom: 12px;
    }
    
    .quick-filters {
        gap: 6px;
    }
    
    /* Additional npub fixes for very small screens */
    .npub-copy-btn {
        max-width: 150px;
        font-size: 9px;
        padding: 2px 6px;
        min-height: 18px;
        line-height: 1.2;
    }
    
    /* Reactions box - even more compact */
    .reactions-box {
        min-width: 90px;
        max-width: 120px;
        font-size: 10px;
        padding: 4px 8px;
        bottom: 6px;
        right: 6px;
    }
    
    /* Keep reactions popup flush right on small screens too */
    .reactions-popup {
        right: 10px;
        left: auto;
        transform: translateY(-50%);
        max-width: 260px;
    }
}

/* Very small devices (360px and below) */
@media (max-width: 360px) {
    .header h1 {
        font-size: 1.4em;
    }
    
    .quick-filter-btn {
        padding: 5px 8px;
        font-size: 11px;
    }
    
    .tag-badge {
        padding: 4px 8px;
        font-size: 11px;
    }
}

/* Landscape mobile improvements */
@media (max-width: 896px) and (orientation: landscape) {
    .modal-content,
    .archive-modal-content {
        max-height: 85vh;
        margin: 10px auto;
    }
    
    .thread-view {
        max-height: 85vh;
    }
}

/* iOS-specific fixes */
@supports (-webkit-touch-callout: none) {
    /* Fix for iOS Safari button rendering */
    button,
    .btn {
        -webkit-appearance: none;
        appearance: none;
    }
    
    /* Prevent iOS text size adjustment */
    body {
        -webkit-text-size-adjust: 100%;
    }
}

/* Improve scrolling on mobile */
@media (max-width: 768px) {
    .modal-content,
    .archive-modal-content,
    .thread-view {
        -webkit-overflow-scrolling: touch;
    }
}
    </style>
</head>
<body>
    <div class="container">
        <!-- Connection Screen -->
        <div id="connection-screen">
            <div class="header">
                <h1><span class="emoji">📝</span> Nostr Notes Archive</h1>
                <p>View and organize your Nostr notes</p>
            </div>

            <div class="connection-box">
                <h3 style="text-align: center; margin-bottom: 20px;">Connect Your Account</h3>
                
                <div class="form-group">
               <label>Your Public Key (npub):</label>
<input type="text" id="pubkey-input" placeholder="Enter your npub..." style="font-family:monospace;">
<small style="color: var(--text-muted); font-size:12px;">
                </div>
                
                 <button id="connect-btn" class="btn"><span class="emoji">🔍</span> Load My Notes</button>
                
                <div class="info-box">
                    <strong>How to find your public key:</strong><br>
                    • Damus: Profile → Settings → Account → Public Key<br>
                    • Primal: Settings → Account → Copy public key<br>
                    • Iris: Profile → Copy public key<br>
                    <br>
                    Paste your npub (NIP-19) above.
                </div>

                <div id="connection-error" class="error"></div>
            </div>
        </div>

        <!-- Main App -->
        <div id="main-app" class="hidden">
            <div class="top-header">
    <div class="header-content">
        <div class="header-left">
            <h2><span class="emoji">📝</span> My Nostr Archive</h2>
            <small id="pubkey-display" class="npub-display">
        </div>
        <div class="header-actions">
            <button id="deep-scan-btn" class="btn-action btn-action-primary">
                Deep Scan
            </button>
            <button id="refresh-btn" class="btn-action btn-action-primary">
                Refresh
            </button>
            <button id="disconnect-btn" class="btn-action btn-action-secondary">
                Disconnect
            </button>
        </div>
    </div>
</div>

            <div class="app-layout">
    <div class="sidebar">
        <div class="search-container" style="margin-bottom: 16px;">
    <!-- Main search bar -->
    <div style="margin-bottom: 12px;">
        <input type="text" id="search-input" placeholder="Search notes... (/ to focus)" 
               style="width: 100%; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 4px;">
    </div>
    
    <!-- Primary Quick filters - 3x2 grid -->
<div class="quick-filters" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; margin-bottom: 12px;">
    <button type="button" class="btn btn-tiny quick-filter-btn" data-filter="month" onclick="this.blur(); toggleQuickFilter('month', this);">This Month</button>
    <button type="button" class="btn btn-tiny quick-filter-btn" data-filter="year" onclick="this.blur(); toggleQuickFilter('year', this);">This Year</button>
    <button type="button" class="btn btn-tiny quick-filter-btn" data-filter="images" onclick="this.blur(); toggleQuickFilter('images', this);">Images</button>
    <button type="button" class="btn btn-tiny quick-filter-btn" data-filter="youtube" onclick="this.blur(); toggleQuickFilter('youtube', this);">Videos</button>
    <button type="button" class="btn btn-tiny quick-filter-btn" data-filter="long" onclick="this.blur(); toggleQuickFilter('long', this);">Long</button>
    <button type="button" class="btn btn-tiny quick-filter-btn" data-filter="links" onclick="this.blur(); toggleQuickFilter('links', this);">Links</button>
</div>

<!-- Secondary filters dropdown -->
<div style="margin-bottom: 12px;">
<select id="secondary-filter-dropdown" onchange="handleSecondaryFilter()" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--card-background); color: var(--text-color); font-size: 13px;">
<option value="">More Filters...</option>
<option value="week">This Week</option>
<option value="6months">6 Months</option>
<option value="music">Music</option>
<option value="most-liked">Most Liked</option>
<option value="most-zapped">Most Zapped</option>
<option value="most-reposted">Most Reposted</option>
<option value="most-quoted">Most Quoted</option>
</select>
</div>
    
    <!-- Date range filters -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
        <div>
            <label style="font-size: 11px; color: var(--text-muted); margin-bottom: 2px; display: block;">FROM DATE</label>
            <input type="date" id="date-from" onchange="applyDateFilters()" 
                   style="width: 100%; padding: 4px 6px; border: 1px solid var(--border-color); border-radius: 3px; font-size: 12px; background: var(--background-color); color: var(--text-color);">
        </div>
        <div>
            <label style="font-size: 11px; color: var(--text-muted); margin-bottom: 2px; display: block;">TO DATE</label>
            <input type="date" id="date-to" onchange="applyDateFilters()"
                   style="width: 100%; padding: 4px 6px; border: 1px solid var(--border-color); border-radius: 3px; font-size: 12px; background: var(--background-color); color: var(--text-color);">
        </div>
    </div>
    
    <!-- Clear filters button -->
    <button class="btn btn-tiny clear-filters-btn" 
            onclick="clearAllFilters()" 
            ontouchstart="this.style.transform='scale(0.95)'; this.style.background='#7f8c8d';"
            ontouchend="this.style.transform=''; this.style.background='#95a5a6';"
            style="width: 100%; background: #95a5a6; color: white; border: none;">
        Clear All Filters
    </button>
</div>
        
        <div class="sidebar-section">
            <h4>My Archives</h4>
            <div id="archive-list">
                <!-- Archives will be populated here -->
            </div>
            <div style="margin-top: 15px;">
                <input type="text" id="new-archive-name" class="keyword-input" placeholder="New archive name..." maxlength="30">
               <button id="create-archive-btn" class="btn" style="font-size: 14px; padding: 8px;"><span class="emoji"></span> Create Archive</button>
              </div>
        </div>

        <div class="sidebar-section">
            <h4>Filter by Tags</h4>
            <div id="tag-filters">
                <button class="tag-filter active" data-tag="">All Notes (0)</button>
               <button class="tag-filter" data-tag="__original" style="background: #3498db; color: white;"><span class="emoji">📝</span> Original Notes (0)</button>
               <button class="tag-filter" data-tag="__replies" style="background: #9b59b6; color: white;"><span class="emoji">💬</span> Replies (0)</button>
            </div>
        </div>

        <div class="sidebar-section">
            <h4>Export</h4>
            <button id="export-json" class="btn" style="font-size: 14px; padding: 8px;">Export JSON</button>
           <button id="export-md" class="btn" style="font-size: 14px; padding: 8px;">Export CSV</button>
        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
        <input type="file" id="import-file" accept=".json,.md,.txt" style="display: none;">
        <div class="import-archive-block">
  <button id="import-btn" class="btn" style="font-size: 14px; padding: 8px; background: #27ae60;">
    <span class="emoji"></span> Import Archive
  </button>
  <small class="import-hint">Supports JSON exports from this app</small>
</div>
    </div>
    
    <button id="clear-cache-btn" class="btn" style="font-size: 14px; padding: 8px; background: #e74c3c;"><span class="emoji"></span> Clear Cache</button>
</div>

<button id="storage-info-btn" class="btn" style="font-size: 14px; padding: 8px;">
    Storage Info
</button>

        <div class="sidebar-section">
            <h4>About</h4>
            <button id="app-info-btn" class="btn" style="font-size: 14px; padding: 8px;">
                App Info
            </button>
        </div>

        <div class="sidebar-section">
    <h4>Keyboard Shortcuts</h4>
    <div style="font-size: 12px; color: var(--text-muted); line-height: 1.4;">
        <div><kbd>/</kbd> or <kbd>Ctrl+K</kbd> Focus search</div>
        <div><kbd>Esc</kbd> Clear search/selections</div>
        <div><kbd>A</kbd> Select all visible</div>
        <div><kbd>Del</kbd> Remove selected</div>
    </div>
</div>
        
        
    <div class="sidebar-section">
            <h4>Theme</h4>
            <select id="theme-selector" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--card-background); color: var(--text-color);">
                <option value="default">Default Blue</option>
                <option value="nostr-purple">Nostr Purple</option>
                <option value="dark-nostr">Dark Nostr</option>
                <option value="bitcoin-gold">Bitcoin Gold</option>
                <option value="neon-green">Neon Green</option>
            </select>
    </div>
</div>


    <div class="main-content">
<!-- Main content card starts here -->
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 32px; padding-bottom: 16px; border-bottom: 1px solid var(--border-color);">
    <div>
        <h3 id="notes-title">All Notes</h3>
        <small id="notes-count" style="color: var(--text-muted);">0 notes</small>
    </div>
  </div>



                    <div id="bulk-controls" class="bulk-controls hidden">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <span id="selected-count" style="font-weight: bold;">0 notes selected</span>
                            <div>
                                <button id="select-all-visible" class="btn btn-small" style="background: #34495e;">Select All Visible</button>
                                <button id="deselect-all" class="btn btn-small" style="background: #7f8c8d;">Deselect All</button>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                           <select id="bulk-archive-dropdown" style="flex: 1; min-width: 150px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--card-background); color: var(--text-color);">
                                <option value="">Select archive...</option>
                            </select>
                           <button id="bulk-add-to-archive" class="btn btn-small" style="background: #27ae60;"><span class="emoji"></span> Add to Archive</button>
                           <button id="bulk-remove-from-archive" class="btn btn-small" style="background: #e74c3c;"><span class="emoji"></span> Remove from Archive</button>
                        </div>
                    </div>
                  <!-- Loader: ALL loader UI goes inside #loading -->
<div id="loading" class="loading hidden">
<div style="font-size: 24px; margin-bottom: 10px;"><span class="emoji">🔄</span></div>
  <p id="loading-text">Loading your notes...</p>
  <div class="progress-bar">
    <div id="progress-fill" class="progress-fill" style="width: 0%;">0%</div>
  </div>
  <div id="status-info" class="status-info"></div>
</div>


<!-- Notes list lives OUTSIDE the loading box -->
<div id="notes-container"></div>

<div id="load-more-container" class="hidden" style="text-align: center; margin: 20px 0;">
  <button id="load-more-btn" class="btn">Load More Notes</button>
  <div id="pagination-info" style="font-size:14px;">
    Showing 0 of 0 notes
  </div>
</div>


<!-- Empty state also OUTSIDE the loading box -->
<div id="empty-state" class="hidden" style="text-align: center; padding: 50px; color: #666;">
<div style="font-size: 48px; margin-bottom: 20px;"><span class="emoji">📝</span></div>
  <h3>No notes found</h3>
  <p>Make sure you've posted notes to Nostr, or check your public key.</p>
</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentPubkey = null;
        let allNotes = [];
        let filteredNotes = [];
        let archivedNotes = new Set(); // Keep for backward compatibility
        let namedArchives = {}; // New: stores multiple archives { archiveName: Set(noteIds) }
        let currentTag = '';
        let searchQuery = '';
        let currentArchive = 'default'; // Track which archive we're viewing
        let selectedNotes = new Set(); // Track selected notes for bulk operations
        let selectedTags = new Set(); // NEW: multi-select tags
        let notesPerPage = 100;
        let currentPage = 1;
        let hashtagElementCache = null;
        let noteMatchCache = null;

        // Engagement tracking
let engagementCache = new Map();
const processedEngagementEvents = new Set();
let engagementFetchQueue = new Set();
let isFetchingEngagement = false;
let cancelEngagementFetch = false;
let currentSortMode = null;

        // Performance optimization
let filterDebounceTimeout = null;
let isFiltering = false;

        // Progressive loading state
let isBackgroundLoading = false;
let backgroundLoadingProgress = 0;
let totalNotesExpected = 0;

// IndexedDB setup with Dexie
let db = null;

          // ADD THIS FUNCTION HERE:
        function npubToHex(npub) {
            try {
                if (!window.NostrTools || !window.NostrTools.nip19) {
                    throw new Error('NostrTools library not loaded');
                }
                
                const decoded = window.NostrTools.nip19.decode(npub);
                if (decoded.type !== 'npub') {
                    throw new Error('Not a valid npub');
                }
                
                return decoded.data;
            } catch (error) {
                console.error('Error converting npub to hex:', error);
                return null;
            }
        }

// Normalize pasted npub (strip spaces, prefix, hidden chars)
function normalizeNpub(input) {
  let s = (input || '').trim().toLowerCase();

  // remove spaces/newlines
  s = s.replace(/\s+/g, '');

  // remove nostr: URI prefix if present
  s = s.replace(/^nostr:/, '');

  // remove zero-width characters and BOM
  s = s.replace(/[\u200B-\u200D\uFEFF]/g, '');

  // replace “smart quotes” with plain quotes (just in case)
  s = s.replace(/[‘’]/g, "'").replace(/[“”]/g, '"');

  return s;
}

        // Enhanced relay list with better reliability
    const RELAYS = [
    'wss://relay.primal.net',      // Fastest - move to top
    'wss://relay.damus.io',         
    'wss://nostr.wine',             
    'wss://nos.lol',                
    'wss://nostr.land/',
    'wss://fiatjaf.com',
];

        // Initialize the app
      document.addEventListener('DOMContentLoaded', function () {
    setupEventListeners();
    setupKeyboardShortcuts();
    setupHashtagDragSelection();

  // Auto-login if we have a saved npub
  const savedNpub = localStorage.getItem('nostr-saved-npub');
  if (savedNpub) {
    document.getElementById('pubkey-input').value = savedNpub;
    connectWithPubkey();
  }
});

        function setupEventListeners() {
            document.getElementById('connect-btn').addEventListener('click', connectWithPubkey);
            document.getElementById('disconnect-btn').addEventListener('click', disconnect);
            document.getElementById('storage-info-btn').addEventListener('click', showStorageInfo);

          // Add null check for app-info-btn
            const appInfoBtn = document.getElementById('app-info-btn');
            if (appInfoBtn) {
                appInfoBtn.addEventListener('click', showAppInfo);
            }    

           // Add null checks for import elements
    const importBtn = document.getElementById('import-btn');
    const importFile = document.getElementById('import-file');
    
    if (importBtn) importBtn.addEventListener('click', triggerFileImport);
    if (importFile) importFile.addEventListener('change', handleFileImport);

            // NEW: allow pressing Enter in the npub box to connect
const pubkeyInput = document.getElementById('pubkey-input');
pubkeyInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    connectWithPubkey();
  }
});

           // IMPROVEMENT 3: Debounced search for better performance
let searchTimeout;
document.getElementById('search-input').addEventListener('input', function(e) {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => handleSearch(e), 300);
});
            document.getElementById('refresh-btn').addEventListener('click', refreshNotes);
            document.getElementById('deep-scan-btn').addEventListener('click', performDeepScan);
            document.getElementById('export-json').addEventListener('click', exportAsJSON);
            document.getElementById('export-md').addEventListener('click', exportAsCSV);
            document.getElementById('create-archive-btn').addEventListener('click', createNewArchive);
            document.getElementById('new-archive-name').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        createNewArchive();
    }
});
            document.getElementById('clear-cache-btn').addEventListener('click', clearAllCache);
            document.getElementById('load-more-btn').addEventListener('click', loadMoreNotes);
            
            
            // Bulk controls for main view
            document.getElementById('select-all-visible').addEventListener('click', selectAllVisible);
            document.getElementById('deselect-all').addEventListener('click', deselectAll);
            document.getElementById('bulk-add-to-archive').addEventListener('click', bulkAddToArchive);
            document.getElementById('bulk-remove-from-archive').addEventListener('click', bulkRemoveFromArchive);
        }

        function setupHashtagDragSelection() {
    const tagFiltersEl = document.getElementById('tag-filters');
    if (!tagFiltersEl) return;
    
    // Remove any existing listeners to prevent duplicates
    if (tagFiltersEl.__dragSetup) return;
    
    // Handle mousedown on hashtag buttons only
    tagFiltersEl.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // Left mouse button only
        
        const btn = e.target.closest('.tag-filter');
        if (!btn) return;
        
        const tag = btn.dataset.tag;
        if (!tag || !tag.startsWith('#')) return; // Only hashtags, not special buttons
        
        startHashtagSelection(tag, e);
    });
    
    // Handle mouseover for dragging
    tagFiltersEl.addEventListener('mouseover', (e) => {
        if (!isSelecting) return;
        
        const btn = e.target.closest('.tag-filter');
        if (!btn) return;
        
        const tag = btn.dataset.tag;
        if (!tag || !tag.startsWith('#')) return;
        
        continueHashtagSelection(tag, e);
    });
    
    tagFiltersEl.__dragSetup = true; // Prevent duplicate setup
}

        async function loadArchivedNotes() {
    if (!currentPubkey) return;
    
    try {
        // Try loading from IndexedDB first
        const chunkStorage = new ChunkedNoteStorage(currentPubkey);
        const ready = await chunkStorage.init();
        
        if (ready && chunkStorage.db) {
            const archivesData = await chunkStorage.db.indices.get('archives');
            
            if (archivesData && archivesData.data) {
                namedArchives = {};
                Object.keys(archivesData.data).forEach(name => {
                    namedArchives[name] = new Set(archivesData.data[name]);
                });
                console.log(`Loaded ${Object.keys(namedArchives).length} archives from IndexedDB`);
                return;
            }
        }
        
        // Fallback: try localStorage
        const savedArchives = localStorage.getItem(`nostr-named-archives-${currentPubkey}`);
        if (savedArchives) {
            const parsed = JSON.parse(savedArchives);
            namedArchives = {};
            Object.keys(parsed).forEach(name => {
                namedArchives[name] = new Set(parsed[name]);
            });
            
            // Migrate to IndexedDB if possible
            if (ready && chunkStorage.db) {
                await chunkStorage.db.indices.put({
                    type: 'archives',
                    data: parsed
                });
                console.log('Migrated archives from localStorage to IndexedDB');
            }
        } else {
            namedArchives = {};
        }
        
        // Legacy archive for backward compatibility
        const saved = localStorage.getItem(`nostr-archived-notes-${currentPubkey}`);
        if (saved) {
            archivedNotes = new Set(JSON.parse(saved));
        } else {
            archivedNotes = new Set();
        }
        
        // Migration logic
        if (archivedNotes.size > 0 && !namedArchives['My Archive']) {
            namedArchives['My Archive'] = new Set([...archivedNotes]);
            archivedNotes.clear();
            await saveArchivedNotes();
        }
    } catch (error) {
        console.error('Error loading archived notes:', error);
        namedArchives = {};
        archivedNotes = new Set();
    }
}

// IMPROVEMENT: Keyboard shortcuts
function setupKeyboardShortcuts() {
    document.addEventListener('keydown', function(e) {
        // Don't trigger shortcuts when typing in inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            // Exception: Escape should work even in inputs
            if (e.key === 'Escape') {
                e.target.blur();
                if (e.target.id === 'search-input') {
                    e.target.value = '';
                    handleSearch();
                }
            }
            return;
        }

         // NEW: allow Enter to submit npub on the connection screen
  if (e.key === 'Enter') {
    const connectionScreen = document.getElementById('connection-screen');
    const pubkeyInput = document.getElementById('pubkey-input');

    if (
      connectionScreen && pubkeyInput &&
      !connectionScreen.classList.contains('hidden') &&
      (document.activeElement === pubkeyInput || pubkeyInput.value.trim())
    ) {
      e.preventDefault();
      connectWithPubkey();
      return; // handled
    }
  }


        // Prevent default for handled shortcuts
        const handled = true;

        switch(e.key) {
            case '/':
                e.preventDefault();
                document.getElementById('search-input').focus();
                break;
                
            case 'Escape':
    // ⭐ CANCEL ENGAGEMENT FETCH FIRST - before anything else
    cancelEngagementFetch = true;
    
    // Always clear everything and go back to "All Notes" state
    const searchInput = document.getElementById('search-input');
    
    // Clear search input
    searchInput.value = '';
    searchQuery = '';
    
    // Clear ALL filters and states
    activeQuickFilters.clear();
    selectedTags.clear();
    currentTag = '';
    currentArchive = 'default';
    currentSortMode = null;  // ⭐ Clear sort mode
    window.inAdvancedSearchMode = false;
    
    // Clear all UI active states
    document.querySelectorAll('.quick-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    document.querySelectorAll('.tag-filter').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.tag === '') {
            btn.classList.add('active');
        }
    });
    
    // Clear date filters
    document.getElementById('date-from').value = '';
    document.getElementById('date-to').value = '';
    
    // Clear dropdown
    const dropdown = document.getElementById('secondary-filter-dropdown');
    if (dropdown) dropdown.value = '';
    
    // Clear selections
    deselectAll();
    
    // Re-sort notes to original chronological order
    allNotes.sort((a, b) => b.created_at - a.created_at);
    
    // Force reset to all notes
    filteredNotes = allNotes.slice();
    resetPagination();
    renderNotes();
    
    // Reset title and count
    document.getElementById('notes-title').textContent = 'All Notes';
    document.getElementById('notes-count').textContent = `${allNotes.length} notes`;
    
    // Blur the search input
    searchInput.blur();
    break;
                
            case 'k':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    document.getElementById('search-input').focus();
                }
                break;
                
            case 'a':
                if (!e.ctrlKey && !e.metaKey) {
                    // Toggle select all visible notes
                    if (selectedNotes.size > 0) {
                        deselectAll();
                    } else {
                        selectAllVisible();
                    }
                }
                break;
                
            case 'Delete':
            case 'Backspace':
                if (selectedNotes.size > 0) {
                    e.preventDefault();
                    if (confirm(`Remove ${selectedNotes.size} selected notes from all archives?`)) {
                        bulkRemoveFromArchive();
                    }
                }
                break;
                
                
            default:
                return; // Don't prevent default for unhandled keys
        }
    });
}

async function saveArchivedNotes() {
    if (!currentPubkey) return;
    try {
        // Try IndexedDB first
        const chunkStorage = new ChunkedNoteStorage(currentPubkey);
        const ready = await chunkStorage.init();
        
        if (ready && chunkStorage.db) {
            // Save to IndexedDB
            const toSave = {};
            Object.keys(namedArchives).forEach(name => {
                toSave[name] = [...namedArchives[name]];
            });
            
            await chunkStorage.db.indices.put({
                type: 'archives',
                data: toSave
            });
            
            console.log('Archives saved to IndexedDB');
            return;
        }
        
        // Fallback to localStorage (with size limit warning)
        const toSave = {};
        Object.keys(namedArchives).forEach(name => {
            toSave[name] = [...namedArchives[name]];
        });
        
        const jsonSize = JSON.stringify(toSave).length;
        
        // Warn if approaching localStorage limits (5MB)
        if (jsonSize > 3000000) { // 3MB warning threshold
            showToast('⚠️ Archive data is large. Consider reducing archived notes.', 'warning', 5000);
        }
        
        localStorage.setItem(`nostr-named-archives-${currentPubkey}`, JSON.stringify(toSave));
        
    } catch (error) {
        if (error.name === 'QuotaExceededError') {
            showToast('Storage quota exceeded! Archives are too large. Try removing some archived notes.', 'error', 8000);
            console.error('Archive storage quota exceeded - too many notes archived');
        } else {
            console.error('Error saving archived notes:', error);
        }
    }
}

        function createNewArchive() {
    const name = document.getElementById('new-archive-name').value.trim();
    if (!name) {
        showToast('Please enter an archive name', 'error');
        return;
    }
    
    if (namedArchives[name]) {
        showToast('Archive with this name already exists', 'error');
        return;
    }
    
    namedArchives[name] = new Set();
    saveArchivedNotes();
    updateArchiveList();
    updateTargetArchiveDropdown();
    
    document.getElementById('new-archive-name').value = '';
    showToast(`Archive "${name}" created successfully!`, 'success');
}

        function deleteArchive(archiveName) {
            if (confirm(`Are you sure you want to delete the archive "${archiveName}"? This cannot be undone.`)) {
                delete namedArchives[archiveName];
                saveArchivedNotes();
                updateArchiveList();
                updateTargetArchiveDropdown();
                
                // If we were viewing the deleted archive, switch to all notes
                if (currentArchive === archiveName) {
                    filterByTag('');
                }
            }
        }

       function viewArchive(archiveName) {
    // Check if we're already viewing this archive - if so, go back to All Notes
    if (currentArchive === archiveName) {
        // Reset to All Notes view
        currentArchive = 'default';
        currentTag = '';
        selectedTags.clear(); // Clear hashtag selections
        currentSortMode = null; // Clear engagement sort mode
        
        // Clear all active states
        document.querySelectorAll('.archive-item').forEach(item => {
            item.classList.remove('active');
        });
        
        // Set "All Notes" as active in tag filters
        document.querySelectorAll('.tag-filter').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.tag === '') {
                btn.classList.add('active');
            }
        });
        
        // Use the existing filterByTag function to properly reset to all notes
        filterByTag('');
        
        return; // Exit early
    }
    
    // Normal archive selection
    currentArchive = archiveName;
    currentTag = '__archive_' + archiveName;
    selectedTags.clear(); // Clear hashtag selections when switching to archive
    
    // ADD: Clear "most" filter when entering archive
    currentSortMode = null;
    const dropdown = document.getElementById('secondary-filter-dropdown');
    if (dropdown) dropdown.value = '';
    
    // Clear all active states first
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Clear tag filters active states
    document.querySelectorAll('.tag-filter').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Use the existing filterByTag function
    filterByTag('__archive_' + archiveName);
    
    // Force update the archive list to show correct active state
    updateArchiveList();
}

        function updateArchiveList() {
    const container = document.getElementById('archive-list');
    if (!container) return;
    
    if (Object.keys(namedArchives).length === 0) {
        container.innerHTML = '<div style="color: #666; font-style: italic; font-size: 13px;">No archives created yet</div>';
        return;
    }
    
    container.innerHTML = Object.keys(namedArchives).map(name => {
        const count = namedArchives[name].size;
        const isActive = currentArchive === name;
        
        return `
            <div class="archive-item ${isActive ? 'active' : ''}" onclick="viewArchive('${name}')">
                <div class="archive-name">${escapeHtml(name)}</div>
                <div class="archive-count">(${count})</div>
                <div class="archive-actions" onclick="event.stopPropagation();">
                    <button class="btn btn-tiny btn-delete" onclick="deleteArchive('${name}')">×</button>
                </div>
            </div>
        `;
    }).join('');
}

        function updateTargetArchiveDropdown() {
    const bulkArchiveDropdown = document.getElementById('bulk-archive-dropdown');
    
    const archiveOptions = '<option value="">Select archive...</option>' +
        Object.keys(namedArchives).map(name => 
            `<option value="${name}">${escapeHtml(name)}</option>`
        ).join('');
    
    if (bulkArchiveDropdown) bulkArchiveDropdown.innerHTML = archiveOptions;
}

        function toggleArchiveNote(noteId, archiveName = null) {
    // If no specific archive is provided, show archive selection
    if (!archiveName && Object.keys(namedArchives).length > 0) {
        showArchiveSelectionModal(noteId);
        return;
    }
    
    // Legacy behavior - add to default archive
    if (archivedNotes.has(noteId)) {
        archivedNotes.delete(noteId);
        // Also remove from all named archives
        Object.keys(namedArchives).forEach(name => {
            namedArchives[name].delete(noteId);
        });
    } else {
        // Add to "My Archive" if it exists, otherwise create it
        if (!namedArchives['My Archive']) {
            namedArchives['My Archive'] = new Set();
        }
        namedArchives['My Archive'].add(noteId);
    }
    
    saveArchivedNotes();

    // Lock the title to prevent updates
const titleEl = document.getElementById('notes-title');
const countEl = document.getElementById('notes-count');
const originalTitle = titleEl.textContent;
const originalCount = countEl.textContent;

// Temporarily freeze the title
Object.defineProperty(titleEl, 'textContent', {
    set: function() { /* ignore */ },
    get: function() { return originalTitle; },
    configurable: true
});

updateArchiveList();
updateTagFilters();

// Unfreeze and restore
delete titleEl.textContent;
titleEl.textContent = originalTitle;
countEl.textContent = originalCount;

    // Update just the button state for this specific note
    const noteCard = document.querySelector(`[data-note-id="${noteId}"]`);
    if (noteCard) {
        const archiveBtn = noteCard.querySelector('.btn-archive');
        if (archiveBtn) {
            const isArchived = Object.values(namedArchives).some(archive => archive.has(noteId));
            archiveBtn.classList.toggle('archived', isArchived);
            archiveBtn.textContent = isArchived ? '✓ Archived' : 'Archive';
        }
    }
}

        function addToArchive(noteId, archiveName) {
    if (!namedArchives[archiveName]) {
        namedArchives[archiveName] = new Set();
    }
    
    namedArchives[archiveName].add(noteId);
    
    saveArchivedNotes();
    
    // PRESERVE filter title before render
    const titleEl = document.getElementById('notes-title');
    const countEl = document.getElementById('notes-count');
    const savedTitle = titleEl.textContent;
    const savedCount = countEl.textContent;
    
    updateTagFilters();
    updateArchiveList();
    renderNotes();
    
    // RESTORE filter title after render
    titleEl.textContent = savedTitle;
    countEl.textContent = savedCount;
}

        function showArchiveSelectionModal(noteId) {
    const archiveNames = Object.keys(namedArchives);
    if (archiveNames.length === 0) {
       showToast('Please create an archive first');
        return;
    }
    
    // Create custom modal HTML
    const optionsList = archiveNames.map((name, index) => 
        `<div class="archive-option" data-index="${index}" onclick="selectArchiveOption(${index}, '${noteId}')">
            ${index + 1}. ${escapeHtml(name)}
        </div>`
    ).join('');
    
    const modalHtml = `
        <div class="modal" onclick="closeArchiveModal(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeArchiveModal()">×</button>
                <h3>Select archive for this note:</h3>
                <div class="archive-options">
                    ${optionsList}
                </div>
                <div style="margin-top: 20px; text-align: center;">
                    <button class="btn btn-small" onclick="closeArchiveModal()">Cancel</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function selectArchiveOption(index, noteId) {
    const archiveNames = Object.keys(namedArchives);
    if (index >= 0 && index < archiveNames.length) {
        addToArchive(noteId, archiveNames[index]);
        showToast(`Note added to "${archiveNames[index]}" archive!`, 'success');
    }
    closeArchiveModal();
}

function closeArchiveModal(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

        // Bulk operations for main view
        function toggleNoteSelection(noteId) {
            if (selectedNotes.has(noteId)) {
                selectedNotes.delete(noteId);
            } else {
                selectedNotes.add(noteId);
            }
            updateSelectionUI();
        }

        function selectAllVisible() {
            filteredNotes.forEach(note => selectedNotes.add(note.id));
            updateSelectionUI();
            renderNotes();
        }

        function deselectAll() {
            selectedNotes.clear();
            updateSelectionUI();
            renderNotes();
        }

        function bulkAddToArchive() {
            const targetArchive = document.getElementById('bulk-archive-dropdown').value;
           if (!targetArchive) {
    showToast('Please select a target archive', 'error');
    return;
}

            if (selectedNotes.size === 0) {
                showToast('Please select some notes first');
                return;
            }

            let addedCount = 0;
            selectedNotes.forEach(noteId => {
                if (!namedArchives[targetArchive].has(noteId)) {
                    namedArchives[targetArchive].add(noteId);
                    addedCount++;
                }
            });

            saveArchivedNotes();
            updateArchiveList();
            updateTagFilters();
            selectedNotes.clear();
            updateSelectionUI();
            renderNotes();

            showToast(`Added ${addedCount} notes to "${targetArchive}" archive`, 'success');
        }

        function bulkRemoveFromArchive() {
            if (selectedNotes.size === 0) {
               showToast('Please select some notes first');
                return;
            }

            let removedCount = 0;
            selectedNotes.forEach(noteId => {
                Object.keys(namedArchives).forEach(archiveName => {
                    if (namedArchives[archiveName].has(noteId)) {
                        namedArchives[archiveName].delete(noteId);
                        removedCount++;
                    }
                });
                archivedNotes.delete(noteId);
            });

            saveArchivedNotes();
            updateArchiveList();
            updateTagFilters();
            selectedNotes.clear();
            updateSelectionUI();
            renderNotes();

            showToast(`Removed ${removedCount} notes from all archives`, 'success');
        }

        function updateSelectionUI() {
            const bulkControls = document.getElementById('bulk-controls');
            const selectedCount = document.getElementById('selected-count');
            
            if (selectedNotes.size > 0) {
                bulkControls.classList.remove('hidden');
                selectedCount.textContent = `${selectedNotes.size} notes selected`;
            } else {
                bulkControls.classList.add('hidden');
            }
        }

       async function connectWithPubkey() {
    // CRITICAL FIX: Cancel any existing operations first
    isLoadingCancelled = true;
    
    // Close all active WebSocket connections
    activeWebSockets.forEach(ws => {
        if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
            ws.close(1000, 'New connection started');
        }
    });
    activeWebSockets.clear();
    
    // Cancel any background loading
    if (backgroundLoadingTimeout) {
        clearTimeout(backgroundLoadingTimeout);
        backgroundLoadingTimeout = null;
    }
    
    hideBackgroundLoadingIndicator();
    
    // Wait a moment for cancellation to propagate
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // NOW reset the flag for the new connection
    isLoadingCancelled = false;
    
    // Force fresh fetch
    useIndexedDB = true;
    
    const connectBtn = document.getElementById('connect-btn');
    connectBtn.classList.add('loading');
    connectBtn.disabled = true;
    connectBtn.textContent = 'Connecting...';

    // Check if NostrTools is available
    if (!window.NostrTools) {
        showError('NostrTools library not loaded. Please refresh the page.');
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Load My Notes';
        return;
    }
    
    const raw = document.getElementById('pubkey-input').value;
    const npub = normalizeNpub(raw);

    if (!npub) {
        showError('Please enter your npub');
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Load My Notes';
        return;
    }
    
    if (!npub.startsWith('npub1')) {
        showError('Invalid npub (must start with "npub1")');
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Load My Notes';
        return;
    }

    if (!/^npub1[02-9ac-hj-np-z]+$/.test(npub)) {
        showError('Invalid npub format');
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Load My Notes';
        return;
    }

    const hexPubkey = npubToHex(npub);
    if (!hexPubkey || hexPubkey.length !== 64) {
        showError('Invalid npub format - could not convert to hex');
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Load My Notes';
        return;
    }

    currentPubkey = hexPubkey.toLowerCase();

    // Clear any previous data when switching users
    allNotes = [];
    filteredNotes = [];
    selectedTags.clear();
    currentTag = '';

    // Clear all filters when switching users
    activeQuickFilters.clear();
    document.querySelectorAll('.quick-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    // Clear date filters
    document.getElementById('date-from').value = '';
    document.getElementById('date-to').value = '';

    // Clear search
    document.getElementById('search-input').value = '';
    searchQuery = '';

    // Clear hashtag active states
    document.querySelectorAll('.tag-filter').forEach(btn => {
        btn.classList.remove('active');
    });

    // Reset archive states
    currentArchive = 'default';
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });

    document.getElementById('tag-filters').innerHTML = '<button class="tag-filter active" data-tag="">Loading...</button>';

    // Load archives for this specific user
await loadArchivedNotes();
    updateArchiveList();

    // Save the npub for next time
    localStorage.setItem('nostr-saved-npub', npub);

    document.getElementById('connection-screen').classList.add('hidden');
    document.getElementById('main-app').classList.remove('hidden');

    document.getElementById('pubkey-display').textContent = 
        npub.substring(0, 12) + '...' + npub.substring(npub.length - 8);
    
    updateArchiveList();
    updateTargetArchiveDropdown();
    
    // SIMPLIFIED LOADING LOGIC - No size detection
    let notes;
    let loadedFromChunkCache = false;
    let cachedChunkStats = null;
    
    try {
        showLoading(true);
        updateProgress(0, 'Connecting to relays...');
        updateStatus('Starting fresh load...', true);
        
        // Check if we have stored chunks first
        updateProgress(5, 'Checking for stored data...');
        
        const chunkStorage = new ChunkedNoteStorage(currentPubkey);
        const chunkReady = await chunkStorage.init();
        
        if (chunkReady) {
            const chunkStats = await chunkStorage.getStats();
            
            if (chunkStats && chunkStats.totalNotes > 0) {
                // Load from stored chunks
                loadedFromChunkCache = true;
                cachedChunkStats = chunkStats;
                updateProgress(15, `Loading all ${chunkStats.totalNotes} notes from storage...`);
                updateStatus(`Found stored data: ${chunkStats.totalChunks} chunks, ${chunkStats.totalNotes} notes`);
                
                notes = await loadNotesHybrid(currentPubkey, false);
                showToast(`Loaded ${notes.length} notes from storage instantly!`, 'success');
                updateStatus(`Loaded ${notes.length} notes from ${chunkStats.totalChunks} stored chunks`);
            } else {
                // No stored data - use progressive loading (QUICK FIX)
                updateProgress(15, 'Loading recent notes...');
                updateStatus('Loading recent notes first for faster startup...');
                
                notes = await loadRecentNotesOnly(currentPubkey, 90); // 90 days
                showToast(`Loaded ${notes.length} recent notes. Full history loading in background.`, 'success');
                updateStatus(`Loaded ${notes.length} recent notes - background loading full history...`);
            }
        } else {
            // Storage unavailable - use progressive loading
            updateProgress(15, 'Loading recent notes...');
            updateStatus('Loading recent notes first...');
            
            notes = await loadRecentNotesOnly(currentPubkey, 90);
            showToast(`Loaded ${notes.length} recent notes. Full history loading in background.`, 'success');
        }
        
        updateStatus(`Sorting ${notes.length} notes by date...`);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        allNotes = notes.sort((a, b) => b.created_at - a.created_at);
        
        updateStatus('Updating archives list...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        updateArchiveList();
        updateTargetArchiveDropdown();
        
        updateStatus('Updating tag filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        updateTagFilters();
        
        updateStatus('Applying filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        applyFilters();
        
        updateStatus('Rendering notes...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        renderNotes();
        await verifyCompletenessQuick(currentPubkey);
        
        // Only schedule background loading if we don't have a good cache
if (!loadedFromChunkCache) {
    // No cache - do full background fetch
    const estimatedTotal = notes.length * 5;
    scheduleBackgroundLoading(currentPubkey, { estimatedTotal });
} else if (cachedChunkStats && cachedChunkStats.totalNotes < 1000) {
    // Small cache - probably incomplete, refresh it
    const estimatedTotal = notes.length * 5;
    scheduleBackgroundLoading(currentPubkey, { estimatedTotal });
}
// Check if neon-green theme is active
const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
const checkmark = isNeonGreen ? '' : '✅ ';

// If we loaded from cache with substantial notes (1000+), don't background fetch
// The incremental update in loadNotesHybrid already handled getting new notes
updateStatus(`${checkmark}Successfully loaded ${allNotes.length} notes!`);
    } catch (error) {
        console.error('Error loading notes:', error);
        showError('Failed to load notes: ' + error.message);
    } finally {
        showLoading(false);
        trackLoadTime();
        // Reset button after completion
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Load My Notes';
    }
}
    

        // Add these global variables at the top of your script
let isLoadingCancelled = false;
let activeWebSockets = new Set();
let backgroundLoadingTimeout = null;
let autoRefreshInterval = null; // Auto-refresh every hour

// Update the disconnect function to cancel ongoing operations
function disconnect() {
    // Set cancellation flag FIRST
    isLoadingCancelled = true;
    
    // Cancel any background loading
    if (backgroundLoadingTimeout) {
        clearTimeout(backgroundLoadingTimeout);
        backgroundLoadingTimeout = null;
    }
    
    // Stop auto-refresh interval
    if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
        console.log('Auto-refresh stopped');
    }
    
    // Close all active WebSocket connections
    activeWebSockets.forEach(ws => {
        if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
            ws.close(1000, 'User disconnected');
        }
    });
    activeWebSockets.clear();
    
    // Hide any loading indicators
    hideBackgroundLoadingIndicator();
    showLoading(false);
    
    // Store the old pubkey before clearing
    const oldPubkey = currentPubkey;
    
    // Reset all variables
    currentPubkey = null;
    allNotes = [];
    filteredNotes = [];
    currentArchive = 'default';
    selectedTags.clear();
    currentTag = '';
    selectedNotes.clear();
    searchQuery = '';

    // Clear all filters on disconnect
    activeQuickFilters.clear();
    document.querySelectorAll('.quick-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.getElementById('date-from').value = '';
    document.getElementById('date-to').value = '';
    document.getElementById('search-input').value = '';
    searchQuery = '';
    
    // Clear localStorage cache data only
    localStorage.removeItem('nostr-last-pubkey');
    localStorage.removeItem('nostr-cached-notes'); 
    localStorage.removeItem('nostr-cache-updated-at');
    localStorage.removeItem('nostr-saved-npub');
    
    // Clear the UI immediately
    document.getElementById('notes-container').innerHTML = '';
    document.getElementById('tag-filters').innerHTML = '<button class="tag-filter active" data-tag="">All Notes (0)</button>';
    document.getElementById('notes-count').textContent = '0 notes';
    document.getElementById('archive-list').innerHTML = '<div style="color: #666; font-style: italic; font-size: 13px;">No archives created yet</div>';

    // Clear pagination state
    document.getElementById('load-more-container').classList.add('hidden');
    document.getElementById('pagination-info').textContent = 'Showing 0 of 0 notes';
    
    document.getElementById('main-app').classList.add('hidden');
    document.getElementById('connection-screen').classList.remove('hidden');
    document.getElementById('pubkey-input').value = '';

    hideError();

// Reset cancellation flag immediately after cleanup
    isLoadingCancelled = false;
}

// IndexedDB fallback handler
let useIndexedDB = true;

function disableIndexedDB(error) {
    console.warn('IndexedDB disabled due to error:', error);
    useIndexedDB = false;
    showToast('Storage limitation detected - using memory-only mode', 'warning');
    
    // Log the error type for debugging
    if (error.name === 'QuotaExceededError') {
        showToast('Storage quota exceeded - consider clearing old data', 'warning');
    } else if (error.name === 'InvalidStateError') {
        console.log('Database state error - likely corruption or version mismatch');
    }
}

async function initDatabase(pubkey) {
    if (!useIndexedDB) return null;
    
    try {
        const dbName = 'NostrArchiveDB'; // Single database name
        
        if (db && db.isOpen()) {
            db.close();
        }
        
        db = new Dexie(dbName);
        db.version(1).stores({
            notes: 'id, pubkey, created_at, content, *hashtags, isReply, isRepost, isQuote, kind',
            settings: 'key, value',
            archives: 'name, *noteIds',  // Add if you don't have it
            chunks: 'chunkKey, archiveName, startTime, endTime, *hashtags, noteCount' // For chunked storage
        });
        
        await db.open();
        console.log('✅ Database opened:', dbName);
        return db;
    } catch (error) {
        console.error('❌ Database init failed:', error);
        disableIndexedDB(error);
        return null;
    }
}

function clearLegacyCache(pubkey) {
    try {
        localStorage.removeItem(`nostr-last-pubkey-${pubkey}`);
        localStorage.removeItem(`nostr-cached-notes-${pubkey}`);
        localStorage.removeItem(`nostr-cache-updated-at-${pubkey}`);
    } catch (error) {
        console.warn('Could not clear legacy cache:', error);
    }
}

async function fetchNotesFromRelays(pubkey) {
    const uniqueEventsMap = new Map();
    const globalSeenIds = new Set(); // NEW: Shared Set to track IDs across ALL relays
    const completedRelays = [];
    
    console.log('=== STARTING RELAY FETCH ===');
    
    const relayStatuses = new Map();
    const relayPromises = RELAYS.map(async (relay, index) => {
        const relayName = relay.replace('wss://', '');
        relayStatuses.set(relay, 'connecting');
        
        try {
            updateStatus(`<span class="emoji">🔄</span> ${relayName}: Connecting...`);
            
            const fetchPromise = fetchAllNotesFromRelay(relay, pubkey, (progress, status) => {
                relayStatuses.set(relay, 'fetching');
                const completedCount = Array.from(relayStatuses.values()).filter(s => s === 'completed' || s === 'failed').length;
                updateProgress(
                    20 + ((completedCount / RELAYS.length) * 60), 
                    `${relayName}: ${status} | ${completedCount}/${RELAYS.length} relays done`
                );
            }, globalSeenIds); // Pass the shared Set
            
            const events = await fetchPromise;
            
            // Deduplicate and count new notes
            let newCount = 0;
            events.forEach(event => {
                if (event?.id && !uniqueEventsMap.has(event.id)) {
                    uniqueEventsMap.set(event.id, event);
                    newCount++;
                }
            });
            
            relayStatuses.set(relay, 'completed');
            const completedCount = Array.from(relayStatuses.values()).filter(s => s === 'completed').length;
            updateStatus(`<span class="emoji">✅</span> ${relayName}: ${newCount} new notes (${uniqueEventsMap.size} total unique) (${completedCount}/${RELAYS.length} relays done)`);
            
            completedRelays.push(relay);
            return { relay, events, success: true };
            
        } catch (error) {
            relayStatuses.set(relay, 'failed');
            const failedCount = Array.from(relayStatuses.values()).filter(s => s === 'failed').length;
            updateStatus(`❌ ${relayName}: ${error.message} (${failedCount} failed)`);
            return { relay, events: [], success: false, error: error.message };
        }
    });
    
    await Promise.allSettled(relayPromises);
    
    return Array.from(uniqueEventsMap.values());
}

// ==================== DEEP SCAN SYSTEM ====================

// SOLUTION 1: Track what we've loaded and verify completeness
class LoadingTracker {
    constructor(pubkey) {
        this.pubkey = pubkey;
        this.relayStats = new Map();
        this.totalUnique = 0;
        this.oldestTimestamp = null;
        this.newestTimestamp = null;
    }
    
    recordRelayResult(relayUrl, notesCount, oldestNote, newestNote, completed) {
        this.relayStats.set(relayUrl, {
            count: notesCount,
            oldest: oldestNote,
            newest: newestNote,
            completed: completed
        });
    }
    
    getCompletionReport() {
        const totalRelays = this.relayStats.size;
        const completedRelays = Array.from(this.relayStats.values())
            .filter(stat => stat.completed).length;
        
        const relayDetails = Array.from(this.relayStats.entries()).map(([url, stat]) => ({
            relay: url.replace('wss://', ''),
            notes: stat.count,
            completed: stat.completed,
            timespan: stat.oldest && stat.newest ? 
                `${new Date(stat.oldest * 1000).toLocaleDateString()} - ${new Date(stat.newest * 1000).toLocaleDateString()}` : 
                'unknown'
        }));
        
        return {
            totalRelays,
            completedRelays,
            totalUnique: this.totalUnique,
            relayDetails,
            confidence: (completedRelays / totalRelays) * 100
        };
    }
}

// SOLUTION 2: Enhanced relay fetching with better error handling AND TIMEOUT
async function fetchAllNotesFromRelayEnhanced(relayUrl, pubkey, progressCallback, globalSeenIds = null) {
    const allEvents = [];
    let until = null;
    let batchNumber = 1;
    const batchSize = 1000;
    let consecutiveEmptyBatches = 0;
    const MAX_EMPTY_BATCHES = 3;
    const MAX_RELAY_TIME = 0; // No timeout for deep scan - let it complete naturally
    
    const startTime = Date.now();
    
    while (true) {
        // Check if we've exceeded total relay time (only if timeout is set)
        if (MAX_RELAY_TIME > 0 && Date.now() - startTime > MAX_RELAY_TIME) {
            console.warn(`[${relayUrl}] Timeout after ${MAX_RELAY_TIME / 1000}s - stopping with ${allEvents.length} notes`);
            progressCallback(100, `timeout (${allEvents.length} notes)`);
            return {
                events: allEvents,
                completed: false,
                batchesProcessed: batchNumber,
                timedOut: true
            };
        }
        
        progressCallback(
            Math.min(95, (batchNumber - 1) * 15), 
            `batch ${batchNumber} (${allEvents.length} notes)`
        );
        
        try {
            const batchEvents = await fetchBatchFromRelay(relayUrl, pubkey, until, batchSize);
            
            console.log(`[${relayUrl}] Batch ${batchNumber}: ${batchEvents.length} events (total: ${allEvents.length})`);
            
            if (batchEvents.length === 0) {
                consecutiveEmptyBatches++;
                console.log(`[${relayUrl}] Empty batch ${consecutiveEmptyBatches}/${MAX_EMPTY_BATCHES}`);
                
                if (consecutiveEmptyBatches >= MAX_EMPTY_BATCHES) {
                    console.log(`[${relayUrl}] Reached end (${MAX_EMPTY_BATCHES} empty batches)`);
                    break;
                }
                
                if (until) {
                    until = until - (30 * 24 * 60 * 60);
                } else {
                    break;
                }
                
                batchNumber++;
                await new Promise(resolve => setTimeout(resolve, 500));
                continue;
            }
            
            consecutiveEmptyBatches = 0;

// Check duplicates if we have a global map
let newCount = 0;
if (globalSeenIds) {
    // Cross-relay deduplication - check against ALL relays
    batchEvents.forEach(event => {
        if (event?.id && !globalSeenIds.has(event.id)) {
            globalSeenIds.add(event.id);
            allEvents.push(event);
            newCount++;
        }
    });
    
    // Stop if this batch is >95% duplicates after batch 10
    // Track consecutive high-duplicate batches
// Add this at the top of the function with other variables
let consecutiveHighDuplicateBatches = 0;

// Then use it without 'this.'
consecutiveHighDuplicateBatches++;
// and
consecutiveHighDuplicateBatches = 0;

if (batchNumber > 20 && batchEvents.length > 0) {  // Changed from 10 to 20
    const duplicateRate = ((batchEvents.length - newCount) / batchEvents.length) * 100;
    
    if (duplicateRate > 95) {  // Changed from 98 to 95
        this.consecutiveHighDuplicateBatches++;
        console.log(`[${relayUrl}] High duplicate rate: ${duplicateRate.toFixed(1)}% (${newCount}/${batchEvents.length} new) - consecutive: ${this.consecutiveHighDuplicateBatches}/25`);  // Update display
        
        // Only stop after 25 consecutive high-duplicate batches
        if (this.consecutiveHighDuplicateBatches >= 25) {  // Changed from 10 to 25
            console.log(`[${relayUrl}] Stopping: 5 consecutive batches with >95% duplicates. Total fetched: ${allEvents.length}`);
            break;
        }
    } else {
        // Reset counter if we find a good batch
        this.consecutiveHighDuplicateBatches = 0;
    }
}
} else {
    // No global map - use old behavior (add everything)
    allEvents.push(...batchEvents);
}

const oldestEvent = batchEvents[batchEvents.length - 1];
            if (!oldestEvent || !oldestEvent.created_at) {
                console.warn(`[${relayUrl}] Invalid event structure - stopping`);
                break;
            }
            
            until = oldestEvent.created_at - 1;
            batchNumber++;
            
            // Rate limiting - 200ms delay between batches for stability
            await new Promise(resolve => setTimeout(resolve, 250));
            
            if (batchNumber > 500) {
                console.warn(`[${relayUrl}] Safety limit: 500 batches (${allEvents.length} notes)`);
                break;
            }
            
        } catch (error) {
            console.error(`[${relayUrl}] Batch ${batchNumber} error:`, error);
            
            if (batchNumber < 5) {
                await new Promise(resolve => setTimeout(resolve, 2000));
                continue;
            }
            break;
        }
    }
    
    progressCallback(100, `complete (${allEvents.length} notes)`);
    
    return {
        events: allEvents,
        completed: consecutiveEmptyBatches >= MAX_EMPTY_BATCHES,
        batchesProcessed: batchNumber,
        timedOut: false
    };
}

// SOLUTION 3: Complete relay scan
async function fetchNotesFromRelaysComplete(pubkey) {
    const tracker = new LoadingTracker(pubkey);
    const uniqueEventsMap = new Map();
    const globalSeenIds = new Set();
    
    // Check if neon-green theme is active
    const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
    
    // Emoji helpers - return empty string for neon-green
    const rocket = isNeonGreen ? '' : '🚀 ';
    const satellite = isNeonGreen ? '' : '📡 ';
    const checkmark = isNeonGreen ? '' : '✅ ';
    const cross = isNeonGreen ? '' : '❌ ';
    
    updateStatus(`${rocket}Starting complete relay scan...`);
    updateProgress(5);
    
    const primaryRelays = RELAYS.slice(0, 8);
    updateStatus(`Phase 1: Fetching from ${primaryRelays.length} primary relays in parallel...`);
    
    let completedPrimaryRelays = 0;
    const primaryPromises = primaryRelays.map(async (relay) => {
        const relayName = relay.replace('wss://', '');
        try {
            updateStatus(`${satellite}${relayName}: Starting...`);
            
            const result = await fetchAllNotesFromRelayEnhanced(relay, pubkey, (progress, status) => {
                updateStatus(`${satellite}${relayName}: ${status}`);
            }, globalSeenIds);
        
        let newCount = 0;
        let duplicateCount = 0;
        
        result.events.forEach(event => {
            if (event?.id && !uniqueEventsMap.has(event.id)) {
                uniqueEventsMap.set(event.id, event);
                newCount++;
            } else if (event?.id) {
                duplicateCount++;
            }
        });
        
        const oldest = result.events.length > 0 ? 
            result.events[result.events.length - 1].created_at : null;
        const newest = result.events.length > 0 ? 
            result.events[0].created_at : null;
        
        tracker.recordRelayResult(relay, newCount, oldest, newest, result.completed);
        
        const duplicateRate = result.events.length > 0 ? 
            (duplicateCount / result.events.length) * 100 : 0;
        
        updateStatus(`${checkmark}${relayName}: ${newCount} unique notes, ${duplicateCount} duplicates (${duplicateRate.toFixed(1)}% duplicate rate) - Total: ${uniqueEventsMap.size}`);
        
        // Update progress: Phase 1 is 5-60%
        completedPrimaryRelays++;
        const phase1Progress = 5 + (completedPrimaryRelays / primaryRelays.length) * 55;
        updateProgress(Math.floor(phase1Progress));
        
        return { relay, success: true, newCount, duplicateCount };
        
    } catch (error) {
        updateStatus(`${cross}${relayName}: ${error.message}`);
        tracker.recordRelayResult(relay, 0, null, null, false);
        completedPrimaryRelays++;
        const phase1Progress = 5 + (completedPrimaryRelays / primaryRelays.length) * 55;
        updateProgress(Math.floor(phase1Progress));
        return { relay, success: false, newCount: 0 };
    }
});
    
    await Promise.all(primaryPromises);
    
    const primaryCount = uniqueEventsMap.size;
    updateStatus(`Phase 1 complete: ${primaryCount} unique notes from primary relays`);
    updateProgress(60);
    
    const secondaryRelays = RELAYS.slice(5);
    if (secondaryRelays.length > 0) {
        updateStatus(`Phase 2: Checking ${secondaryRelays.length} additional relays sequentially...`);
        
        let completedSecondaryRelays = 0;
        for (const relay of secondaryRelays) {
            const relayName = relay.replace('wss://', '');
            
            try {
                updateStatus(`${satellite}${relayName}: Checking for missing notes...`);
                
                const result = await fetchAllNotesFromRelayEnhanced(relay, pubkey, (progress, status) => {
                    updateStatus(`${satellite}${relayName}: ${status}`);
                }, globalSeenIds);
                
                let newCount = 0;
                result.events.forEach(event => {
                    if (event?.id && !uniqueEventsMap.has(event.id)) {
                        uniqueEventsMap.set(event.id, event);
                        newCount++;
                    }
                });
                
                const oldest = result.events.length > 0 ? 
                    result.events[result.events.length - 1].created_at : null;
                const newest = result.events.length > 0 ? 
                    result.events[0].created_at : null;
                
                tracker.recordRelayResult(relay, newCount, oldest, newest, result.completed);
                
                if (newCount > 0) {
                    updateStatus(`${checkmark}${relayName}: Found ${newCount} missing notes! (${uniqueEventsMap.size} total)`);
                } else {
                    updateStatus(`${checkmark}${relayName}: No new notes (${uniqueEventsMap.size} total)`);
                }
                
                // Update progress: Phase 2 is 60-90%
                completedSecondaryRelays++;
                const phase2Progress = 60 + (completedSecondaryRelays / secondaryRelays.length) * 30;
                updateProgress(Math.floor(phase2Progress));
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
            } catch (error) {
                updateStatus(`${cross}${relayName}: ${error.message}`);
                tracker.recordRelayResult(relay, 0, null, null, false);
                completedSecondaryRelays++;
                const phase2Progress = 60 + (completedSecondaryRelays / secondaryRelays.length) * 30;
                updateProgress(Math.floor(phase2Progress));
            }
        }
    }
    
    tracker.totalUnique = uniqueEventsMap.size;
    const report = tracker.getCompletionReport();
    
    updateStatus('=== LOADING COMPLETE ===');
    updateStatus(`Total unique notes: ${report.totalUnique}`);
    updateStatus(`Relays completed: ${report.completedRelays}/${report.totalRelays}`);
    updateStatus(`Confidence level: ${report.confidence.toFixed(1)}%`);
    updateProgress(90);
    
    console.table(report.relayDetails);
    
    return {
        events: Array.from(uniqueEventsMap.values()),
        report: report
    };
}

// SOLUTION 4: Deep Scan function
async function performDeepScan() {
    if (!currentPubkey) {
        showToast('No user connected', 'error');
        return;
    }
    
    if (!confirm('Deep scan will thoroughly search ALL relays for every note. This may take 2-5 minutes for large accounts. Continue?')) {
        return;
    }
    
    // Disable Deep Scan button and update text
    const deepScanBtn = document.getElementById('deep-scan-btn');
    if (deepScanBtn) {
        deepScanBtn.disabled = true;
        deepScanBtn.textContent = 'Scanning...';
    }
    
    try {
        showLoading(true);
        updateStatus('Starting deep scan...', true);
        updateProgress(0); // Start at 0%
        
        const result = await fetchNotesFromRelaysComplete(currentPubkey);
        
        updateStatus('Sorting notes...');
        updateProgress(95); // Almost done
        allNotes = result.events.sort((a, b) => b.created_at - a.created_at);
        
        const chunkStorage = new ChunkedNoteStorage(currentPubkey);
        const chunkReady = await chunkStorage.init();
        
        if (chunkReady) {
            await chunkStorage.storeNotesInChunks(allNotes);
            updateStatus('Stored notes in chunks');
        }
        
        updateTagFilters();
        applyFilters();
        renderNotes();
        
        updateProgress(100); // Complete
        
        // Show completion toast
        showToast(`Deep scan complete: ${allNotes.length} notes loaded (${result.report.confidence.toFixed(0)}% confidence)`, 'success', 5000);
        
        // Hide the warning toast if it's still showing
        document.querySelectorAll('.toast.warning').forEach(toast => {
            toast.classList.remove('show');
            setTimeout(() => {
                if (document.body.contains(toast)) {
                    document.body.removeChild(toast);
                }
            }, 300);
        });
        
    } catch (error) {
        console.error('Deep scan error:', error);
        showToast('Deep scan failed: ' + error.message, 'error');
    } finally {
        showLoading(false);
        
        // Re-enable Deep Scan button and restore text
        if (deepScanBtn) {
            deepScanBtn.disabled = false;
            deepScanBtn.textContent = 'Deep Scan';
        }
    }
}

async function verifyCompletenessQuick(pubkey) {
    // Quick check: ask relays for a COUNT (if they support it)
    // Most relays don't support COUNT, so this is a rough estimate
    
    try {
        const samples = await Promise.all(
            RELAYS.slice(0, 3).map(async (relay) => {
                try {
                    const recent = await getRecentNoteCount(relay, pubkey, 30);
                    return recent;
                } catch {
                    return 0;
                }
            })
        );
        
        const maxRecent = Math.max(...samples);
        
        // FIX: Count our TOTAL notes, not just recent ones
        const totalNotesWeHave = allNotes.length;
        
        // Only show warning if the discrepancy is significant
        // AND we have a reasonable sample from relays
        if (maxRecent > totalNotesWeHave + 50 && maxRecent > 100) {
            showDismissibleBanner(
                `⚠️ Possible missing notes: You have ${totalNotesWeHave} total notes, but relays report ~${maxRecent} recent notes. Try "Deep Scan".`,
                'warning'
            );
            return false;
        }
        
        return true;
    } catch (error) {
        console.error('Verification check failed:', error);
        return true; // Don't block on verification errors
    }
}

// ==================== END DEEP SCAN SYSTEM ====================

// NEW: Memory-efficient deduplication for image-heavy accounts
async function memoryEfficientDeduplication(allEvents) {
    console.log(`Starting deduplication of ${allEvents.length} events`);
    
    const uniqueEventsMap = new Map();
    const chunkSize = 2000; // Process in smaller chunks for image-heavy accounts
    let duplicatesFound = 0;
    
    for (let startIndex = 0; startIndex < allEvents.length; startIndex += chunkSize) {
        const endIndex = Math.min(startIndex + chunkSize, allEvents.length);
        const chunk = allEvents.slice(startIndex, endIndex);
        
        console.log(`Processing chunk ${Math.floor(startIndex/chunkSize) + 1}: events ${startIndex}-${endIndex}`);
        
        chunk.forEach(event => {
            if (!event?.id) return;
            
            const existing = uniqueEventsMap.get(event.id);
            if (!existing) {
                uniqueEventsMap.set(event.id, event);
            } else {
                duplicatesFound++;
                // Keep the event with more complete data
                if ((event.tags?.length || 0) > (existing.tags?.length || 0) || 
                    event.content.length > existing.content.length) {
                    uniqueEventsMap.set(event.id, event);
                }
            }
        });
        
        // Update progress and yield control
        const progress = 80 + ((endIndex / allEvents.length) * 15);
        updateProgress(progress, `Deduplicating: ${endIndex}/${allEvents.length} processed (${duplicatesFound} duplicates found)`);
        
        // Yield control to prevent browser freeze
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Memory cleanup
        if (startIndex % 10000 === 0 && performance.memory) {
            const memoryMB = performance.memory.usedJSHeapSize / 1024 / 1024;
            console.log(`Memory usage: ${memoryMB.toFixed(1)} MB`);
            if (memoryMB > 500) {
                console.log('High memory usage detected, forcing garbage collection pause');
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
    }
    
    const uniqueEvents = Array.from(uniqueEventsMap.values());
console.log(`=== DEDUPLICATION COMPLETE: ${uniqueEvents.length} unique notes ===`);
updateStatus(`✅ Found ${uniqueEvents.length} unique notes across all relays`);

return uniqueEvents;
}

async function fetchNotesFromRelaysSince(pubkey, sinceTimestamp) {
    const allEvents = [];
    const completedRelays = [];
    
    updateStatus('🔄 Checking relays for new notes...');
    
    const relayPromises = RELAYS.map(async (relay, index) => {
        const relayName = relay.replace('wss://', '');
        
        try {
            // Only fetch notes newer than our newest stored note
            const newNotes = await fetchNewNotesFromRelay(relay, pubkey, sinceTimestamp);
            
            updateStatus(`✅ ${relayName}: ${newNotes.length} new notes`);
            return { relay, events: newNotes, success: true };
            
        } catch (error) {
            updateStatus(`❌ ${relayName}: ${error.message}`);
            return { relay, events: [], success: false };
        }
    });
    
    const results = await Promise.allSettled(relayPromises);
    
    // Collect new events
    results.forEach((result) => {
        if (result.status === 'fulfilled' && result.value.success) {
            allEvents.push(...result.value.events);
        }
    });
    
    // Simple deduplication for new notes
    const uniqueEvents = [];
    const seenIds = new Set();
    
    allEvents.forEach(event => {
        if (event.id && !seenIds.has(event.id)) {
            seenIds.add(event.id);
            uniqueEvents.push(event);
        }
    });
    
    return uniqueEvents;
}

async function fetchNewNotesFromRelay(relayUrl, pubkey, sinceTimestamp) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        const events = [];
        let timeoutId;
        
        ws.onopen = function() {
            const filter = {
    kinds: [1, 6], // Add kind 6
    authors: [pubkey],
    since: sinceTimestamp + 1,
    limit: 1000
};
            
            const subscription = ['REQ', 'incremental-' + Date.now(), filter];
            ws.send(JSON.stringify(subscription));
            
            timeoutId = setTimeout(() => {
                ws.close();
                resolve(events);
            }, 10000); // 10 second timeout
        };
        
        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const [type, subId, eventData] = message;
                
                if (type === 'EVENT') {
                    const note = processNote(eventData);
                    if (note) {
                        events.push(note);
                    }
                } else if (type === 'EOSE') {
                    clearTimeout(timeoutId);
                    ws.close();
                    resolve(events);
                }
            } catch (error) {
                console.error('Error parsing message:', error);
            }
        };
        
        ws.onerror = function() {
            clearTimeout(timeoutId);
            reject(new Error('Connection failed'));
        };
        
        ws.onclose = function() {
            clearTimeout(timeoutId);
            resolve(events);
        };
    });
}

async function fetchAllNotesFromRelay(relayUrl, pubkey, progressCallback, globalSeenIds = null) {
    const allEvents = [];
    const seenIds = new Set(); // Track duplicates within this relay
    let until = null;
    let batchNumber = 1;
    const batchSize = 1000;
    let consecutiveEmptyBatches = 0;
    let consecutiveHighDuplicateBatches = 0; // Track consecutive high-duplicate batches
    const MAX_EMPTY_BATCHES = 3;
    
    while (true) {
        progressCallback(
            Math.min(95, (batchNumber - 1) * 15), 
            `batch ${batchNumber} (${allEvents.length} notes)`
        );
        
        try {
            const batchEvents = await fetchBatchFromRelay(relayUrl, pubkey, until, batchSize);
            
            console.log(`[${relayUrl}] Batch ${batchNumber}: ${batchEvents.length} events (total: ${allEvents.length})`);
            
            // Check if we got events
            if (batchEvents.length === 0) {
                consecutiveEmptyBatches++;
                console.log(`[${relayUrl}] Empty batch ${consecutiveEmptyBatches}/${MAX_EMPTY_BATCHES}`);
                
                if (consecutiveEmptyBatches >= MAX_EMPTY_BATCHES) {
                    console.log(`[${relayUrl}] Reached end (${MAX_EMPTY_BATCHES} empty batches)`);
                    break;
                }
                
                // Try going back further in time
                if (until) {
                    until = until - (30 * 24 * 60 * 60); // Go back 30 days
                } else {
                    break;
                }
                
                batchNumber++;
                await new Promise(resolve => setTimeout(resolve, 500));
                continue;
            }
            
            // Reset empty batch counter when we get results
            consecutiveEmptyBatches = 0;
            
            // NEW: Check against global map if provided, otherwise use local seenIds
            let newInBatch = 0;
            
            if (globalSeenIds) {
                // Cross-relay deduplication
                batchEvents.forEach(event => {
                    if (event?.id && !globalSeenIds.has(event.id)) {
                        globalSeenIds.add(event.id);
                        seenIds.add(event.id);
                        allEvents.push(event);
                        newInBatch++;
                    }
                });
                
                // Stop if this batch is >95% duplicates after batch 10
                if (batchNumber > 20 && batchEvents.length > 0) {
                    const duplicateRate = ((batchEvents.length - newInBatch) / batchEvents.length) * 100;
                    
                    if (duplicateRate > 98) {
                        consecutiveHighDuplicateBatches++;
                        console.log(`[${relayUrl}] High duplicate rate: ${duplicateRate.toFixed(1)}% (${newInBatch}/${batchEvents.length} new) - consecutive: ${consecutiveHighDuplicateBatches}/10`);
                        
                        // Only stop after 10 consecutive high-duplicate batches
                        if (consecutiveHighDuplicateBatches >= 10) {
                            console.log(`[${relayUrl}] Stopping: 10 consecutive batches with >95% duplicates. Total fetched: ${allEvents.length}`);
                            break;
                        }
                    } else {
                        // Reset counter if we find a good batch
                        consecutiveHighDuplicateBatches = 0;
                    }
                }
            } else {
                // Local deduplication only (within this relay)
                batchEvents.forEach(event => {
                    if (event?.id && !seenIds.has(event.id)) {
                        seenIds.add(event.id);
                        allEvents.push(event);
                        newInBatch++;
                    }
                });
                
                // Early termination if mostly duplicates within this relay
                if (batchNumber > 10 && newInBatch < batchEvents.length * 0.1) {
                    console.log(`[${relayUrl}] Low new event rate (${newInBatch}/${batchEvents.length} new), stopping early at ${allEvents.length} notes`);
                    break;
                }
            }
            
            // Safety check: ensure we have a valid event before accessing its timestamp
            const oldestEvent = batchEvents[batchEvents.length - 1];
            if (!oldestEvent || !oldestEvent.created_at) {
                console.warn(`[${relayUrl}] Invalid event structure in batch ${batchNumber} - stopping`);
                break;
            }
            
            until = oldestEvent.created_at - 1;
            batchNumber++;
            
            // Rate limiting - 100ms delay between batches for speed
            await new Promise(resolve => setTimeout(resolve, 250));
            
            // Safety check - prevent infinite loops
            if (batchNumber > 500) {
                console.warn(`[${relayUrl}] Safety limit: 500 batches reached (${allEvents.length} notes)`);
                break;
            }
            
        } catch (error) {
            console.error(`Error fetching batch ${batchNumber} from ${relayUrl}:`, error);
            break;
        }
    }
    
    progressCallback(100, `complete (${allEvents.length} notes)`);
    return allEvents;
}
   
async function loadNotesHybrid(pubkey, silent = false) {
    try {
        // Initialize chunked storage
        const chunkStorage = new ChunkedNoteStorage(pubkey);
        const chunkStorageReady = await chunkStorage.init();
        
        if (!chunkStorageReady) {
            if (!silent) updateStatus('Chunked storage unavailable, using legacy system...');
            return await fetchNotesFromRelays(pubkey);
        }
        
        // Check if we have chunked data
        const chunkStats = await chunkStorage.getStats();
        
        if (chunkStats && chunkStats.totalNotes > 0) {
            if (!silent) {
                updateStatus(`Found chunked storage: ${chunkStats.totalChunks} chunks, ${chunkStats.totalNotes} notes`);
                updateStatus(`Loading all notes from chunked storage...`);
            }
            
            // Load all notes from chunks
            const cachedNotes = await chunkStorage.loadAllNotes();
            
            if (cachedNotes.length > 0) {
                if (!silent) updateStatus(`Loaded ${cachedNotes.length} notes from ${chunkStats.totalChunks} chunks`);
                
                // 🆕 INCREMENTAL UPDATE: Check for new notes since last sync
                const lastSyncTime = await chunkStorage.getLastSyncTime();
                
                if (lastSyncTime) {
                    const hoursSinceSync = (Date.now() - lastSyncTime) / (1000 * 60 * 60);
                    
                    if (hoursSinceSync > 1) { // Only check if it's been more than 1 hour
                        if (!silent) updateStatus(`Last synced ${hoursSinceSync.toFixed(1)} hours ago - checking for new notes...`);
                        
                        // Get newest timestamp from cached notes
                        const newestTimestamp = Math.max(...cachedNotes.map(n => n.created_at));
                        
                        // Fetch only NEW notes
                        const newNotes = await fetchNotesFromRelaysSince(pubkey, newestTimestamp);
                        
                        if (newNotes.length > 0) {
                            if (!silent) updateStatus(`Found ${newNotes.length} new notes since last sync!`);
                            
                            // Merge and deduplicate
                            const mergedNotes = [...cachedNotes, ...newNotes];
                            const uniqueNotes = Array.from(
                                new Map(mergedNotes.map(n => [n.id, n])).values()
                            );
                            
                            // Update chunk storage with new notes
                            await chunkStorage.storeNotesInChunks(uniqueNotes);
                            await chunkStorage.storeLastSyncTime();
                            
                            if (!silent) updateStatus(`Updated storage with ${newNotes.length} new notes`);
                            
                            return uniqueNotes;
                        } else {
                            if (!silent) updateStatus('No new notes found');
                            await chunkStorage.storeLastSyncTime(); // Update sync time anyway
                        }
                    }
                }
                
                return cachedNotes;
            }
        }
        
        // No valid chunked data, fetch fresh and store in chunks
        if (!silent) updateStatus('No chunk data found, fetching fresh and storing in chunks...');
        
        const freshNotes = await fetchNotesFromRelays(pubkey);
        
        if (freshNotes.length > 0) {
            // Store in chunked format
            const stored = await chunkStorage.storeNotesInChunks(freshNotes);
            
            if (stored && !silent) {
                await chunkStorage.storeLastSyncTime();
                const newStats = await chunkStorage.getStats();
                updateStatus(`Stored ${freshNotes.length} notes in ${newStats.totalChunks} chunks`);
            }
        }
        
        return freshNotes;
        
    } catch (error) {
        console.error('Chunked loading error:', error);
        if (!silent) updateStatus('Chunked loading failed, using fallback...');
        return await fetchNotesFromRelays(pubkey);
    }
}

// PRODUCTION FAILSAFE SYSTEM

async function checkDatabaseHealth(pubkey, silent = false) {
    try {
        if (!db || !db.isOpen()) {
            if (!silent) updateStatus('Database connection failed');
            return false;
        }
        
        // Test basic database operations
        const testCount = await db.notes.count();
        const testSettings = await db.settings.toArray();
        
        // Check if we can read a sample note
        if (testCount > 0) {
            const sampleNote = await db.notes.limit(1).first();
            
            // Basic integrity checks
            if (!sampleNote) {
                if (!silent) updateStatus('Database count/data mismatch detected');
                return false;
            }
            
            if (!sampleNote.id || sampleNote.content === undefined || !sampleNote.created_at) {
                if (!silent) updateStatus('Invalid note structure detected');
                return false;
            }
        }
        
        // Test write capability
        try {
            await db.settings.put({ key: 'health_check', value: Date.now() });
            await db.settings.delete('health_check');
        } catch (writeError) {
            if (!silent) updateStatus('Database write test failed');
            return false;
        }
        
        return true;
    } catch (error) {
        console.error('Database health check failed:', error);
        return false;
    }
}

function validateNotesData(notes, expectedCount) {
    // Check we got reasonable amount of data
    const minExpected = Math.max(Math.min(expectedCount * 0.8, expectedCount - 100), 20);
    if (notes.length < minExpected) {
        return { 
            isValid: false, 
            reason: `Got ${notes.length} notes, expected at least ${minExpected}` 
        };
    }
    
    // Check data structure integrity
    const validNotes = notes.filter(note => 
        note && 
        note.id && 
        typeof note.id === 'string' &&
        note.content !== undefined && 
        note.created_at && 
        typeof note.created_at === 'number' &&
        Array.isArray(note.hashtags)
    );
    
    const validRatio = validNotes.length / notes.length;
    if (validRatio < 0.95) {
        return { 
            isValid: false, 
            reason: `${Math.round((1-validRatio)*100)}% of notes have invalid structure` 
        };
    }
    
    // Check for duplicate IDs (corruption indicator)
    const uniqueIds = new Set(validNotes.map(note => note.id));
    if (uniqueIds.size < validNotes.length * 0.98) {
        return { 
            isValid: false, 
            reason: 'Duplicate note IDs detected (data corruption)' 
        };
    }
    
    // Check timestamp sanity (notes can't be from the future)
    const now = Math.floor(Date.now() / 1000);
    const futureNotes = validNotes.filter(note => note.created_at > now + 3600);
    if (futureNotes.length > validNotes.length * 0.01) {
        return { 
            isValid: false, 
            reason: 'Invalid timestamps detected' 
        };
    }
    
    return { isValid: true, reason: 'Data validation passed' };
}

// Add this function to validate and fix note classifications when loading
function validateNoteClassification(note) {
    // Ensure classification fields exist and are boolean
    const validatedNote = {
        ...note,
        isReply: Boolean(note.isReply),
        isRepost: Boolean(note.isRepost),
        isQuote: Boolean(note.isQuote),
        kind: note.kind || 1
    };
    
    // If classifications seem wrong, re-process the note
    if (validatedNote.kind === 6 && !validatedNote.isRepost) {
        validatedNote.isRepost = true;
        validatedNote.isReply = false;
        validatedNote.isQuote = false;
    }
    
    return validatedNote;
}

async function repairDatabase(pubkey) {
    try {
        console.log('Repairing database for', pubkey.substring(0, 8) + '...');
        
        // Close current connection
        if (db && db.isOpen()) {
            await db.close();
        }
        
        // Delete corrupted database
        const dbName = `nostr-notes-${pubkey}`;
        await new Promise((resolve) => {
            const deleteReq = indexedDB.deleteDatabase(dbName);
            deleteReq.onsuccess = () => {
                console.log('Corrupted database deleted successfully');
                resolve();
            };
            deleteReq.onerror = () => {
                console.log('Database deletion failed, continuing anyway');
                resolve();
            };
            deleteReq.onblocked = () => {
                console.log('Database deletion blocked, forcing continuation');
                setTimeout(resolve, 2000);
            };
            // Safety timeout
            setTimeout(resolve, 5000);
        });
        
        // Reinitialize fresh database
        db = null;
        await initDatabase(pubkey);
        
        console.log('Database repair completed successfully');
        return true;
    } catch (error) {
        console.error('Database repair failed:', error);
        disableIndexedDB(error);
        return false;
    }
}

// Chunked Storage System for Phase 2
class ChunkedNoteStorage {
    constructor(pubkey) {
        this.pubkey = pubkey;
        this.dbName = `nostr-chunks-${pubkey}`;
        this.db = null;
    }
    
    async init() {
        try {
            this.db = new Dexie(this.dbName);
            this.db.version(1).stores({
                chunks: 'chunkKey, notes, metadata, created_at, updated_at',
                indices: 'type, data'
            });
            
            await this.db.open();
            return true;
        } catch (error) {
            console.error('Chunked storage init failed:', error);
            return false;
        }
    }
    
    // Generate chunk key from timestamp (YYYY-MM format)
    getChunkKey(timestamp) {
        const date = new Date(timestamp * 1000);
        return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
    }
    
    // Organize notes into monthly chunks
    // In the ChunkedNoteStorage class, update the organizeNotesIntoChunks method
organizeNotesIntoChunks(notes) {
    const chunks = new Map();
    
    notes.forEach(note => {
        const chunkKey = this.getChunkKey(note.created_at);
        
        if (!chunks.has(chunkKey)) {
            chunks.set(chunkKey, {
                chunkKey,
                notes: [],
                metadata: {
                    startDate: note.created_at,
                    endDate: note.created_at,
                    noteCount: 0,
                    hasReplies: false,
                    hasReposts: false,  // ADD THIS
                    hasQuotes: false,   // ADD THIS
                    hashtags: new Set()
                }
            });
        }
        
        const chunk = chunks.get(chunkKey);
        // IMPORTANT: Store the complete note object with all classifications
        chunk.notes.push({
            ...note,
            isReply: note.isReply || false,
            isRepost: note.isRepost || false,
            isQuote: note.isQuote || false
        });
        
        chunk.metadata.noteCount++;
        chunk.metadata.startDate = Math.min(chunk.metadata.startDate, note.created_at);
        chunk.metadata.endDate = Math.max(chunk.metadata.endDate, note.created_at);
        
        if (note.isReply) {
            chunk.metadata.hasReplies = true;
        }
        if (note.isRepost) {
            chunk.metadata.hasReposts = true;
        }
        if (note.isQuote) {
            chunk.metadata.hasQuotes = true;
        }
        
        if (note.hashtags) {
            note.hashtags.forEach(tag => chunk.metadata.hashtags.add(tag));
        }
    });
    
    // Convert hashtag Sets to arrays for storage
    chunks.forEach(chunk => {
        chunk.metadata.hashtags = Array.from(chunk.metadata.hashtags);
    });
    
    return Array.from(chunks.values());
}
    
    // Store notes in chunks
    async storeNotesInChunks(notes) {
        if (!this.db) return false;
        
        try {
            const chunks = this.organizeNotesIntoChunks(notes);
            
            // Clear existing chunks
            await this.db.chunks.clear();
            await this.db.indices.clear();
            
            // Store chunks
            for (const chunk of chunks) {
                await this.db.chunks.put({
                    ...chunk,
                    created_at: Date.now(),
                    updated_at: Date.now()
                });
            }
            
            // Build search indices
            await this.buildSearchIndices(chunks);
            
            console.log(`Stored ${chunks.length} chunks covering ${notes.length} notes`);
            return true;
            
        } catch (error) {
            console.error('Error storing chunks:', error);
            return false;
        }
    }
    
    // Build search indices for faster filtering
    async buildSearchIndices(chunks) {
        const hashtagIndex = new Map();
        const dateIndex = new Map();
        
        chunks.forEach(chunk => {
            // Hashtag index
            chunk.metadata.hashtags.forEach(tag => {
                if (!hashtagIndex.has(tag)) {
                    hashtagIndex.set(tag, []);
                }
                hashtagIndex.get(tag).push(chunk.chunkKey);
            });
            
            // Date index
            dateIndex.set(chunk.chunkKey, {
                startDate: chunk.metadata.startDate,
                endDate: chunk.metadata.endDate,
                noteCount: chunk.metadata.noteCount
            });
        });
        
        // Store indices
        await this.db.indices.put({
            type: 'hashtags',
            data: Object.fromEntries(hashtagIndex)
        });
        
        await this.db.indices.put({
            type: 'dates',
            data: Object.fromEntries(dateIndex)
        });
    }
    
    // Load specific chunks
    async loadChunks(chunkKeys) {
        if (!this.db) return [];
        
        try {
            const chunks = await this.db.chunks
                .where('chunkKey')
                .anyOf(chunkKeys)
                .toArray();
            
            // Flatten notes from all chunks
            const allNotes = [];
            chunks.forEach(chunk => {
                allNotes.push(...chunk.notes);
            });
            
            return allNotes.sort((a, b) => b.created_at - a.created_at);
            
        } catch (error) {
            console.error('Error loading chunks:', error);
            return [];
        }
    }
    
    // Load all notes from all chunks
    async loadAllNotes() {
        if (!this.db) return [];
        
        try {
            const allChunks = await this.db.chunks.toArray();
            const allNotes = [];
            
            allChunks.forEach(chunk => {
                allNotes.push(...chunk.notes);
            });
            
            return allNotes.sort((a, b) => b.created_at - a.created_at);
            
        } catch (error) {
            console.error('Error loading all notes from chunks:', error);
            return [];
        }
    }
    
    // Get chunks containing specific hashtags
    async getChunksForHashtags(hashtags) {
        if (!this.db) return [];
        
        try {
            const hashtagIndex = await this.db.indices.get('hashtags');
            if (!hashtagIndex) return [];
            
            const relevantChunks = new Set();
            hashtags.forEach(tag => {
                if (hashtagIndex.data[tag]) {
                    hashtagIndex.data[tag].forEach(chunkKey => {
                        relevantChunks.add(chunkKey);
                    });
                }
            });
            
            return Array.from(relevantChunks);
            
        } catch (error) {
            console.error('Error getting chunks for hashtags:', error);
            return [];
        }
    }
    
    // Get chunks for date range
    async getChunksForDateRange(startDate, endDate) {
        if (!this.db) return [];
        
        try {
            const dateIndex = await this.db.indices.get('dates');
            if (!dateIndex) return [];
            
            const relevantChunks = [];
            Object.entries(dateIndex.data).forEach(([chunkKey, chunkInfo]) => {
                // Check if chunk overlaps with date range
                if (chunkInfo.endDate >= startDate && chunkInfo.startDate <= endDate) {
                    relevantChunks.push(chunkKey);
                }
            });
            
            return relevantChunks;
            
        } catch (error) {
            console.error('Error getting chunks for date range:', error);
            return [];
        }
    }
    
    // Get storage statistics
    async getStats() {
        if (!this.db) return null;
        
        try {
            const chunks = await this.db.chunks.toArray();
            let totalNotes = 0;
            let oldestNote = null;
            let newestNote = null;
            
            chunks.forEach(chunk => {
                totalNotes += chunk.metadata.noteCount;
                if (!oldestNote || chunk.metadata.startDate < oldestNote) {
                    oldestNote = chunk.metadata.startDate;
                }
                if (!newestNote || chunk.metadata.endDate > newestNote) {
                    newestNote = chunk.metadata.endDate;
                }
            });
            
            return {
                totalChunks: chunks.length,
                totalNotes,
                oldestNote: oldestNote ? new Date(oldestNote * 1000) : null,
                newestNote: newestNote ? new Date(newestNote * 1000) : null,
                avgNotesPerChunk: Math.round(totalNotes / chunks.length)
            };
            
        } catch (error) {
            console.error('Error getting storage stats:', error);
            return null;
        }
    }

    // 🆕 ADD THESE TWO METHODS HERE
async storeLastSyncTime() {
    if (!this.db) return;
    try {
        await this.db.indices.put({
            type: 'last_sync',
            data: Date.now()
        });
    } catch (error) {
        console.error('Error storing last sync time:', error);
    }
}

async getLastSyncTime() {
    if (!this.db) return null;
    try {
        const result = await this.db.indices.get('last_sync');
        return result ? result.data : null;
    } catch (error) {
        console.error('Error getting last sync time:', error);
        return null;
    }
}
}


// Chunk management utilities
async function getChunkStorageInfo(pubkey) {
    const chunkStorage = new ChunkedNoteStorage(pubkey);
    const ready = await chunkStorage.init();
    
    if (!ready) return null;
    
    return await chunkStorage.getStats();
}

// Phase 3: Smart Filter-Aware Loading System
class SmartFilterEngine {
    constructor(chunkStorage) {
        this.chunkStorage = chunkStorage;
        this.loadedChunks = new Map(); // Cache for loaded chunks
        this.estimatedCounts = new Map(); // Cache for filter estimates
    }
    
    // Get estimated count for filters without loading all data
    async getEstimatedCount(filters) {
        const cacheKey = JSON.stringify(filters);
        if (this.estimatedCounts.has(cacheKey)) {
            return this.estimatedCounts.get(cacheKey);
        }
        
        try {
            const relevantChunks = await this.getRelevantChunks(filters);
            let estimatedCount = 0;
            
            // For hashtag filters, we can be more precise
            if (filters.hashtags && filters.hashtags.length > 0) {
                const chunks = await this.chunkStorage.getChunksForHashtags(filters.hashtags);
                // Load chunk metadata to get more accurate estimates
                for (const chunkKey of chunks) {
                    const chunk = await this.chunkStorage.db.chunks.get(chunkKey);
                    if (chunk) {
                        // Estimate based on hashtag density in chunk
                        const matchingHashtags = filters.hashtags.filter(tag => 
                            chunk.metadata.hashtags.includes(tag)
                        );
                        const ratio = matchingHashtags.length / Math.max(chunk.metadata.hashtags.length, 1);
                        estimatedCount += Math.ceil(chunk.metadata.noteCount * ratio * 0.7); // Conservative estimate
                    }
                }
            } else {
                // For other filters, use chunk note counts
                for (const chunkKey of relevantChunks) {
                    const chunk = await this.chunkStorage.db.chunks.get(chunkKey);
                    if (chunk) {
                        estimatedCount += chunk.metadata.noteCount;
                    }
                }
            }
            
            this.estimatedCounts.set(cacheKey, estimatedCount);
            return estimatedCount;
            
        } catch (error) {
            console.error('Error estimating count:', error);
            return 0;
        }
    }
    
    // Determine which chunks are relevant for given filters
    async getRelevantChunks(filters) {
        let relevantChunks = new Set();
        
        try {
            // Start with all chunks
            const allChunks = await this.chunkStorage.db.chunks.toArray();
            allChunks.forEach(chunk => relevantChunks.add(chunk.chunkKey));
            
            // Filter by hashtags
            if (filters.hashtags && filters.hashtags.length > 0) {
                const hashtagChunks = await this.chunkStorage.getChunksForHashtags(filters.hashtags);
                relevantChunks = new Set(hashtagChunks);
            }
            
            // Filter by date range
            if (filters.dateFrom || filters.dateTo) {
                const startDate = filters.dateFrom ? Math.floor(filters.dateFrom.getTime() / 1000) : 0;
                const endDate = filters.dateTo ? Math.floor(filters.dateTo.getTime() / 1000) : Math.floor(Date.now() / 1000);
                
                const dateChunks = await this.chunkStorage.getChunksForDateRange(startDate, endDate);
                
                if (relevantChunks.size === allChunks.length) {
                    // If we started with all chunks, use date chunks
                    relevantChunks = new Set(dateChunks);
                } else {
                    // Intersect with existing relevant chunks
                    relevantChunks = new Set([...relevantChunks].filter(x => dateChunks.includes(x)));
                }
            }
            
            // Filter by content type (replies/original)
            if (filters.contentType) {
                const filteredChunks = [];
                for (const chunkKey of relevantChunks) {
                    const chunk = await this.chunkStorage.db.chunks.get(chunkKey);
                    if (chunk) {
                        if (filters.contentType === 'replies' && chunk.metadata.hasReplies) {
                            filteredChunks.push(chunkKey);
                        } else if (filters.contentType === 'original' && chunk.metadata.noteCount > 0) {
                            filteredChunks.push(chunkKey);
                        }
                    }
                }
                relevantChunks = new Set(filteredChunks);
            }
            
            return Array.from(relevantChunks);
            
        } catch (error) {
            console.error('Error getting relevant chunks:', error);
            return [];
        }
    }
    
    // Load notes from relevant chunks with filters applied
    async loadFilteredNotes(filters, maxNotes = 50000) {
        try {
            const relevantChunks = await this.getRelevantChunks(filters);
            
            if (relevantChunks.length === 0) {
                return [];
            }
            
            updateStatus(`Loading from ${relevantChunks.length} relevant chunks...`);
            
            // Load chunks in order of relevance (newest first)
            const sortedChunks = relevantChunks.sort((a, b) => b.localeCompare(a));
            let allNotes = [];
            let loadedCount = 0;
            
            for (const chunkKey of sortedChunks) {
                if (loadedCount >= maxNotes) break;
                
                // Check if chunk is already loaded
                if (!this.loadedChunks.has(chunkKey)) {
                    const chunkNotes = await this.chunkStorage.loadChunks([chunkKey]);
                    this.loadedChunks.set(chunkKey, chunkNotes);
                }
                
                const chunkNotes = this.loadedChunks.get(chunkKey) || [];
                allNotes.push(...chunkNotes);
                loadedCount += chunkNotes.length;
                
                // Update progress
                updateStatus(`Loaded ${loadedCount} notes from ${Object.keys(this.loadedChunks).length} chunks...`);
            }
            
            // Apply fine-grained filters
            const filteredNotes = this.applyDetailedFilters(allNotes, filters);
            
            updateStatus(`Filtered to ${filteredNotes.length} matching notes`);
            return filteredNotes.slice(0, maxNotes);
            
        } catch (error) {
            console.error('Error loading filtered notes:', error);
            return [];
        }
    }
    
    // Apply detailed filters to loaded notes
    // Apply detailed filters to loaded notes
applyDetailedFilters(notes, filters) {
    return notes.filter(note => {
        // Text search
        if (filters.searchText) {
            const searchTerms = filters.searchText.toLowerCase().split(/\s+/);
            const searchableText = (note.content + ' ' + (note.hashtags || []).join(' ')).toLowerCase();
            if (!searchTerms.every(term => searchableText.includes(term))) {
                return false;
            }
        }
        
        // Hashtag filter
        if (filters.hashtags && filters.hashtags.length > 0) {
            if (!filters.hashtags.some(tag => note.hashtags && note.hashtags.includes(tag))) {
                return false;
            }
        }
        
        // Date range
        if (filters.dateFrom && note.created_at < Math.floor(filters.dateFrom.getTime() / 1000)) {
            return false;
        }
        if (filters.dateTo && note.created_at > Math.floor(filters.dateTo.getTime() / 1000)) {
            return false;
        }
        
        // Content type
        if (filters.contentType === 'replies' && !note.isReply) {
            return false;
        }
        if (filters.contentType === 'original' && note.isReply) {
            return false;
        }
        
        // Image filter
        if (filters.hasImages) {
            const imageRegex = /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp))/gi;
            if (!imageRegex.test(note.content)) {
                return false;
            }
        }
        
        // YouTube filter
        if (filters.hasYouTube) {
            const youtubeRegex = /(youtube\.com\/watch\?v=|youtu\.be\/)/gi;
            if (!youtubeRegex.test(note.content)) {
                return false;
            }
        }

        // Links filter
        if (filters.hasLinks) {
            // Match all URLs
            const allUrls = note.content.match(/https?:\/\/[^\s<>"]+/gi) || [];
            
            if (allUrls.length === 0) return false; // No links at all
            
            // If we're ALSO filtering for images or videos, allow those
            if (filters.hasImages || filters.hasYouTube) {
                // Already has links, and we want images/videos - this is fine
            } else {
                // Links-only filter: exclude notes that ONLY have images/videos
                const imageRegex = /\.(jpg|jpeg|png|gif|webp)(\?[^\s"<>]*)?$/i;
                const youtubeRegex = /(youtube\.com\/watch\?v=|youtu\.be\/)/i;
                
                // Check if there's at least one link that's NOT just an image or video
                const hasNonMediaLink = allUrls.some(url => !imageRegex.test(url) && !youtubeRegex.test(url));
                if (!hasNonMediaLink) {
                    return false;
                }
            }
        }
        
        // Music filter
        if (filters.hasMusic) {
            const musicRegex = /(song\.link\/|open\.spotify\.com\/(track|album|playlist)\/|music\.youtube\.com\/watch|music\.apple\.com\/)/i;
            if (!musicRegex.test(note.content)) {
                return false;
            }
        }
        
        // Length filters
        if (filters.minLength && note.content.length < filters.minLength) {
            return false;
        }
        if (filters.maxLength && note.content.length > filters.maxLength) {
            return false;
        }
        
        return true;
    });
}
    
    // Clear caches
    clearCaches() {
        this.loadedChunks.clear();
        this.estimatedCounts.clear();
    }
}

// Smart tag filtering using chunk awareness
// Smart tag filtering using chunk awareness
async function performSmartTagFilter(tag) {
    console.log('=== SMART TAG FILTER DEBUG ===');
    console.log('Filtering for tag:', tag);
    
    try {
        const chunkStorage = new ChunkedNoteStorage(currentPubkey);
        const ready = await chunkStorage.init();
        
        if (!ready) {
            console.log('Chunk storage not ready, falling back to memory filtering');
            const memoryResults = allNotes.filter(note => noteMatchesTag(note, tag));
            console.log('Memory filtering found:', memoryResults.length, 'results');
            return memoryResults;
        }
        
        console.log('Chunk storage ready, attempting smart filtering...');
        
        const filterEngine = new SmartFilterEngine(chunkStorage);
        
        // Convert tag to filter format
        const filters = {};
        
        if (tag.startsWith('#')) {
            filters.hashtags = [tag];
            console.log('Set hashtag filter:', filters.hashtags);
            
            // DEBUG: Check if hashtag exists in indices
            const hashtagIndex = await chunkStorage.db.indices.get('hashtags');
            console.log('Hashtag index:', hashtagIndex);
            
            if (hashtagIndex && hashtagIndex.data[tag]) {
                console.log('Found chunks for hashtag:', hashtagIndex.data[tag]);
            } else {
                console.log('No chunks found for hashtag in index, falling back to memory');
                const memoryResults = allNotes.filter(note => noteMatchesTag(note, tag));
                console.log('Memory fallback found:', memoryResults.length, 'results');
                return memoryResults;
            }
            
        } else if (tag === '__original') {
            filters.contentType = 'original';
        } else if (tag === '__replies') {
            filters.contentType = 'replies';
        } else if (tag.startsWith('__archive_')) {
            // Archive filtering still uses memory (archives are typically smaller)
            const archiveName = tag.replace('__archive_', '');
            if (namedArchives[archiveName]) {
                return allNotes.filter(note => namedArchives[archiveName].has(note.id));
            }
            return [];
        }
        
        // Get estimated count
        const estimatedCount = await filterEngine.getEstimatedCount(filters);
        console.log('Estimated count:', estimatedCount);
        
        if (estimatedCount > 0) {
            updateStatus(`Loading ${estimatedCount} estimated notes for ${tag}...`);
            
            // Load filtered notes
            const results = await filterEngine.loadFilteredNotes(filters);
            
            console.log('Smart filtering results:', results.length);
            updateStatus(`Loaded ${results.length} notes for ${tag}`);
            return results;
        }
        
        console.log('No estimated results, falling back to memory');
        const memoryResults = allNotes.filter(note => noteMatchesTag(note, tag));
        console.log('Memory fallback found:', memoryResults.length, 'results');
        return memoryResults;
        
    } catch (error) {
        console.error('Smart tag filter error:', error);
        // Fallback to memory search
        const memoryResults = allNotes.filter(note => noteMatchesTag(note, tag));
        console.log('Error fallback found:', memoryResults.length, 'results');
        return memoryResults;
    }
}

async function clearChunkStorage(pubkey) {
    try {
        const chunkStorage = new ChunkedNoteStorage(pubkey);
        const ready = await chunkStorage.init();
        
        if (ready && chunkStorage.db) {
            await chunkStorage.db.chunks.clear();
            await chunkStorage.db.indices.clear();
            return true;
        }
        
        return false;
    } catch (error) {
        console.error('Error clearing chunk storage:', error);
        return false;
    }
}

// Add this function to debug chunk storage
async function debugChunkStorage() {
    if (!currentPubkey) {
        console.log('No current pubkey');
        return;
    }
    
    const chunkStorage = new ChunkedNoteStorage(currentPubkey);
    const ready = await chunkStorage.init();
    
    if (!ready) {
        console.log('Chunk storage not ready');
        return;
    }
    
    console.log('=== CHUNK STORAGE DEBUG ===');
    
    // Get all chunks
    const chunks = await chunkStorage.db.chunks.toArray();
    console.log('Total chunks:', chunks.length);
    
    // Check hashtag index
    const hashtagIndex = await chunkStorage.db.indices.get('hashtags');
    console.log('Hashtag index:', hashtagIndex);
    
    if (hashtagIndex) {
        const hashtags = Object.keys(hashtagIndex.data);
        console.log('Hashtags in index:', hashtags.slice(0, 10), '(showing first 10)');
        
        // Check a specific hashtag
        const firstHashtag = hashtags[0];
        if (firstHashtag) {
            console.log(`Chunks for ${firstHashtag}:`, hashtagIndex.data[firstHashtag]);
        }
    }
    
    // Check sample chunk
    if (chunks.length > 0) {
        console.log('Sample chunk metadata:', chunks[0].metadata);
    }
}

// Make it globally available for testing
window.debugChunkStorage = debugChunkStorage;

async function fetchFreshAndStore(pubkey, silent = false) {
    if (!silent) updateStatus('Fetching fresh data from relays...');
    
    const freshNotes = await fetchNotesFromRelays(pubkey);
    
    if (freshNotes.length > 0 && db && useIndexedDB) {
        try {
            if (!silent) updateStatus('Storing fresh data in IndexedDB...');
            
            await db.notes.clear();
            await db.settings.clear();
            
            // IMPORTANT: Ensure all classification fields are explicitly stored
            const notesToStore = freshNotes.map(note => ({
                ...note,
                isReply: Boolean(note.isReply),
                isRepost: Boolean(note.isRepost),
                isQuote: Boolean(note.isQuote),
                kind: note.kind || 1
            }));
            
            // Store in chunks to avoid memory issues
            const chunkSize = 1000;
            for (let i = 0; i < notesToStore.length; i += chunkSize) {
                const chunk = notesToStore.slice(i, i + chunkSize);
                await db.notes.bulkAdd(chunk);
                
                if (!silent && notesToStore.length > chunkSize) {
                    updateStatus(`Stored ${Math.min(i + chunkSize, notesToStore.length)}/${notesToStore.length} notes...`);
                }
            }
            
            await db.settings.put({ key: 'last_sync_time', value: Date.now() });
            await db.settings.put({ key: 'total_notes_stored', value: notesToStore.length });
            
            if (!silent) {
                updateStatus(`Successfully stored ${notesToStore.length} notes in IndexedDB`);
            }
        } catch (storeError) {
            console.error('Failed to store fresh data:', storeError);
            if (!silent) updateStatus('Storage failed, continuing with memory-only mode');
            disableIndexedDB(storeError);
        }
    }
    
    return freshNotes;
}

async function incrementalSync(pubkey, silent = true) {
    if (!db || !useIndexedDB) {
        return await fetchNotesFromRelays(pubkey); // Fallback to full fetch
    }
    
    try {
        // Get the newest note we have stored
        const newestStoredNote = await db.notes
            .orderBy('created_at')
            .reverse()
            .first();
        
        if (!newestStoredNote) {
            // No stored notes, do full fetch
            return await fetchNotesFromRelays(pubkey);
        }
        
        const lastTimestamp = newestStoredNote.created_at;
        
        if (!silent) {
            updateStatus(`Checking for notes newer than ${new Date(lastTimestamp * 1000).toLocaleString()}...`);
        }
        
        // Fetch only newer notes from relays
        const newNotes = await fetchNotesFromRelaysSince(pubkey, lastTimestamp);
        
        if (newNotes.length > 0) {
            // Add new notes to IndexedDB
            await db.notes.bulkAdd(newNotes);
            await db.settings.put({ key: 'last_sync_time', value: Date.now() });
            
            if (!silent) {
                updateStatus(`Found and stored ${newNotes.length} new notes`);
            }
            
            // Return all notes (existing + new) for display
            const allNotes = await db.notes
                .orderBy('created_at')
                .reverse()
                .toArray();
            
            return allNotes;
        } else {
            if (!silent) {
                updateStatus('No new notes found');
            }
            
            // Return existing notes
            return await db.notes
                .orderBy('created_at')
                .reverse()
                .toArray();
        }
        
    } catch (error) {
        console.error('Incremental sync error:', error);
        // Fallback to full fetch
        return await fetchNotesFromRelays(pubkey);
    }
}

async function loadNotes(silent = false, isRefresh = false) {
    const previousNotesCount = allNotes.length; // Track what we had before
    let loadedFromChunkCache = false;
    let cachedChunkStats = null;
    
    if (!silent) {
        showLoading(true);
        updateProgress(0, 'Connecting to relays.');
        updateStatus('Starting fresh load...', true);
    } else {
        // small indicator only
        updateStatus('Refreshing notes…');
    }
            
    try {
        let notes;
        let isLargeAccount = false;
        let accountInfo = null; // Declare once at the top

        if (!silent) {
            // FIRST: Check if we have stored chunks (prioritize over account size detection)
            updateProgress(5, 'Checking for stored data...');
            
            const chunkStorage = new ChunkedNoteStorage(currentPubkey);
            const chunkReady = await chunkStorage.init();
            
            if (chunkReady) {
                const chunkStats = await chunkStorage.getStats();
                
                if (chunkStats && chunkStats.totalNotes > 0) {
                    // We have stored data - load it all immediately
                    loadedFromChunkCache = true;
                    cachedChunkStats = chunkStats;
                    updateProgress(15, `Loading all ${chunkStats.totalNotes} notes from storage...`);
                    updateStatus(`Found stored data: ${chunkStats.totalChunks} chunks, ${chunkStats.totalNotes} notes`);
                    
                    notes = await loadNotesHybrid(currentPubkey, silent);
                    
                    showToast(`Loaded ${notes.length} notes from storage instantly!`, 'success');
                    updateStatus(`Loaded ${notes.length} notes from ${chunkStats.totalChunks} stored chunks`);
                    
                } else {
                    // No stored data - do account size detection and progressive loading
                    updateProgress(10, 'No stored data found, checking account size...');
                    accountInfo = await estimateAccountSize(currentPubkey); // Set accountInfo here
                    
                    console.log('Account info:', accountInfo);
                    updateProgress(15, `Account: ${accountInfo.size} (${accountInfo.recentCount} recent notes)`);
                    
                    if (accountInfo.size === 'large') {
                        isLargeAccount = true;
                        updateProgress(20, 'Large account - loading recent notes first...');
                        updateStatus('Large account detected! Loading recent notes for faster startup...');
                        
                        notes = await loadRecentNotesOnly(currentPubkey, 30);
                        showToast(`Loaded ${notes.length} recent notes instantly! Older notes loading in background.`, 'success');
                        
                    } else if (accountInfo.size === 'medium') {
                        updateProgress(20, 'Medium account - loading recent notes first...');
                        updateStatus('Medium account detected! Loading recent notes first...');
                        
                        notes = await loadRecentNotesOnly(currentPubkey, 60);
                        showToast(`Loaded ${notes.length} recent notes. Full history loading in background.`, 'success');
                        
                    } else {
                        updateProgress(20, 'Small account detected - loading all notes...');
                        updateStatus('Small account detected - loading all notes...');
                        
                        notes = await loadNotesHybrid(currentPubkey, silent);
                    }
                }
            } else {
                // Chunked storage failed - fallback to original progressive loading
                updateProgress(10, 'Storage unavailable, checking account size...');
                accountInfo = await estimateAccountSize(currentPubkey); // Set accountInfo here too
                
                console.log('Account info:', accountInfo);
                updateProgress(15, `Account: ${accountInfo.size} (${accountInfo.recentCount} recent notes)`);
                
                if (accountInfo.size === 'large') {
                    isLargeAccount = true;
                    updateProgress(20, 'Large account - loading recent notes first...');
                    
                    notes = await loadRecentNotesOnly(currentPubkey, 30);
                    showToast(`Loaded ${notes.length} recent notes instantly! Older notes loading in background.`, 'success');
                    
                } else if (accountInfo.size === 'medium') {
                    updateProgress(20, 'Medium account - loading recent notes first...');
                    
                    notes = await loadRecentNotesOnly(currentPubkey, 60);
                    showToast(`Loaded ${notes.length} recent notes. Full history loading in background.`, 'success');
                    
                } else {
                    updateProgress(20, 'Small account detected - loading all notes...');
                    notes = await loadNotesHybrid(currentPubkey, silent);
                }
            }
        } else {
            // Silent loads (refreshes) always use hybrid approach
            notes = await loadNotesHybrid(currentPubkey, silent);
        }

        // Clear old localStorage cache since we're using IndexedDB now
        if (useIndexedDB) {
            clearLegacyCache(currentPubkey);
        }
        
        updateStatus(`Sorting ${notes.length} notes by date...`);
        await new Promise(resolve => setTimeout(resolve, 10)); // Brief pause
        
        allNotes = notes.sort((a, b) => b.created_at - a.created_at);
        
        updateStatus('Updating archives list...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Initialize archives UI after loading
        updateArchiveList();
        updateTargetArchiveDropdown();
        
        updateStatus('Updating tag filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        updateTagFilters();
        
        updateStatus('Applying filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        applyFilters();
        
        updateStatus('Rendering notes...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        renderNotes();
        
        // Schedule background loading AFTER UI is ready (only for fresh loads without stored data)
        // Fixed: Check if accountInfo exists before accessing its properties
        if (!silent && (isLargeAccount || (accountInfo && accountInfo.size === 'medium'))) {
            scheduleBackgroundLoading(currentPubkey, { estimatedTotal: notes.length * 5 });
        } else if (!silent && loadedFromChunkCache) {
            // Always refresh cached chunks in the background to make sure we don't miss notes
            const estimatedTotal = (cachedChunkStats && cachedChunkStats.totalNotes) || notes.length;
            scheduleBackgroundLoading(currentPubkey, { estimatedTotal });
        }
        
        // Start auto-refresh: check for new notes every hour
        if (!silent && !isRefresh) {
            startAutoRefresh(currentPubkey);
        }
        
        // Check if neon-green theme is active
const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
const checkmark = isNeonGreen ? '' : '✅ ';

// Calculate what was actually new
const newNotesCount = allNotes.length - previousNotesCount;
updateStatus(`${checkmark}Successfully loaded ${allNotes.length} notes!`);
        
        if (!silent && isRefresh === true) {
            if (newNotesCount > 0) {
                showToast(`Refresh complete - ${newNotesCount} new notes loaded (${allNotes.length} total)`, 'success');
            } else {
                showToast(`Refresh complete - no new notes found (${allNotes.length} total)`, 'success');
            }
        }
        
    } catch (error) {
        console.error('Error loading notes:', error);
        showError('Failed to load notes: ' + error.message);
    } finally {
        if (!silent) {
            showLoading(false);
            trackLoadTime();
        }
    }
}
      
async function fetchBatchFromRelay(relayUrl, pubkey, until, limit, retryCount = 0) {
    const maxRetries = 3;
    
    console.log(`[${relayUrl}] Fetching batch: until=${until}, limit=${limit}, retry=${retryCount}`);
    
    try {
        const result = await fetchBatchFromRelayCore(relayUrl, pubkey, until, limit);
        console.log(`[${relayUrl}] Batch returned ${result.length} events`);
        return result;
    } catch (error) {
        console.error(`[${relayUrl}] Batch attempt ${retryCount + 1} failed:`, error.message);
        
        if (retryCount < maxRetries) {
            const backoffDelay = Math.pow(2, retryCount) * 1000;
            console.log(`[${relayUrl}] Retrying after ${backoffDelay}ms`);
            await new Promise(resolve => setTimeout(resolve, backoffDelay));
            return fetchBatchFromRelay(relayUrl, pubkey, until, limit, retryCount + 1);
        }
        
        console.warn(`[${relayUrl}] All retries exhausted, returning empty batch`);
        return [];
    }
}

function fetchBatchFromRelayCore(relayUrl, pubkey, until, limit) {
    return new Promise((resolve, reject) => {
        // Check if loading was cancelled before starting
        if (isLoadingCancelled) {
            resolve([]);
            return;
        }
        
        // SIMPLE FIX: Check if this pubkey is still active
        if (!currentPubkey || currentPubkey !== pubkey) {
            resolve([]);
            return;
        }
        
        const ws = new WebSocket(relayUrl);
        activeWebSockets.add(ws); // Track this WebSocket
        const events = [];
        let timeoutId;
        let isResolved = false;
        
        const cleanup = (reason = 'unknown') => {
            if (timeoutId) clearTimeout(timeoutId);
            activeWebSockets.delete(ws); // Remove from tracking
            if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
                ws.close(1000, 'Batch complete');
            }
        };
        
        const resolveOnce = (result) => {
            if (!isResolved) {
                isResolved = true;
                cleanup();
                resolve(result);
            }
        };
        
        const rejectOnce = (error) => {
            if (!isResolved) {
                isResolved = true;
                cleanup();
                reject(error);
            }
        };
        
        ws.onopen = function() {
            // Check cancellation after connection opens
            if (isLoadingCancelled) {
                resolveOnce([]);
                return;
            }
            
            const filter = {
                kinds: [1, 6],
                authors: [pubkey],
                limit: limit
            };
            
            if (until) {
                filter.until = until;
            }
            
            const subscription = ['REQ', 'batch-' + Date.now(), filter];
            ws.send(JSON.stringify(subscription));
            
            timeoutId = setTimeout(() => {
                console.warn(`[${relayUrl}] Timeout after 45s, returning ${events.length} events`);
                resolveOnce(events);
            }, 45000); // 45 seconds timeout
        };
        
        ws.onmessage = function(event) {
            // Check cancellation on each message
            if (isLoadingCancelled) {
                resolveOnce(events);
                return;
            }
            
            try {
                const message = JSON.parse(event.data);
                const [type, subId, eventData] = message;
                
                if (type === 'EVENT') {
                    const note = processNote(eventData);
                    if (note) {
                        events.push(note);
                    }
                } else if (type === 'EOSE') {
                    resolveOnce(events);
                }
            } catch (error) {
                console.error('Error parsing message:', error);
            }
        };
        
        ws.onerror = function() {
            rejectOnce(new Error('Connection failed'));
        };
        
        ws.onclose = function() {
            if (!isResolved) {
                resolveOnce(events);
            }
        };
    });
}
// Account size detection for progressive loading
async function estimateAccountSize(pubkey) {
    try {
        // Try to get a COUNT from relays instead of recent notes
        const testRelays = ['wss://relay.snort.social', 'wss://relay.damus.io', 'wss://relay.primal.net'];
        let bestEstimate = 0;
        
        for (const relay of testRelays) {
            try {
                // Get a small sample to estimate total size
                const sampleSize = await getTotalNoteEstimate(relay, pubkey);
                bestEstimate = Math.max(bestEstimate, sampleSize);
                console.log(`${relay}: estimated ${sampleSize} total notes`);
                
                if (sampleSize > 5000) {
                    return { size: 'large', estimatedTotal: sampleSize };
                }
            } catch (error) {
                console.log(`${relay} failed for size check:`, error.message);
                continue;
            }
        }
        
        // Classification based on total estimate
        if (bestEstimate > 2000) {
            return { size: 'large', estimatedTotal: bestEstimate };
        } else if (bestEstimate > 500) {
            return { size: 'medium', estimatedTotal: bestEstimate };
        } else {
            return { size: 'small', estimatedTotal: bestEstimate };
        }
        
    } catch (error) {
        console.error('Account size estimation failed:', error);
        // Default to medium to use progressive loading
        return { size: 'medium', estimatedTotal: 1000 };
    }
}

async function getTotalNoteEstimate(relayUrl, pubkey) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        let count = 0;
        let hasReceivedAnyEvent = false;
        
        const timeoutId = setTimeout(() => {
            ws.close();
            // If we got some events, extrapolate
            if (hasReceivedAnyEvent && count > 0) {
                resolve(count * 3); // Rough estimate
            } else {
                resolve(0);
            }
        }, 15000); // 15 second timeout
        
        ws.onopen = function() {
            // Request first 1000 notes to estimate
            const filter = {
                kinds: [1, 6],
                authors: [pubkey],
                limit: 1000
            };
            
            ws.send(JSON.stringify(['REQ', 'size-check', filter]));
        };
        
        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const [type] = message;
                
                if (type === 'EVENT') {
                    count++;
                    hasReceivedAnyEvent = true;
                } else if (type === 'EOSE') {
                    clearTimeout(timeoutId);
                    ws.close();
                    // If we got exactly 1000, there are probably more
                    resolve(count >= 1000 ? count * 5 : count);
                }
            } catch (error) {
                // Ignore parse errors
            }
        };
        
        ws.onerror = function() {
            clearTimeout(timeoutId);
            reject(new Error('Connection failed'));
        };
    });
}

async function getRecentNoteCount(relayUrl, pubkey, daysBack) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        let count = 0;
        const timeoutId = setTimeout(() => {
            ws.close();
            resolve(count);
        }, 10000); // 10 second timeout
        
        ws.onopen = function() {
            const since = Math.floor(Date.now() / 1000) - (daysBack * 24 * 60 * 60);
            const filter = {
    kinds: [1, 6], // Add kind 6
    authors: [pubkey],
    since: since,
    limit: 1000
};
            
            ws.send(JSON.stringify(['REQ', 'size-check', filter]));
        };
        
        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const [type] = message;
                
                if (type === 'EVENT') {
                    count++;
                } else if (type === 'EOSE') {
                    clearTimeout(timeoutId);
                    ws.close();
                    resolve(count);
                }
            } catch (error) {
                // Ignore parse errors
            }
        };
        
        ws.onerror = function() {
            clearTimeout(timeoutId);
            reject(new Error('Connection failed'));
        };
    });
}

// Load only recent notes for large accounts
// Enhanced recent loading with chunked storage awareness
async function loadRecentNotesOnly(pubkey, daysBack = 30) {
    try {
        // Try to load from chunks first
        const chunkStorage = new ChunkedNoteStorage(pubkey);
        const chunkStorageReady = await chunkStorage.init();
        
        if (chunkStorageReady) {
            const stats = await chunkStorage.getStats();
            
            if (stats && stats.totalNotes > 0) {
                // Calculate date range for recent notes
                const sinceTimestamp = Math.floor(Date.now() / 1000) - (daysBack * 24 * 60 * 60);
                const nowTimestamp = Math.floor(Date.now() / 1000);
                
                // Get relevant chunks for this date range
                const relevantChunks = await chunkStorage.getChunksForDateRange(sinceTimestamp, nowTimestamp);
                
                if (relevantChunks.length > 0) {
                    updateStatus(`Loading recent notes from ${relevantChunks.length} chunks...`);
                    
                    const recentNotes = await chunkStorage.loadChunks(relevantChunks);
                    
                    // Filter to exact date range
                    const filteredNotes = recentNotes.filter(note => 
                        note.created_at >= sinceTimestamp
                    );
                    
                    if (filteredNotes.length > 0) {
                        updateStatus(`Loaded ${filteredNotes.length} recent notes from chunks`);
                        return filteredNotes;
                    }
                }
            }
        }
        
        // Fallback to relay loading
        updateStatus(`No chunk data available, loading recent notes from relays...`);
        return await loadRecentNotesFromRelays(pubkey, daysBack);
        
    } catch (error) {
        console.error('Chunked recent loading failed:', error);
        return await loadRecentNotesFromRelays(pubkey, daysBack);
    }
}

// Separate function for relay-based recent loading
async function loadRecentNotesFromRelays(pubkey, daysBack) {
    const allEvents = [];
    const since = Math.floor(Date.now() / 1000) - (daysBack * 24 * 60 * 60);
    
    updateStatus(`Loading recent notes from relays (last ${daysBack} days)...`);
    
    const relayPromises = RELAYS.slice(0, 5).map(async (relay, index) => {
        const relayName = relay.replace('wss://', '');
        
        try {
            updateStatus(`${relayName}: Loading recent notes...`);
            
            const recentNotes = await fetchRecentNotesFromRelay(relay, pubkey, since);

// Check if neon-green theme is active
const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
const checkmark = isNeonGreen ? '' : '✅ ';

updateStatus(`${checkmark}${relayName}: ${recentNotes.length} recent notes`);
return { relay, events: recentNotes, success: true };
            
        } catch (error) {
            updateStatus(`❌ ${relayName}: ${error.message}`);
            return { relay, events: [], success: false };
        }
    });
    
    const results = await Promise.allSettled(relayPromises);
    
    // Collect events
    results.forEach((result) => {
        if (result.status === 'fulfilled' && result.value.success) {
            allEvents.push(...result.value.events);
        }
    });
    
    // Quick deduplication
    const uniqueEvents = [];
    const seenIds = new Set();
    
    allEvents.forEach(event => {
        if (event.id && !seenIds.has(event.id)) {
            seenIds.add(event.id);
            uniqueEvents.push(event);
        }
    });
    
    // Check if neon-green theme is active
const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
const checkmark = isNeonGreen ? '' : '✅ ';

updateStatus(`${checkmark}Loaded ${uniqueEvents.length} recent notes from relays`);
return uniqueEvents;
}

async function scheduleBackgroundLoading(pubkey, accountInfo) {
    // SIMPLE FIX: Don't start if pubkey doesn't match
    if (!currentPubkey || currentPubkey !== pubkey) {
        console.log('Background loading cancelled - pubkey mismatch');
        return;
    }
    
    // Prevent overlapping background loads
    if (isBackgroundLoading) {
        return;
    }

    if (backgroundLoadingTimeout) {
        clearTimeout(backgroundLoadingTimeout);
        backgroundLoadingTimeout = null;
    }

    backgroundLoadingTimeout = setTimeout(async () => {
        // CRITICAL: Check again after timeout
        if (!currentPubkey || currentPubkey !== pubkey) {
            console.log('Background loading cancelled - user switched');
            backgroundLoadingTimeout = null;
            return;
        }
        
        // Check if cancelled before starting
        if (isLoadingCancelled) {
            backgroundLoadingTimeout = null;
            return;
        }
        
        try {
            isBackgroundLoading = true;
            console.log('Starting background loading for:', pubkey.substring(0, 8));
            showBackgroundLoadingIndicator();
            
            const fullNotes = await fetchNotesFromRelays(pubkey);
            
            // CRITICAL: Check AGAIN after fetch - user might have switched during fetch
            if (!currentPubkey || currentPubkey !== pubkey) {
                console.log('Background loading cancelled - user switched during fetch');
                hideBackgroundLoadingIndicator();
                isBackgroundLoading = false;
                backgroundLoadingTimeout = null;
                return;
            }
            
            // Check cancellation after fetch
            if (isLoadingCancelled) {
                hideBackgroundLoadingIndicator();
                isBackgroundLoading = false;
                backgroundLoadingTimeout = null;
                return;
            }
            
            // Initialize chunked storage
            const chunkStorage = new ChunkedNoteStorage(pubkey);
            const chunkStorageReady = await chunkStorage.init();
            
            if (chunkStorageReady) {
                // Only update chunks if we got MORE notes than currently stored
const currentStats = await chunkStorage.getStats();
const currentNoteCount = currentStats ? currentStats.totalNotes : 0;

if (fullNotes.length > currentNoteCount) {
    // We found more notes - update chunks
    await chunkStorage.storeNotesInChunks(fullNotes);
    const newStats = await chunkStorage.getStats();
    updateStatus(`✅ Updated chunk storage: ${newStats.totalChunks} chunks, ${newStats.totalNotes} notes`);
} else {
    // We have same or fewer notes - don't overwrite!
    updateStatus(`⚠️ Skipped chunk update: already have ${currentNoteCount} notes (background got ${fullNotes.length})`);
}
            }
            
            // Find notes we don't already have in memory
            const existingIds = new Set(allNotes.map(note => note.id));
            const newNotes = fullNotes.filter(note => !existingIds.has(note.id));
            
            console.log(`Background loading found ${newNotes.length} additional notes`);
            
            if (newNotes.length > 0) {
    // FINAL CHECK: Only update if still the same user
    if (currentPubkey === pubkey) {
        // Add to global array
        allNotes.push(...newNotes);
        allNotes.sort((a, b) => b.created_at - a.created_at);
        
        // Update UI if user is on default view
        updateTagFilters();
        
        if (!currentTag && selectedTags.size === 0 && activeQuickFilters.size === 0) {
            applyFilters();
            renderNotes();
        }
        
        hideBackgroundLoadingIndicator();
        // REMOVED: Don't show toast for background loading - it's silent
        updateStatus(`✅ Background loading: +${newNotes.length} older notes (${allNotes.length} total)`);
    } else {
        console.log('Skipping UI update - user switched');
        hideBackgroundLoadingIndicator();
    }
} else {
    hideBackgroundLoadingIndicator();
    
    // Check if neon-green theme is active
    const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
    const checkmark = isNeonGreen ? '' : '✅ ';
    
    updateStatus(`${checkmark}Background loading complete: chunk storage updated, no additional notes in memory`);
}
            
        } catch (error) {
            console.error('Background loading failed:', error);
            hideBackgroundLoadingIndicator();
        } finally {
            isBackgroundLoading = false;
            backgroundLoadingTimeout = null;
        }
    }, 2000);
}

// Auto-refresh: Check for new notes every hour
function startAutoRefresh(pubkey) {
    // Clear any existing interval
    if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
    }
    
    // Set up 1-hour interval (3600000 milliseconds)
    autoRefreshInterval = setInterval(async () => {
        // Only refresh if still connected to same pubkey
        if (!currentPubkey || currentPubkey !== pubkey) {
            clearInterval(autoRefreshInterval);
            autoRefreshInterval = null;
            return;
        }
        
        console.log('Auto-refresh: Checking for new notes...');
        
        try {
            // Silently refresh in background
            await loadNotes(true, true); // silent=true, isRefresh=true
            
            const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
            const checkmark = isNeonGreen ? '' : '🔄 ';
            updateStatus(`${checkmark}Auto-refreshed: ${allNotes.length} total notes`);
        } catch (error) {
            console.error('Auto-refresh failed:', error);
        }
    }, 3600000); // 1 hour in milliseconds
    
    console.log('Auto-refresh enabled: will check for new notes every hour');
}

function showBackgroundLoadingIndicator() {
    const indicator = document.createElement('div');
    indicator.id = 'bg-loading-indicator';
    indicator.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: var(--card-background);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 12px 16px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
        font-size: 13px;
        color: var(--text-color);
        animation: slideIn 0.3s ease;
    `;
    indicator.innerHTML = `
        <div style="margin-bottom: 4px; font-weight: 500;">Loading older notes...</div>
        <div style="width: 200px; height: 4px; background: var(--background-color); border-radius: 2px; overflow: hidden;">
            <div style="height: 100%; background: var(--primary-color); width: 0%; animation: progressAnim 3s ease-in-out infinite;"></div>
        </div>
    `;
    
    document.body.appendChild(indicator);
}

function hideBackgroundLoadingIndicator() {
    const indicator = document.getElementById('bg-loading-indicator');
    if (indicator) {
        indicator.remove();
    }
}

async function fetchRecentNotesFromRelay(relayUrl, pubkey, since) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        const events = [];
        let timeoutId;
        
        ws.onopen = function() {
            const filter = {
    kinds: [1, 6], // Add kind 6
    authors: [pubkey],
    since: since,
    limit: 2000
};
            
            ws.send(JSON.stringify(['REQ', 'recent-' + Date.now(), filter]));
            
            timeoutId = setTimeout(() => {
                ws.close();
                resolve(events);
            }, 15000); // 15 second timeout
        };
        
        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const [type, subId, eventData] = message;
                
                if (type === 'EVENT') {
                    const note = processNote(eventData);
                    if (note) {
                        events.push(note);
                    }
                } else if (type === 'EOSE') {
                    clearTimeout(timeoutId);
                    ws.close();
                    resolve(events);
                }
            } catch (error) {
                console.error('Error parsing message:', error);
            }
        };
        
        ws.onerror = function() {
            clearTimeout(timeoutId);
            reject(new Error('Connection failed'));
        };
        
        ws.onclose = function() {
            clearTimeout(timeoutId);
            resolve(events);
        };
    });
}

        function processNote(event) {
    if (!event || !event.id) {
        return null;
    }
    
    let content = event.content || '';
    let isRepost = false;
    let isQuote = false;
    let isReply = false;
    
    if (event.kind === 6) {
    // Kind 6 is ONLY a repost - set flag and exit early
    isRepost = true;
    
    if (!content.trim()) {
        content = "Boosted a note";
    } else {
        try {
            const embeddedEvent = JSON.parse(content);
            if (embeddedEvent.content) {
                content = `Reposted: "${embeddedEvent.content.substring(0, 200)}${embeddedEvent.content.length > 200 ? '...' : ''}"`;
            }
        } catch (e) {
            content = `Reposted: ${content.substring(0, 200)}${content.length > 200 ? '...' : ''}`;
        }
    }
    
    // Return early with cleaned repost
    const hashtags = extractHashtags(content);
    return {
        id: event.id,
        pubkey: event.pubkey,
        created_at: event.created_at,
        content: content,
        hashtags: hashtags,
        isReply: false,
        isRepost: true,
        isQuote: false,
        kind: event.kind,
        tags: event.tags || []
    };
}else if (event.kind === 1) {
        // Only process kind 1 events for replies/quotes
        const eTags = event.tags?.filter(tag => tag[0] === 'e') || [];
        const pTags = event.tags?.filter(tag => tag[0] === 'p' && tag[1] !== event.pubkey) || [];
        
        // Check for note references (potential quotes)
        const hasNostrEntity = /nostr:(note1[a-z0-9]{58}|nevent1[a-z0-9]+)/i.test(content);
        const hasNoteRef = /\b(note1[a-z0-9]{58}|nevent1[a-z0-9]+)\b/i.test(content);
        
        if (hasNostrEntity || hasNoteRef) {
            // Has note references - determine if quote or reply
            const hasSubstantialContent = content.trim().length > 50;
            const startsWithMention = content.trim().startsWith('@');
            const hasReplyContext = startsWithMention || content.toLowerCase().includes('replying');
            
            if (hasReplyContext) {
                isReply = true;
            } else if (hasSubstantialContent) {
                isQuote = true;
            } else {
                isReply = true; // Default to reply for short content
            }
        } else if (eTags.length > 0 || pTags.length > 0 || content.trim().startsWith('@')) {
            // Has tags or mentions but no note references - reply
            isReply = true;
        }
        // Otherwise it's an original note (all flags remain false)
    }
    
    const hashtags = extractHashtags(content);
    
    return {
        id: event.id,
        pubkey: event.pubkey,
        created_at: event.created_at,
        content: content,
        hashtags: hashtags,
        isReply: isReply,
        isRepost: isRepost,
        isQuote: isQuote,
        kind: event.kind,
        tags: event.tags || []
    };
}

function getReplyTargetNpub(note) {
    if (!note.tags || !Array.isArray(note.tags)) return null;
    
    // Find p-tags (mentions of other users)
    const pTags = note.tags.filter(tag => tag[0] === 'p' && tag[1]);
    
    if (pTags.length === 0) return null;
    
    // Get the first p-tag (usually the person being replied to)
    const targetPubkey = pTags[0][1];
    
    try {
        // Convert hex pubkey to npub using NostrTools
        if (window.NostrTools && window.NostrTools.nip19) {
            return window.NostrTools.nip19.npubEncode(targetPubkey);
        }
    } catch (error) {
        console.error('Error converting pubkey to npub:', error);
    }
    
    return null;
}

// Add this function to create a shortened display version of npub
function shortenNpub(npub) {
    if (!npub || npub.length < 16) return npub;
    return npub.substring(0, 12) + '...' + npub.substring(npub.length - 8);
}

// Add this temporary debug function to check classifications
function debugNoteClassifications() {
    if (!allNotes.length) {
        console.log('No notes loaded');
        return;
    }
    
    const sample = allNotes.slice(0, 20);
    console.log('=== NOTE CLASSIFICATION DEBUG ===');
    
    sample.forEach(note => {
        const flags = [];
        if (note.isReply) flags.push('REPLY');
        if (note.isRepost) flags.push('REPOST');
        if (note.isQuote) flags.push('QUOTE');
        if (flags.length === 0) flags.push('ORIGINAL');
        
        console.log(`${note.id.substring(0, 8)}: [${flags.join(', ')}] "${note.content.substring(0, 50)}..."`);
    });
    
    const totals = {
        original: allNotes.filter(n => !n.isReply && !n.isRepost && !n.isQuote).length,
        replies: allNotes.filter(n => n.isReply).length,
        reposts: allNotes.filter(n => n.isRepost).length,
        quotes: allNotes.filter(n => n.isQuote).length,
        multipleFlags: allNotes.filter(n => [n.isReply, n.isRepost, n.isQuote].filter(Boolean).length > 1).length
    };
    
    console.log('TOTALS:', totals);
    console.log('Notes with multiple flags (should be 0):', totals.multipleFlags);
}

// Make it globally available
window.debugNoteClassifications = debugNoteClassifications;

// 1. ADD this function to show storage usage information
async function showStorageInfo() {
    try {
        let info = {
            localStorage: 0,
            indexedDB: 0,
            totalNotes: allNotes.length,
            loadedNotes: allNotes.length,
            archives: Object.keys(namedArchives).length,
            totalArchived: 0
        };
        
        // Calculate localStorage usage
        let localStorageSize = 0;
        for (let key in localStorage) {
            if (localStorage.hasOwnProperty(key)) {
                localStorageSize += localStorage[key].length + key.length;
            }
        }
        info.localStorage = (localStorageSize / 1024).toFixed(2); // KB
        
        // Calculate IndexedDB usage and note count
        if (db && useIndexedDB) {
            try {
                const totalInDB = await db.notes.count();
                info.totalNotes = totalInDB;
            } catch (error) {
                console.log('Could not get IndexedDB count:', error);
            }
        }
        
        // Calculate archived notes
        Object.values(namedArchives).forEach(archive => {
            info.totalArchived += archive.size;
        });
        
        // Show storage info modal
        const modalHtml = `
            <div class="modal" onclick="closeStorageInfo(event)">
                <div class="modal-content" onclick="event.stopPropagation()">
                    <button class="modal-close" onclick="closeStorageInfo()">Close</button>
                    <h3>Storage Information</h3>
                    <div style="font-family: monospace; line-height: 1.6;">
                        <p><strong>Notes:</strong></p>
                        <p>  • Total stored: ${info.totalNotes.toLocaleString()}</p>
                        <p>  • Currently loaded: ${info.loadedNotes.toLocaleString()}</p>
                        <p>  • Memory usage: ~${(info.loadedNotes * 0.5).toFixed(1)} KB</p>
                        
                        <p><strong>Archives:</strong></p>
                        <p>  • Number of archives: ${info.archives}</p>
                        <p>  • Total archived notes: ${info.totalArchived}</p>
                        
                        <p><strong>Storage:</strong></p>
                        <p>  • LocalStorage: ${info.localStorage} KB</p>
                        <p>  • IndexedDB: ${useIndexedDB ? 'Active' : 'Not available'}</p>
                        
                        <p><strong>Performance:</strong></p>
                        <p>  • Load time: ${getLastLoadTime()}</p>
                        <p>  • Memory status: ${getMemoryStatus(info.loadedNotes)}</p>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <button class="btn btn-small" onclick="exportStorageReport()" style="background: var(--primary-color); margin-right: 10px;">
    Export Report
</button>
<button class="btn btn-small" onclick="optimizeStorage()" style="background: var(--success-color);">
    Optimize Storage
</button>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
    } catch (error) {
        showToast('Error getting storage info: ' + error.message, 'error');
    }
}

// App info modal function
async function showAppInfo() {
    const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
    
    const modalHtml = `
        <div class="modal" onclick="closeAppInfo(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeAppInfo()">Close</button>
                <h3>${isNeonGreen ? 'Nostr Notes Archive' : '📝 Nostr Notes Archive'}</h3>
                
                <div style="line-height: 1.6; margin-bottom: 24px;">
                    <p><strong>What is this app?</strong></p>
                    <p>This is a browser-based tool for viewing, organizing, and archiving your notes. It connects directly to Nostr relays to fetch your posts and allows you to organize them into custom archives for better management.</p>
                </div>

                <div style="line-height: 1.6; margin-bottom: 24px;">
                    <p><strong>Key Features:</strong></p>
                    <ul style="margin-left: 20px; margin-top: 8px;">
                        <li>View all your original notes and replies</li>
                        <li>Create custom archives to organize notes</li>
                        <li>Search by content, hashtags, and date ranges</li>
                        <li>Filter by images, videos, and note length</li>
                        <li>Export notes as JSON or CSV</li>
                        <li>Fast IndexedDB caching for better performance</li>
                        <li>Multiple theme options including Neon Green</li>
                        <li>Keyboard shortcuts for power users</li>
                    </ul>
                </div>

                <div style="line-height: 1.6; margin-bottom: 24px;">
                    <p><strong>Privacy & Security:</strong></p>
                    <p>Your data stays in your browser. The app only connects to public Nostr relays to read your posts. No data is sent to external servers except for the relay connections needed to fetch your notes.</p>
                </div>

                <div style="background: var(--background-color); padding: 16px; border-radius: 8px; border-left: 4px solid var(--primary-color); margin-bottom: 24px;">
                    <p><strong>Created by Romeo</strong></p>
                    <p style="font-family: monospace; font-size: 13px; word-break: break-all; margin-top: 8px;">
                        <strong>Npub:</strong> npub12p5753xcjal8034w5czap3fcdvj9qj36h5873g73ea05emw2gznszr0ann
                    </p>
                    <button onclick="copyToClipboard('npub12p5753xcjal8034w5czap3fcdvj9qj36h5873g73ea05emw2gznszr0ann')" 
                            class="copy-btn" style="margin-top: 8px;">
                        Copy NPUB
                    </button>
                </div>

                <div style="text-align: center; font-size: 13px; color: var(--text-muted);">
                    <p>Built with ❤️ for the Nostr community</p>
                    <p style="margin-top: 8px;">Version 2.4 • Open Source • No Tracking</p>
                    <p style="margin-top: 8px;">
                        <a href="https://github.com/rome539/nostr-archive" target="_blank" rel="noopener noreferrer" style="color: var(--primary-color); text-decoration: none;">
                            View on GitHub
                        </a>
                    </p>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeAppInfo(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

// 2. Helper functions for storage info
function getLastLoadTime() {
    const lastLoad = localStorage.getItem('nostr-last-load-time');
    if (lastLoad) {
        const seconds = (Date.now() - parseInt(lastLoad)) / 1000;
        return seconds < 60 ? `${seconds.toFixed(1)}s ago` : `${(seconds/60).toFixed(1)}m ago`;
    }
    return 'Unknown';
}

function getMemoryStatus(noteCount) {
    if (noteCount < 25000) return 'Excellent';
    if (noteCount < 75000) return 'Good'; 
    if (noteCount < 150000) return 'Fair';
    return 'High';
}

function closeStorageInfo(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

// 3. ADD storage optimization function
async function optimizeStorage() {
    try {
        let optimized = [];
        let freedSpace = 0;
        
        // Clear old localStorage entries from other users
        const keysToCheck = Object.keys(localStorage);
        keysToCheck.forEach(key => {
            if (key.startsWith('nostr-cached-notes-') && key !== `nostr-cached-notes-${currentPubkey}`) {
                const size = localStorage[key]?.length || 0;
                localStorage.removeItem(key);
                freedSpace += size;
                optimized.push('Removed old user cache');
            }
            if (key.startsWith('nostr-last-pubkey-') && key !== `nostr-last-pubkey-${currentPubkey}`) {
                localStorage.removeItem(key);
                optimized.push('Cleaned old pubkey data');
            }
        });
        
        // Clean up empty archives (this is actually useful)
        let emptyArchives = 0;
        Object.keys(namedArchives).forEach(archiveName => {
            if (namedArchives[archiveName].size === 0) {
                delete namedArchives[archiveName];
                emptyArchives++;
            }
        });
        if (emptyArchives > 0) {
            optimized.push(`Removed ${emptyArchives} empty archives`);
        }
        
        // Clear IndexedDB cache to force fresh relay fetch on next load
        if (db && useIndexedDB) {
            await db.settings.delete('last_sync_time');
            optimized.push('Reset sync cache (will fetch fresh data next time)');
        }
        
        if (optimized.length > 0) {
            if (emptyArchives > 0) saveArchivedNotes();
            const spaceSaved = freedSpace > 0 ? ` (freed ${(freedSpace/1024).toFixed(1)} KB)` : '';
            showToast(`Optimized: ${optimized.join(', ')}${spaceSaved}`, 'success');
        } else {
            showToast('Nothing to optimize - storage is clean!', 'success');
        }
        
        closeStorageInfo();
        
    } catch (error) {
        showToast('Error optimizing storage: ' + error.message, 'error');
    }
}

function exportStorageReport() {
    const report = {
        generated_at: new Date().toISOString(),
        user_pubkey: currentPubkey ? currentPubkey.substring(0, 16) + '...' : 'none',
        stats: {
            total_notes_stored: allNotes.length,
            notes_currently_loaded: allNotes.length,
            archives_count: Object.keys(namedArchives).length,
            total_archived_notes: Object.values(namedArchives).reduce((sum, archive) => sum + archive.size, 0),
            hashtags_found: new Set(allNotes.flatMap(note => note.hashtags || [])).size,
            replies_count: allNotes.filter(note => note.isReply).length,
            original_notes_count: allNotes.filter(note => !note.isReply).length
        },
        performance: {
            indexeddb_active: useIndexedDB,
            memory_status: getMemoryStatus(allNotes.length),
            relays_configured: RELAYS.length,
            last_load_time: getLastLoadTime()
        },
        archives: Object.keys(namedArchives).map(name => ({
            name: name,
            note_count: namedArchives[name].size
        }))
    };
    
    downloadFile(
        JSON.stringify(report, null, 2),
        `nostr-storage-report-${new Date().toISOString().split('T')[0]}.json`,
        'application/json'
    );
    
    showToast('Storage report exported!', 'success');
}

// 5. ADD function to track load times
function trackLoadTime() {
    localStorage.setItem('nostr-last-load-time', Date.now().toString());
}

        function extractHashtags(content) {
            const matches = content.match(/#\w+/g);
            return matches ? matches.map(tag => tag.toLowerCase()) : [];
        }

        function updateTagFilters() {
    const tagCounts = {};
    
    // Build hashtag counts efficiently
    allNotes.forEach(note => {
        note.hashtags?.forEach(tag => {
            tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        });
    });
    
    const archivedCount = allNotes.filter(note => archivedNotes.has(note.id)).length;
    const originalNotesCount = allNotes.filter(note => !note.isReply && !note.isRepost && !note.isQuote).length;
    const repliesCount = allNotes.filter(note => note.isReply).length;
    const repostsCount = allNotes.filter(note => note.isRepost).length;
    const quotesCount = allNotes.filter(note => note.isQuote).length;
    
    const container = document.getElementById('tag-filters');

    if (!container) {
        console.error('tag-filters container not found!');
        return;
    }

    container.innerHTML = `
    <button type="button" class="tag-filter active" data-tag="" onclick="this.blur()">All Notes (${allNotes.length})</button>
    <button type="button" class="tag-filter" data-tag="__original" onclick="this.blur()"><span class="emoji">📄</span> Original Notes (${originalNotesCount})</button>
    <button type="button" class="tag-filter" data-tag="__replies" onclick="this.blur()"><span class="emoji">💬</span> Replies (${repliesCount})</button>
    <button type="button" class="tag-filter" data-tag="__reposts" onclick="this.blur()"><span class="emoji">🔄</span> Reposts (${repostsCount})</button>
    <button type="button" class="tag-filter" data-tag="__quotes" onclick="this.blur()"><span class="emoji">💭</span> Quotes (${quotesCount})</button>
`;

    // Group hashtags alphabetically
    const hashtagGroups = {};
    Object.keys(tagCounts).sort((a, b) => a.localeCompare(b)).forEach(tag => {
        const firstLetter = tag.charAt(1).toUpperCase(); // Skip the # symbol
        if (!hashtagGroups[firstLetter]) {
            hashtagGroups[firstLetter] = [];
        }
        hashtagGroups[firstLetter].push(tag);
    });

    // Add grouped hashtags with collapsible sections
    Object.keys(hashtagGroups).sort().forEach(letter => {
        const groupCount = hashtagGroups[letter].length;
        
        // Add clickable letter header
        const letterHeader = document.createElement('button');
        letterHeader.type = 'button';
        letterHeader.className = 'hashtag-group-header';
        letterHeader.style.cssText = `
            display: block;
            width: 100%;
            text-align: left;
            background: var(--background-color);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            margin: 8px 0 0 0;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            color: var(--text-color);
            font-size: 13px;
            transition: background-color 0.2s ease;
        `;
        letterHeader.textContent = `${letter} (${groupCount} hashtags)`;
        
        // Click handler - the button should highlight while pressed, then return to normal
        letterHeader.onclick = function(e) {
            toggleHashtagGroup(letter);
            // Force remove focus immediately so the highlight doesn't persist
            setTimeout(() => this.blur(), 100);
        };
        
        container.appendChild(letterHeader);
        
        // Add container for hashtags (initially hidden)
        const hashtagContainer = document.createElement('div');
        hashtagContainer.id = `hashtag-group-${letter}`;
        hashtagContainer.style.cssText = `
            display: none;
            margin: 0 0 8px 0;
            padding: 4px 0;
            border-left: 2px solid var(--border-color);
            padding-left: 8px;
        `;
        
        hashtagGroups[letter].forEach(tag => {
            const button = document.createElement('button');
            button.className = 'tag-filter';
            button.dataset.tag = tag;
            button.textContent = `${tag} (${tagCounts[tag]})`;
            button.addEventListener('click', () => toggleTag(tag));
            hashtagContainer.appendChild(button);
        });
        
        container.appendChild(hashtagContainer);
    });
    
    // Add click handlers
    const allNotesBtn = container.querySelector('[data-tag=""]');
    const originalBtn = container.querySelector('[data-tag="__original"]');
    const repliesBtn = container.querySelector('[data-tag="__replies"]');
    const repostsBtn = container.querySelector('[data-tag="__reposts"]');
    const quotesBtn = container.querySelector('[data-tag="__quotes"]');

    if (allNotesBtn) allNotesBtn.addEventListener('click', () => toggleTag(''));
    if (originalBtn) originalBtn.addEventListener('click', () => toggleTag('__original'));
    if (repliesBtn) repliesBtn.addEventListener('click', () => toggleTag('__replies'));
    if (repostsBtn) repostsBtn.addEventListener('click', () => toggleTag('__reposts'));
    if (quotesBtn) quotesBtn.addEventListener('click', () => toggleTag('__quotes'));

    
    setActiveTagButtons();

    // --- one-time drag-select listeners for tag filters ---
    (function initTagDragOnce() {
        const tagFiltersEl = document.getElementById('tag-filters');
        if (!tagFiltersEl || tagFiltersEl.__dragInit) return;

        // Start drag only with LEFT button and only on real hashtags (e.g., "#coffee")
        tagFiltersEl.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;                         // left click only
            const btn = e.target.closest('.tag-filter');
            if (!btn) return;
            const tag = btn.dataset.tag;
            if (!tag || !tag.startsWith('#')) return;           // ignore All/Original/Replies
            startHashtagSelection(tag, e);                      // decides add/remove mode
        });

        // Continue while holding the button, over real hashtags only
        tagFiltersEl.addEventListener('mouseover', (e) => {
            if (!isSelecting) return;                           // set by startHashtagSelection
            const btn = e.target.closest('.tag-filter');
            if (!btn) return;
            const tag = btn.dataset.tag;
            if (!tag || !tag.startsWith('#')) return;
            continueHashtagSelection(tag, e);
        });

        // End drag anywhere
        document.addEventListener('mouseup', endHashtagSelection);

        tagFiltersEl.__dragInit = true;                       // guard against rebinding
    })();
}

        function filterByTag(tag) {
            currentTag = tag;

            document.getElementById('date-from').value = '';
            document.getElementById('date-to').value = '';
            
            // Update active button
            document.querySelectorAll('.tag-filter').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tag === tag) {
                    btn.classList.add('active');
                }
            });
            
            applyFilters();
            renderNotes();
            setActiveTagButtons();
        }

        function toggleHashtagGroup(letter) {
    const container = document.getElementById(`hashtag-group-${letter}`);
    
    if (container.style.display === 'none') {
        container.style.display = 'block';
    } else {
        container.style.display = 'none';
    }
}

function setActiveTagButtons() {
  const buttons = document.querySelectorAll('#tag-filters .tag-filter');
  buttons.forEach(btn => {
    const t = btn.dataset.tag || '';
    
    // Clear existing active state
    btn.classList.remove('active');
    
    // "All Notes" is active only when nothing is selected AND we're not in archive view
    if (t === '' && selectedTags.size === 0 && !currentTag.startsWith('__archive_')) {
      btn.classList.add('active');
    } 
    // Hashtag buttons are active when they're in selectedTags (regardless of archive view)
    else if (t !== '' && selectedTags.has(t)) {
      btn.classList.add('active');
    }
    // Special buttons (Original Notes, Replies) are active when selected
    else if (t === '__original' && selectedTags.has('__original')) {
      btn.classList.add('active');
    }
    else if (t === '__replies' && selectedTags.has('__replies')) {
      btn.classList.add('active');
    }
    else if (t === '__reposts' && selectedTags.has('__reposts')) {
      btn.classList.add('active');
    }
    else if (t === '__quotes' && selectedTags.has('__quotes')) {
      btn.classList.add('active');
    }
  });
}

function applyDateFilters() {
    // ADD: Clear "most" filter when applying date filters
    currentSortMode = null;
    const dropdown = document.getElementById('secondary-filter-dropdown');
    if (dropdown) dropdown.value = '';
    
    // Use advanced filtering system
    applyAllFilters();
}


function toggleTag(tag) {
    // DON'T clear archive state - we want filters to work INSIDE archives
    // The archive context should persist when applying filters
    
    if (!tag) {
        // "All Notes" clears ALL selections including quick filters AND dates
        selectedTags.clear();
        currentTag = '';
        currentArchive = 'default';
        searchQuery = '';
        
        // Clear archive active states
        document.querySelectorAll('.archive-item').forEach(item => {
            item.classList.remove('active');
        });
        
        activeQuickFilters.clear();
        
        // Clear quick filter buttons
        document.querySelectorAll('.quick-filter-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Clear date filters
        document.getElementById('date-from').value = '';
        document.getElementById('date-to').value = '';
        
        // Set "All Notes" as active
        document.querySelectorAll('.tag-filter').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.tag === '') {
                btn.classList.add('active');
            }
        });
        
        // Use simple filtering for "All Notes"
        window.inAdvancedSearchMode = false;
        filteredNotes = allNotes.slice();
        resetPagination();
        renderNotes();
        
        // Force advanced mode off AGAIN after render
        window.inAdvancedSearchMode = false;
        
        // Force update the count display
        document.getElementById('notes-title').textContent = 'All Notes';
        document.getElementById('notes-count').textContent = `${allNotes.length} notes`;
        return;
    } 
    
    // Check if we have manual dates set
    const hasManualDates = document.getElementById('date-from').value || document.getElementById('date-to').value;
    
    // For hashtag/content type selection, work WITH quick filters and dates
    if (selectedTags.has(tag)) {
        selectedTags.delete(tag);
        
        // If no tags selected after removal, check if we have quick filters or dates
        if (selectedTags.size === 0 && (activeQuickFilters.size > 0 || hasManualDates)) {
            // We still have quick filters or dates active, so use advanced search
            applyAllFilters();
        } else if (selectedTags.size === 0 && activeQuickFilters.size === 0 && !hasManualDates) {
            // If we're in an archive, stay in the archive but show all notes from that archive
            if (currentArchive !== 'default' && currentTag.startsWith('__archive_')) {
                // Stay in archive, just remove hashtag filter
                currentTag = '__archive_' + currentArchive;
                applyFilters();
                renderNotes();
            } else {
                // Nothing active, go to "All Notes"
                currentTag = '';
                currentArchive = 'default';
                searchQuery = '';
                
                document.querySelectorAll('.tag-filter').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.tag === '') {
                        btn.classList.add('active');
                    }
                });
                
                document.querySelectorAll('.archive-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                window.inAdvancedSearchMode = false;
                
                // CRITICAL: Set filtered notes directly without calling applyFilters
                filteredNotes = allNotes.slice();
                resetPagination();
                renderNotes();
                
                // Force advanced mode off AGAIN after render
                window.inAdvancedSearchMode = false;
                
                // Force update the count display
                document.getElementById('notes-title').textContent = 'All Notes';
                document.getElementById('notes-count').textContent = `${allNotes.length} notes`;
            }
        } else {
            // Other tags still selected, continue with appropriate filtering
            if (activeQuickFilters.size > 0 || hasManualDates) {
                applyAllFilters();
            } else {
                applyFilters();
                renderNotes();
            }
        }
    } else {
    selectedTags.add(tag);
    
    // ADD: Clear "most" filter when selecting a hashtag/tag
    currentSortMode = null;
    const dropdown = document.getElementById('secondary-filter-dropdown');
    if (dropdown) dropdown.value = '';
    
    // Check if all content types are selected - that equals "All Notes"
    const hasOriginal = selectedTags.has('__original');
    const hasReplies = selectedTags.has('__replies');
    const hasReposts = selectedTags.has('__reposts');
    const hasQuotes = selectedTags.has('__quotes');
        
        // If all 4 content types are selected, clear them but keep quick filters and dates
        if (hasOriginal && hasReplies && hasReposts && hasQuotes && selectedTags.size === 4) {
            selectedTags.clear();
            currentTag = '';
            
            if (activeQuickFilters.size > 0 || hasManualDates) {
                // Quick filters or dates are active, use advanced search
                applyAllFilters();
            } else {
                // No filters active, go to "All Notes"
                document.querySelectorAll('.tag-filter').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.tag === '') {
                        btn.classList.add('active');
                    }
                });
                window.inAdvancedSearchMode = false;
                filteredNotes = allNotes.slice();
                resetPagination();
                renderNotes();
                
                // Force advanced mode off AGAIN after render
                window.inAdvancedSearchMode = false;
                
                // Force update the count display
                document.getElementById('notes-title').textContent = 'All Notes';
                document.getElementById('notes-count').textContent = `${allNotes.length} notes`;
            }
        } else if (hasOriginal && hasReplies && selectedTags.size === 2 && !hasReposts && !hasQuotes) {
            // If only original and replies are selected, clear them but keep quick filters and dates
            selectedTags.clear();
            currentTag = '';
            
            if (activeQuickFilters.size > 0 || hasManualDates) {
                // Quick filters or dates are active, use advanced search
                applyAllFilters();
            } else {
                // No filters active, go to "All Notes"
                document.querySelectorAll('.tag-filter').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.tag === '') {
                        btn.classList.add('active');
                    }
                });
                window.inAdvancedSearchMode = false;
                filteredNotes = allNotes.slice();
                resetPagination();
                renderNotes();
                
                // Force advanced mode off AGAIN after render
                window.inAdvancedSearchMode = false;
                
                // Force update the count display
                document.getElementById('notes-title').textContent = 'All Notes';
                document.getElementById('notes-count').textContent = `${allNotes.length} notes`;
            }
        } else {
            // Normal tag selection - use appropriate filter system
            if (activeQuickFilters.size > 0 || hasManualDates) {
                applyAllFilters();
            } else {
                applyFilters();
                renderNotes();
            }
        }
    }
    
    setActiveTagButtons();
}

function debugFilterState() {
    console.log('=== FILTER STATE DEBUG ===');
    console.log('allNotes.length:', allNotes.length);
    console.log('filteredNotes.length:', filteredNotes.length);
    console.log('selectedTags:', Array.from(selectedTags));
    console.log('currentTag:', currentTag);
    console.log('currentArchive:', currentArchive);
    console.log('activeQuickFilters:', Array.from(activeQuickFilters));
    console.log('searchQuery:', searchQuery);
    console.log('inAdvancedSearchMode:', window.inAdvancedSearchMode);
}

window.debugFilterState = debugFilterState;

function noteMatchesTag(note, tag) {
    if (tag === '__original') return !note.isReply && !note.isRepost && !note.isQuote;
    if (tag === '__replies') return note.isReply;
    if (tag === '__reposts') return note.isRepost;
    if (tag === '__quotes') return note.isQuote;
    if (tag === '__archived') return archivedNotes.has(note.id);
    if (tag.startsWith('__archive_')) {
        const name = tag.replace('__archive_', '');
        return namedArchives[name] && namedArchives[name].has(note.id);
    }
    return note.hashtags && note.hashtags.includes(tag);
}

        function handleSearch() {
    searchQuery = document.getElementById('search-input').value.toLowerCase();
    
    // ADD: Clear "most" filter when searching
    currentSortMode = null;
    const dropdown = document.getElementById('secondary-filter-dropdown');
    if (dropdown) dropdown.value = '';
    
    // Check if there are any active date filters
    const hasDateFilters = document.getElementById('date-from').value || 
                          document.getElementById('date-to').value;
    
    // If there are active quick filters OR date filters, use the advanced search system
    if (activeQuickFilters.size > 0 || hasDateFilters) {
        applyAllFilters();
    } else {
        // Use the simple filter system
        applyFilters();
        renderNotes();
    }
}

      function applyFilters() {
    // Prevent concurrent filtering
    if (isFiltering) {
        clearTimeout(filterDebounceTimeout);
        filterDebounceTimeout = setTimeout(() => applyFilters(), 100);
        return;
    }
    
    isFiltering = true;
    
    try {
        // If we have active quick filters, delegate to the advanced search system
        if (activeQuickFilters.size > 0) {
            applyAllFilters();
            return;
        }
        
        // Start with all notes
        let workingSet = allNotes;
        
        // OPTIMIZATION: Apply archive filter FIRST (most restrictive)
        if (currentArchive !== 'default' && currentTag.startsWith('__archive_')) {
            const archiveName = currentTag.replace('__archive_', '');
            if (namedArchives[archiveName]) {
                const archiveSet = namedArchives[archiveName];
                workingSet = workingSet.filter(note => archiveSet.has(note.id));
            }
        }
        
        // OPTIMIZATION: Apply content type filters early (fast)
        if (selectedTags.size > 0) {
            const tags = Array.from(selectedTags);
            workingSet = workingSet.filter(note =>
                tags.some(tag => noteMatchesTag(note, tag))
            );
        } else if (currentTag && currentTag !== '' && !currentTag.startsWith('__archive_')) {
            // Fall back to old single-select behavior
            if (currentTag === '__archived') {
                workingSet = workingSet.filter(note => archivedNotes.has(note.id));
            } else if (currentTag === '__original') {
                workingSet = workingSet.filter(note => !note.isReply && !note.isRepost && !note.isQuote);
            } else if (currentTag === '__replies') {
                workingSet = workingSet.filter(note => note.isReply);
            } else if (currentTag === '__reposts') {
                workingSet = workingSet.filter(note => note.isRepost);
            } else if (currentTag === '__quotes') {
                workingSet = workingSet.filter(note => note.isQuote);
            } else if (currentTag) {
                workingSet = workingSet.filter(note => note.hashtags.includes(currentTag));
            }
        }
        
        // OPTIMIZATION: Apply text search LAST (most expensive)
        if (searchQuery) {
            const q = searchQuery.toLowerCase();
            workingSet = workingSet.filter(note => {
                // Search in content
                if (note.content.toLowerCase().includes(q)) return true;
                
                // Search in hashtags
                if (note.hashtags && note.hashtags.some(tag => tag.includes(q))) return true;
                
                // Search in reply target npub
                if (note.isReply) {
                    const replyTargetNpub = getReplyTargetNpub(note);
                    if (replyTargetNpub && replyTargetNpub.toLowerCase().includes(q)) {
                        return true;
                    }
                    
                    if (note.tags && Array.isArray(note.tags)) {
                        const pTags = note.tags.filter(tag => tag[0] === 'p' && tag[1]);
                        if (pTags.length > 0) {
                            const targetPubkey = pTags[0][1];
                            if (targetPubkey.toLowerCase().includes(q)) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            });
        }
        
        filteredNotes = workingSet;
        resetPagination();
        
    } finally {
        isFiltering = false;
    }
}

function showFilteringIndicator() {
    const title = document.getElementById('notes-title');
    if (title && !title.textContent.includes('⏳')) {
        title.dataset.originalText = title.textContent;
        title.textContent = '⏳ Filtering...';
    }
}

function hideFilteringIndicator() {
    const title = document.getElementById('notes-title');
    if (title && title.dataset.originalText) {
        title.textContent = title.dataset.originalText;
        delete title.dataset.originalText;
    }
}



        function renderNotes() {
    // FIX #9: Clear cache at the start
    hashtagElementCache = null;
    
    const container = document.getElementById('notes-container');
    const emptyState = document.getElementById('empty-state');
    const loadMoreContainer = document.getElementById('load-more-container');
    const paginationInfo = document.getElementById('pagination-info');
    const title = document.getElementById('notes-title');
    const count = document.getElementById('notes-count');
    
    if (!container) {
        console.error('notes-container not found!');
        return;
    }
    
    // Calculate how many notes to show
    const totalToShow = Math.min(currentPage * notesPerPage, filteredNotes.length);
    const notesToRender = filteredNotes.slice(0, totalToShow);
            
    // Update title and count
    if (selectedTags.size > 0) {
        // Check if we're in an archive context
        if (currentArchive !== 'default' && currentTag.startsWith('__archive_')) {
            const archiveName = currentTag.replace('__archive_', '');
            const tagNames = Array.from(selectedTags).map(tag => {
                if (tag === '__original') return 'Original Notes';
                if (tag === '__replies') return 'Replies';
                if (tag === '__reposts') return 'Reposts';
                if (tag === '__quotes') return 'Quotes';
                if (tag === '__archived') return 'Archived';
                return tag;
            });
            // Show archive context with selected tags
            title.textContent = `Archive: ${archiveName} (${tagNames.join(' + ')})`;
        } else {
            // Check if all content types are selected - that's equivalent to "All Notes"
            const hasOriginal = selectedTags.has('__original');
            const hasReplies = selectedTags.has('__replies');
            const hasReposts = selectedTags.has('__reposts');
            const hasQuotes = selectedTags.has('__quotes');
            
            if ((hasOriginal && hasReplies && selectedTags.size === 2) ||
                (hasOriginal && hasReplies && hasReposts && hasQuotes && selectedTags.size === 4)) {
                // If only original and replies are selected, OR all 4 types are selected, show "All Notes"
                title.textContent = 'All Notes';
            } else {
                // Multi-tag selection takes priority
                const tagNames = Array.from(selectedTags).map(tag => {
                    if (tag === '__original') return 'Original Notes';
                    if (tag === '__replies') return 'Replies';
                    if (tag === '__reposts') return 'Reposts';
                    if (tag === '__quotes') return 'Quotes';
                    if (tag === '__archived') return 'Archived';
                    return tag;
                });
                title.textContent = tagNames.join(' + ');
            }
        }
    } else if (currentTag === '__archived') {
        title.textContent = 'All Archived Notes';
    } else if (currentTag === '__original') {
        title.textContent = 'Original Notes';
    } else if (currentTag === '__replies') {
        title.textContent = 'Replies';
    } else if (currentTag === '__reposts') {
        title.textContent = 'Reposts';
    } else if (currentTag === '__quotes') {
        title.textContent = 'Quotes';
    } else if (currentTag.startsWith('__archive_')) {
        const archiveName = currentTag.replace('__archive_', '');
        // Check if neon-green theme is active
        const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
        title.textContent = isNeonGreen ? `Archive: ${archiveName}` : ` Archive: ${archiveName}`;
        title.style.color = 'var(--text-muted)';
    } else if (currentTag) {
        title.textContent = `Notes tagged ${currentTag}`;
        title.style.color = '';     // Reset color
        title.style.fontWeight = ''; // Reset weight
    } else {
        title.textContent = 'All Notes';
        title.style.color = '';     // Reset color
        title.style.fontWeight = ''; // Reset weight
    }
    count.textContent = `${filteredNotes.length} notes`;

    if (filteredNotes.length === 0) {
        container.innerHTML = '';
        loadMoreContainer.classList.add('hidden');
        if (emptyState) emptyState.classList.remove('hidden');
        updateSelectionUI();
        return;
    }

    // Update export button text to show what will be exported
    const exportJsonBtn = document.getElementById('export-json');
    const exportMdBtn = document.getElementById('export-md');
    // Define isNeonGreen here so it can be used below
    const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';

   if (currentTag.startsWith('__archive_')) {
    const archiveName = currentTag.replace('__archive_', '');
    if (exportJsonBtn) exportJsonBtn.textContent = `Export "${archiveName}" JSON`;
    if (exportMdBtn) exportMdBtn.textContent = `Export "${archiveName}" CSV`;
} else {
    if (exportJsonBtn) exportJsonBtn.textContent = 'Export JSON';
    if (exportMdBtn) exportMdBtn.textContent = 'Export CSV';
}

    if (emptyState) emptyState.classList.add('hidden');

    // Only show load more button if we're not currently loading AND there are more notes to show
    // Show load more button logic
    const hasMoreNotes = totalToShow < filteredNotes.length;

    if (hasMoreNotes && filteredNotes.length > 0) {
        loadMoreContainer.classList.remove('hidden');
        paginationInfo.textContent = `Showing ${totalToShow} of ${filteredNotes.length} notes`;
    } else {
        loadMoreContainer.classList.add('hidden');
        if (filteredNotes.length > 0) {
            paginationInfo.textContent = `Showing all ${filteredNotes.length} notes`;
        }
    }
            
    // Render notes in chunks to prevent blocking
    const renderInChunks = async () => {
        const chunkSize = 50; // Smaller chunks for rendering
        let html = '';
        
        // FIX #8: Pre-calculate sets for faster lookups
        const archivedSet = archivedNotes;
        const selectedSet = selectedNotes;
        
        for (let i = 0; i < notesToRender.length; i += chunkSize) {
            const chunk = notesToRender.slice(i, i + chunkSize);
                
            chunk.forEach(note => {
                const date = new Date(note.created_at * 1000).toLocaleString();
                // FIX #8: Use pre-calculated sets
                const isArchived = archivedSet.has(note.id);
                const isSelected = selectedSet.has(note.id);
                
                const hashtagsHtml = note.hashtags && note.hashtags.length > 0 ? 
                    note.hashtags.map(tag => {
                        const isSelected = selectedTags.has(tag);
                        return `<span class="hashtag" 
                               onmousedown="startHashtagSelection('${tag}', event)" 
                               onmouseenter="continueHashtagSelection('${tag}', event)"
                               ontouchstart="startHashtagSelection('${tag}', event)"
                               data-tag="${tag}"
                               ${isSelected ? 'data-selected="true"' : ''}>${tag}</span>`;
                    }).join(' ') : '';
                
                // Different styling for different note types
                const cardClass = `note-card ${isArchived ? 'archived' : ''} ${note.isReply ? 'reply-card' : ''} ${note.isRepost ? 'repost-card' : ''} ${note.isQuote ? 'quote-card' : ''}`;

                // Set appropriate indicator based on note type
                let noteIndicator = '<span class="emoji">📄</span> '; // Default for original notes
                if (note.isRepost) {
                    noteIndicator = '<span class="emoji">🔄</span> ';
                } else if (note.isQuote) {
                    noteIndicator = '<span class="emoji">💭</span> ';
                } else if (note.isReply) {
                    // Get the npub they're replying to
                    const replyTargetNpub = getReplyTargetNpub(note);
                    if (replyTargetNpub) {
                        const shortNpub = shortenNpub(replyTargetNpub);
                        noteIndicator = `<span class="reply-indicator"><span class="emoji">💬</span> Replying to <button onclick="copyToClipboard('${replyTargetNpub}')" class="npub-copy-btn" title="Click to copy full npub">${shortNpub}</button></span> `;
                    } else {
                        noteIndicator = '<span class="emoji">💬</span> ';
                    }
                }
                
                // IMPROVED: Check if we're in a specific archive view
                const isInSpecificArchive = currentTag.startsWith('__archive_');
                const currentArchiveName = isInSpecificArchive ? currentTag.replace('__archive_', '') : '';
                const isNoteInCurrentArchive = isInSpecificArchive && namedArchives[currentArchiveName] && namedArchives[currentArchiveName].has(note.id);
                
                // Create the appropriate archive button
                let archiveButtonHtml = '';
                if (isInSpecificArchive && isNoteInCurrentArchive) {
                    // We're viewing a specific archive and this note is in it - show "Remove from [archive]"
                    archiveButtonHtml = `
                        <button class="btn btn-small" style="background: #e74c3c; color: white;" 
                                onclick="removeFromSpecificArchive('${note.id}', '${currentArchiveName}')">
                            Remove
                        </button>`;
                } else {
                    // Normal archive/unarchive button
                    archiveButtonHtml = `
                        <button class="btn btn-small btn-archive ${isArchived ? 'archived' : ''}" 
                                onclick="toggleArchiveNote('${note.id}')">
                            ${isArchived ? '✓ Archived' : '<span class="emoji"></span> Archive'}
                        </button>`;
                }
                
                html += `
    <div class="${cardClass}" data-note-id="${note.id}">
        <div class="note-header">
            <div style="display: flex; align-items: center; gap: 8px;">
                <input type="checkbox" class="note-checkbox" ${isSelected ? 'checked' : ''} 
                       onchange="toggleNoteSelection('${note.id}')">
                ${noteIndicator}
                <span onclick="copyNeventToClipboard('${note.id}')" 
                      class="date-copy-btn" 
                      title="Click to copy note link">
                    ${date}
                </span>
            </div>
            <div class="note-actions">
                ${archiveButtonHtml}
                <button class="btn btn-small btn-action-secondary" 
                        onclick="showNoteInfo('${note.id}')">
                    Info
                </button>
            </div>
        </div>
        <div class="note-content">${processMusicLinks(processYouTubeLinks(processImageLinks(makeLinksClickable(escapeHtml(note.content)))))}</div>
        ${hashtagsHtml ? `<div class="hashtags">${hashtagsHtml}</div>` : ''}
        ${createReactionsBoxHTML(note.id)}
    </div>
`;
            });
                
            // Update progress and yield control
            if (i % 100 === 0) {
                await new Promise(resolve => setTimeout(resolve, 1));
            }
        }
        
        container.innerHTML = html;
    setupLazyLoading();
    updateSelectionUI();
    setupHashtagDragSelection();
    
    // Fetch engagement stats for visible notes
    setTimeout(() => {
        const visibleNoteIds = notesToRender.map(note => note.id);
        fetchEngagementStats(visibleNoteIds);
        
        // Update reactions boxes after data loads
        setTimeout(() => {
            visibleNoteIds.forEach(noteId => {
                const reactionsBox = document.querySelector(`[data-note-id="${noteId}"] .reactions-box`);
                if (reactionsBox) {
                    const stats = getEngagementStats(noteId);
                    const total = stats.reactions + stats.zaps + stats.reposts + stats.quotes;
                    reactionsBox.textContent = `${total} engagement${total !== 1 ? 's' : ''}`;
                    reactionsBox.classList.remove('loading');
                }
            });
        }, 2000);
    }, 100);
}
    
    renderInChunks();
}


async function refreshNotes() {
    if (!currentPubkey) {
        showToast('No user connected - cannot refresh', 'error');
        return;
    }
    
    // Prevent refresh during background loading
    if (isBackgroundLoading) {
        showToast('Background loading in progress - please wait', 'warning');
        return;
    }
    
    const refreshBtn = document.getElementById('refresh-btn');
    if (refreshBtn) {
        refreshBtn.disabled = true;
        refreshBtn.textContent = 'Refreshing...';
    }
    
    try {
        // STEP 1: Check for new notes
        const newNotes = await fetchNotesFromRelaysSince(currentPubkey, allNotes[0]?.created_at || 0);
        
        if (newNotes.length > 0) {
            allNotes.unshift(...newNotes);
            allNotes.sort((a, b) => b.created_at - a.created_at);
            
            // Update storage
            const chunkStorage = new ChunkedNoteStorage(currentPubkey);
            const ready = await chunkStorage.init();
            if (ready) await chunkStorage.storeNotesInChunks(allNotes);
            
            updateTagFilters();
            applyFilters();
        }
        
        // STEP 2: CRITICAL - Clear ALL engagement data to force fresh fetch
        console.log('Clearing engagement cache for refresh...');
        processedEngagementEvents.clear();
        engagementCache.clear();
        cancelEngagementFetch = false;
        
        // Re-render to show "Loading..." state
        renderNotes();
        
        // STEP 3: Fetch fresh engagement data for ALL currently visible notes
        const notesContainer = document.getElementById('notes-container');
        const visibleNoteElements = notesContainer.querySelectorAll('.note-card');
        const visibleNoteIds = Array.from(visibleNoteElements).map(el => el.getAttribute('data-note-id')).filter(Boolean);

        console.log(`Fetching engagement for ${visibleNoteIds.length} visible notes...`);
        updateStatus(`Fetching engagement for ${visibleNoteIds.length} visible notes...`);
        
        // Fetch engagement with proper await
        await fetchEngagementStats(visibleNoteIds);
        
        // STEP 4: Wait for relay responses (15 seconds for better reliability)
        console.log('Waiting for relay responses...');
        await new Promise(resolve => setTimeout(resolve, 15000));
        
        // STEP 5: Update all engagement boxes with fresh data
        console.log('Updating engagement boxes...');
        let updatedCount = 0;
        visibleNoteIds.forEach(noteId => {
            const stats = getEngagementStats(noteId);
            const total = stats.reactions + stats.zaps + stats.reposts + stats.quotes;
            
            // Update the box in the DOM
            const reactionsBox = document.querySelector(`[data-note-id="${noteId}"] .reactions-box`);
            if (reactionsBox) {
                reactionsBox.textContent = `${total} engagement${total !== 1 ? 's' : ''}`;
                reactionsBox.classList.remove('loading');
                updatedCount++;
            }
            
            // Also update the popup if it exists
            const popup = document.getElementById('popup-' + noteId);
            if (popup) {
                const formattedSats = (stats.zapAmount || 0).toLocaleString();
                popup.innerHTML = `
                    <div class="reactions-popup-header">Engagement (${total})</div>
                    <div class="reaction-item">
                        <span>Reactions</span>
                        <span class="reaction-count">${stats.reactions}</span>
                    </div>
                    <div class="reaction-item">
                        <span>Zaps (${formattedSats} sats)</span>
                        <span class="reaction-count">${stats.zaps}</span>
                    </div>
                    <div class="reaction-item">
                        <span>Reposts</span>
                        <span class="reaction-count">${stats.reposts}</span>
                    </div>
                    <div class="reaction-item">
                        <span>Quotes</span>
                        <span class="reaction-count">${stats.quotes}</span>
                    </div>
                `;
            }
        });
        
        console.log(`Updated ${updatedCount} engagement boxes`);
        
        // Dismiss warning banner after successful refresh
        const warningBanner = document.getElementById('dismissible-banner');
        if (warningBanner) warningBanner.remove();
        
        // Success message
        if (newNotes.length > 0) {
            showToast(`${newNotes.length} new notes + ${updatedCount} engagement stats refreshed!`, 'success', 4000);
        } else {
            showToast(`No new notes - ${updatedCount} engagement stats refreshed!`, 'success', 4000);
        }
        
        updateStatus(`Refresh complete: ${newNotes.length} new notes, ${updatedCount} engagement stats updated`);
        
    } catch (error) {
        console.error('Refresh error:', error);
        showToast('Refresh failed: ' + error.message, 'error');
    } finally {
        // Re-enable refresh button
        if (refreshBtn) {
            refreshBtn.disabled = false;
            refreshBtn.textContent = 'Refresh Notes';
        }
    }
}

async function loadNotesIncremental(isRefresh = false) {
    const previousNotesCount = allNotes.length;
    
    try {
        if (isRefresh) {
            updateStatus('Checking for new notes...');
        } else {
            showLoading(true);
            updateStatus('Loading notes...', true);
        }
        
        // Get the timestamp of our newest note
        const newestNote = allNotes.length > 0 ? allNotes[0] : null;
        const sinceTimestamp = newestNote ? newestNote.created_at : 0;
        
        updateStatus(`Looking for notes newer than ${newestNote ? new Date(sinceTimestamp * 1000).toLocaleString() : 'beginning'}...`);
        
        // Fetch only newer notes
        const newNotes = await fetchNotesFromRelaysSince(currentPubkey, sinceTimestamp);
        
        if (newNotes.length > 0) {
            // Add new notes to the beginning of our array
            allNotes.unshift(...newNotes);
            allNotes.sort((a, b) => b.created_at - a.created_at);
            
            // Update chunked storage with new notes
            const chunkStorage = new ChunkedNoteStorage(currentPubkey);
            const chunkReady = await chunkStorage.init();
            
            if (chunkReady) {
                await chunkStorage.storeNotesInChunks(allNotes);
                updateStatus(`Updated chunked storage with ${newNotes.length} new notes`);
            }
            
            updateArchiveList();
            updateTargetArchiveDropdown();
            updateTagFilters();
            applyFilters();
            renderNotes();
            
            showToast(`Found ${newNotes.length} new notes!`, 'success');
        } else {
            showToast('No new notes found', 'success');
        }
        
        updateStatus(`✅ Refresh complete: ${newNotes.length} new notes (${allNotes.length} total)`);
        
    } catch (error) {
        console.error('Refresh failed:', error);
        showToast('Refresh failed: ' + error.message, 'error');
    } finally {
        if (!isRefresh) {
            showLoading(false);
        }
    }
}

async function loadNotesForced(isRefresh = false) {
    const previousNotesCount = allNotes.length;
    
    if (!isRefresh) {
        showLoading(true);
        updateProgress(0, 'Connecting to relays.');
        updateStatus('Starting fresh load...', true);
    } else {
        updateStatus('Refreshing notes from relays...');
    }
    
    try {
        let notes;
        
        if (isRefresh) {
            // Force fresh fetch from relays for refresh
            updateProgress(20, 'Fetching fresh notes from relays...');
            notes = await fetchNotesFromRelays(currentPubkey);
            
            // Store in chunked format after successful refresh
            const chunkStorage = new ChunkedNoteStorage(currentPubkey);
            const chunkReady = await chunkStorage.init();
            
            if (chunkReady && notes.length > 0) {
                await chunkStorage.storeNotesInChunks(notes);
                updateStatus(`Stored ${notes.length} notes in chunks after refresh`);
            }
        } else {
            // Original loading logic for non-refresh loads
            notes = await loadNotesHybrid(currentPubkey, false);
        }

        updateStatus(`Sorting ${notes.length} notes by date...`);
        await new Promise(resolve => setTimeout(resolve, 10));
        
        allNotes = notes.sort((a, b) => b.created_at - a.created_at);
        
        updateStatus('Updating archives list...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        updateArchiveList();
        updateTargetArchiveDropdown();
        
        updateStatus('Updating tag filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        updateTagFilters();
        
        updateStatus('Applying filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        applyFilters();
        
        updateStatus('Rendering notes...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        renderNotes();
        
       // Check if neon-green theme is active
const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
const checkmark = isNeonGreen ? '' : '✅ ';

const newNotesCount = allNotes.length - previousNotesCount;
updateStatus(`${checkmark}Successfully loaded ${allNotes.length} notes!`);

if (isRefresh) {
    if (newNotesCount > 0) {
        showToast(`Refresh complete - ${newNotesCount} new notes loaded (${allNotes.length} total)`, 'success');
    } else {
        showToast(`Refresh complete - no new notes found (${allNotes.length} total)`, 'success');
    }
}
        
    } catch (error) {
        console.error('Error loading notes:', error);
        showError('Failed to load notes: ' + error.message);
    } finally {
        if (!isRefresh) {
            showLoading(false);
            trackLoadTime();
        }
    }
}

function setupLazyLoading() {
    // Simple lazy loading for images
    const images = document.querySelectorAll('img[loading="lazy"]');
    
    if ('IntersectionObserver' in window) {
        const imageObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    if (img.dataset.src) {
                        img.src = img.dataset.src;
                        img.removeAttribute('data-src');
                    }
                    observer.unobserve(img);
                }
            });
        });
        
        images.forEach(img => imageObserver.observe(img));
    }
}

        function exportAsJSON() {
    const dataToExport = filteredNotes;
    
    let filterType;
    let displayName;
    
    if (currentTag.startsWith('__archive_')) {
        const archiveName = currentTag.replace('__archive_', '');
        filterType = archiveName;
        displayName = `Archive: ${archiveName}`;
    } else if (currentTag === '__original') {
        filterType = 'original-notes';
        displayName = 'Original Notes';
    } else if (currentTag === '__replies') {
        filterType = 'replies';
        displayName = 'Replies';
    } else if (currentTag) {
        filterType = currentTag;
        displayName = `Tag: ${currentTag}`;
    } else {
        filterType = 'all-notes';
        displayName = 'All Notes';
    }
    
    const data = {
        exported_at: new Date().toISOString(),
        filter_type: filterType,
        display_name: displayName,
        total_notes: dataToExport.length,
        notes: dataToExport.map(note => {
            const stats = getEngagementStats(note.id);
            return {
                id: note.id,
                date: new Date(note.created_at * 1000).toISOString(),
                content: note.content,
                hashtags: note.hashtags,
                archived: Object.values(namedArchives).some(archive => archive.has(note.id)),
                isReply: note.isReply,
                isRepost: note.isRepost,
                isQuote: note.isQuote,
                engagement: {
                    reactions: stats.reactions,
                    zaps: stats.zaps,
                    zap_amount_sats: stats.zapAmount,
                    reposts: stats.reposts,
                    quotes: stats.quotes,
                    total: stats.reactions + stats.zaps + stats.reposts + stats.quotes
                }
            };
        })
    };
    
    downloadFile(
        JSON.stringify(data, null, 2),
        `nostr-notes-${filterType}-${new Date().toISOString().split('T')[0]}.json`,
        'application/json'
    );
}

        function exportAsCSV() {
    const dataToExport = filteredNotes;
    
    const filterType = currentTag.startsWith('__archive_') 
        ? currentTag.replace('__archive_', '') 
        : currentTag === '__archived' ? 'My Archive' 
        : currentTag || 'All Notes';
    
    // CSV Header
    let csv = 'Date,Type,Content,Reactions,Zaps,Zap Amount (sats),Reposts,Quotes,Total Engagement,Hashtags,Archived,Note ID\n';
    
    dataToExport.forEach(note => {
        const date = new Date(note.created_at * 1000).toISOString();
        const isArchived = Object.values(namedArchives).some(archive => archive.has(note.id));
        
        // Determine note type
        let noteType = 'Original';
        if (note.isRepost) noteType = 'Repost';
        else if (note.isQuote) noteType = 'Quote';
        else if (note.isReply) noteType = 'Reply';
        
        // Get engagement stats
        const stats = getEngagementStats(note.id);
        const totalEngagement = stats.reactions + stats.zaps + stats.reposts + stats.quotes;
        
        // Escape content for CSV (handle quotes and newlines)
        const escapedContent = note.content
            .replace(/"/g, '""') // Escape quotes
            .replace(/\n/g, ' ') // Replace newlines with spaces
            .substring(0, 500); // Limit to 500 chars for readability
        
        // Build row
        csv += `"${date}",`;
        csv += `"${noteType}",`;
        csv += `"${escapedContent}",`;
        csv += `${stats.reactions},`;
        csv += `${stats.zaps},`;
        csv += `${stats.zapAmount || 0},`;
        csv += `${stats.reposts},`;
        csv += `${stats.quotes},`;
        csv += `${totalEngagement},`;
        csv += `"${note.hashtags.join(', ')}",`;
        csv += `"${isArchived ? 'Yes' : 'No'}",`;
        csv += `"${note.id}"\n`;
    });
    
    downloadFile(
        csv,
        `nostr-notes-${filterType.replace(/[^a-z0-9]/gi, '-').toLowerCase()}-${new Date().toISOString().split('T')[0]}.csv`,
        'text/csv'
    );
}

        function showNoteInfo(noteId) {
    const note = allNotes.find(n => n.id === noteId);
    if (!note) return;
    
    const date = new Date(note.created_at * 1000);
    const archiveStatus = Object.keys(namedArchives).filter(name => 
        namedArchives[name].has(noteId)
    );
    const nevent = createNevent(note);
    
    // Check if this note is part of a thread
    const threadNotes = getThreadNotes(noteId);
    const isThreaded = threadNotes.length > 1;
    
    // Thread icon removed - no emoji
    const threadIcon = '';
    
    // Thread info section (only show if part of thread)
    const threadSection = isThreaded ? `
        <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color);">
            <p><strong>${threadIcon}Thread:</strong> ${threadNotes.length} of your notes in this conversation</p>
            <button class="btn btn-small" onclick="showThreadView('${noteId}')" style="margin-top: 8px; width: 100%;">
                View Thread
            </button>
        </div>
    ` : '';
    
    const modalHtml = `
    <div class="modal" onclick="closeModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <button class="modal-close" onclick="closeModal()">Close</button>
            <h3>Note Information</h3> 
            <p><strong>Nevent:</strong><br><small style="word-break: break-all;">${nevent}</small></p>
                <p><strong>ID:</strong><br><small style="word-break: break-all;">${note.id}</small></p>
                <p><strong>Author:</strong><br><small style="word-break: break-all;">${note.pubkey}</small></p>
                <p><strong>Created:</strong> ${date.toLocaleString()}</p>
                <p><strong>Type:</strong> ${note.isRepost ? 'Repost (kind 6)' : note.isQuote ? 'Quote (kind 1)' : note.isReply ? 'Reply (kind 1)' : 'Original Note (kind 1)'}</p>
                <p><strong>Content Length:</strong> ${note.content.length} characters</p>
                <p><strong>Hashtags:</strong> ${note.hashtags.length > 0 ? note.hashtags.join(', ') : 'None'}</p>
                <p><strong>Archives:</strong> ${archiveStatus.length > 0 ? archiveStatus.join(', ') : 'Not archived'}</p>
                ${threadSection}
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function getThreadNotes(noteId) {
    const note = allNotes.find(n => n.id === noteId);
    if (!note) return [];
    
    // Find the root of the thread
    let rootId = noteId;
    
    // Check if this note is a reply
    if (note.tags && Array.isArray(note.tags)) {
        const eTags = note.tags.filter(tag => tag[0] === 'e');
        if (eTags.length > 0) {
            // The root is typically the first 'e' tag, or the one marked as 'root'
            const rootTag = eTags.find(tag => tag[3] === 'root') || eTags[0];
            if (rootTag && rootTag[1]) {
                rootId = rootTag[1];
            }
        }
    }
    
    // Find all YOUR notes that reference this root
    const threadNotes = allNotes.filter(n => {
        if (n.id === rootId) return true; // Include root if it's yours
        
        // Check if this note replies to the root
        if (n.tags && Array.isArray(n.tags)) {
            const eTags = n.tags.filter(tag => tag[0] === 'e');
            return eTags.some(tag => tag[1] === rootId);
        }
        
        return false;
    });
    
    // Sort chronologically (oldest first for conversation flow)
    return threadNotes.sort((a, b) => a.created_at - b.created_at);
}

function showThreadView(noteId) {
    // Close the Info modal first
    const infoModal = document.querySelector('.modal');
    if (infoModal) {
        infoModal.remove();
    }
    
    const threadNotes = getThreadNotes(noteId);
    
    if (threadNotes.length === 0) {
        showToast('No thread notes found', 'error');
        return;
    }
    
    // Check for neon-green theme (needed for note type emojis)
    const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
    
    // Thread icon removed - no emoji
    const threadIcon = '';
    
    // Build the thread display
    const threadHtml = threadNotes.map(note => {
    const date = new Date(note.created_at * 1000);
    const noteType = isNeonGreen ? '' : (note.isRepost ? '🔄 ' : note.isQuote ? '💭 ' : note.isReply ? '💬 ' : '📝 ');
    
    return `
        <div style="padding: 15px 0; margin-bottom: 20px; border-bottom: 1px solid var(--border-color);">
            <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 12px;">
                ${noteType}You • ${date.toLocaleString()}
            </div>
            <div style="white-space: pre-wrap; line-height: 1.6; padding-left: 0;">
                ${escapeHtml(note.content)}
            </div>
        </div>
    `;
}).join('');
    
    const modalHtml = `
        <div class="modal" onclick="closeThreadView(event)">
            <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 700px;">
                <button class="modal-close" onclick="closeThreadView()">Close</button>
                <div style="text-align: center; margin-bottom: 20px;">
    <h3>${threadIcon}Thread View</h3>
    <p style="color: var(--text-muted); margin-bottom: 0;">
        Showing ${threadNotes.length} of your notes in this conversation
    </p>
</div>
                <div class="thread-scroll" style="max-height: 50vh; overflow-y: auto; padding-right: 10px;">
                    ${threadHtml}
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}
function closeThreadView(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

function closeModal(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

        function createNevent(note) {
    try {
        if (!window.NostrTools || !window.NostrTools.nip19) {
            return 'NostrTools not available';
        }
        
        // Create nevent data
        const neventData = {
            id: note.id,
            relays: RELAYS.slice(0, 2), // Include first 2 relays
            author: note.pubkey
        };
        
        return window.NostrTools.nip19.neventEncode(neventData);
    } catch (error) {
        console.error('Error creating nevent:', error);
        return 'Error creating nevent';
    }
}

// REPLACE your existing clearAllCache function (around line 2600) with this enhanced version:

async function clearAllCache() {
    if (confirm('This will clear ALL data including cached notes, archives, and IndexedDB. This action cannot be undone. Continue?')) {
        try {
            // Cancel any ongoing operations FIRST
            isLoadingCancelled = true;
            
            // Cancel background loading
            if (backgroundLoadingTimeout) {
                clearTimeout(backgroundLoadingTimeout);
                backgroundLoadingTimeout = null;
            }
            
            // Close all active WebSocket connections
            activeWebSockets.forEach(ws => {
                if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
                    ws.close(1000, 'Cache cleared by user');
                }
            });
            activeWebSockets.clear();
            
            // Hide any loading indicators immediately
            hideBackgroundLoadingIndicator();
            showLoading(false);
            
            // Enhanced IndexedDB clearing - clear everything first
            await clearIndexedDBCompletely();
            
            // Clear chunked storage for current user
            if (currentPubkey) {
                await clearChunkStorage(currentPubkey);
            }
            
            // Only clear data for the current user, not all users
            if (currentPubkey) {
                // Clear cache data for current user
                localStorage.removeItem(`nostr-last-pubkey-${currentPubkey}`);
                localStorage.removeItem(`nostr-cached-notes-${currentPubkey}`);
                localStorage.removeItem(`nostr-cache-updated-at-${currentPubkey}`);
                
                // Clear archives for current user
                localStorage.removeItem(`nostr-archived-notes-${currentPubkey}`);
                localStorage.removeItem(`nostr-named-archives-${currentPubkey}`);
            }
            
            // Clear global settings (theme, etc.) but NOT other users' data
            localStorage.removeItem('nostr-saved-npub');
            localStorage.removeItem('archives-cleanup-done');
            
            // Reset all global variables
            currentPubkey = null;
            allNotes = [];
            filteredNotes = [];
            archivedNotes = new Set();
            namedArchives = {};
            currentTag = '';
            searchQuery = '';
            currentArchive = 'default';
            selectedNotes = new Set();
            selectedTags = new Set();
            
            // Clear quick filters
            activeQuickFilters.clear();
            document.querySelectorAll('.quick-filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Clear date filters
            document.getElementById('date-from').value = '';
            document.getElementById('date-to').value = '';
            
            // Clear search
            document.getElementById('search-input').value = '';
            
            // Clear the UI immediately
            document.getElementById('notes-container').innerHTML = '';
            document.getElementById('tag-filters').innerHTML = '<button class="tag-filter active" data-tag="">All Notes (0)</button>';
            document.getElementById('notes-count').textContent = '0 notes';
            document.getElementById('notes-title').textContent = 'All Notes';
            document.getElementById('archive-list').innerHTML = '<div style="color: #666; font-style: italic; font-size: 13px;">No archives created yet</div>';
            
            // Hide bulk controls and other UI elements
            document.getElementById('bulk-controls').classList.add('hidden');
            document.getElementById('load-more-container').classList.add('hidden');
            document.getElementById('empty-state').classList.add('hidden');
            
            // Reset database connection completely
            db = null;
            useIndexedDB = true; // Reset this flag
            
            // Go back to connection screen
            document.getElementById('main-app').classList.add('hidden');
            document.getElementById('connection-screen').classList.remove('hidden');
            document.getElementById('pubkey-input').value = '';
            
            showToast('All data cleared successfully! Please reconnect.', 'success');
            
            // Reset cancellation flag after everything is done
            isLoadingCancelled = false;
            
        } catch (error) {
            console.error('Error clearing data:', error);
            showToast('Error clearing some data: ' + error.message, 'error');
            
            // Reset cancellation flag even on error
            isLoadingCancelled = false;
        }
    }
}

// ADD this new function to handle IndexedDB clearing:
async function clearIndexedDBCompletely() {
    try {
        // Close current database connection if open
        if (db && db.isOpen()) {
            // Clear all data before closing
            try {
                await db.notes.clear();
                await db.settings.clear();
            } catch (error) {
                console.log('Error clearing tables before close:', error);
            }
            await db.close();
        }
        
        // Clear the specific databases for current user
        if (currentPubkey) {
            const databases = [
                `nostr-notes-${currentPubkey}`,
                `nostr-chunks-${currentPubkey}`
            ];
            
            for (const dbName of databases) {
                // Delete the database entirely
                if (window.indexedDB && window.indexedDB.deleteDatabase) {
                    await new Promise((resolve, reject) => {
                        const deleteReq = window.indexedDB.deleteDatabase(dbName);
                        
                        deleteReq.onsuccess = () => {
                            console.log(`IndexedDB ${dbName} deleted successfully`);
                            resolve();
                        };
                        
                        deleteReq.onerror = (event) => {
                            console.error(`Error deleting IndexedDB ${dbName}:`, event.target.error);
                            resolve(); // Don't reject - continue with cleanup
                        };
                        
                        deleteReq.onblocked = () => {
                            console.warn(`IndexedDB ${dbName} deletion blocked`);
                            // Force resolve after delay
                            setTimeout(resolve, 2000);
                        };
                        
                        // Timeout safety
                        setTimeout(() => {
                            console.warn('IndexedDB deletion timeout');
                            resolve();
                        }, 5000);
                    });
                }
            }
        }
        
        // Reset database variables completely
        db = null;
        useIndexedDB = true; // Reset this flag so it will try IndexedDB again
        
        console.log('IndexedDB cleared completely');
        
    } catch (error) {
        console.error('Error clearing IndexedDB completely:', error);
        // Reset variables anyway
        db = null;
        useIndexedDB = true;
    }
}

// OPTIONAL: Add a separate "Clear IndexedDB Only" function for debugging
async function clearIndexedDBOnly() {
    if (confirm('Clear IndexedDB cache only? (Archives and settings will be preserved)')) {
        try {
            await clearIndexedDB();
            showToast('IndexedDB cleared. Notes will be refetched from relays on next load.', 'success');
        } catch (error) {
            showToast('Error clearing IndexedDB: ' + error.message, 'error');
        }
    }
}

                function loadMoreNotes() {
            currentPage++;
            renderNotes();
        }

        function resetPagination() {
    currentPage = 1;
}

        function updateProgress(percent, text) {
            const progressFill = document.getElementById('progress-fill');
            const loadingText = document.getElementById('loading-text');
            
            if (progressFill) {
                progressFill.style.width = `${percent}%`;
                progressFill.textContent = `${Math.round(percent)}%`;
            }
            if (loadingText && text) {
                loadingText.textContent = text;
            }
        }

       // REPLACE the existing updateStatus function with this enhanced version:
function updateStatus(text, clearPrevious = false) {
    const statusInfo = document.getElementById('status-info');
    if (statusInfo) {
        if (clearPrevious) {
            statusInfo.innerHTML = text + '<br>';
        } else {
            // Limit status history to prevent UI overflow
            const lines = statusInfo.innerHTML.split('<br>');
            if (lines.length > 10) {
                lines.splice(0, lines.length - 8); // Keep last 8 lines
                statusInfo.innerHTML = lines.join('<br>');
            }
            statusInfo.innerHTML += text + '<br>';
        }
        
        // Auto-scroll to bottom
        statusInfo.scrollTop = statusInfo.scrollHeight;
    }
}

// Toast notification system
// Add these variables at the top of your script
let activeToasts = new Set();
let toastTimeout = null;

// Replace your existing showToast function with this:
function showToast(message, type = 'success', duration = 3000) {
    // Prevent duplicate toasts
    if (activeToasts.has(message)) {
        return;
    }
    
    // Clear any pending toast timeout
    if (toastTimeout) {
        clearTimeout(toastTimeout);
    }
    
    // Add to active toasts
    activeToasts.add(message);
    
    // Remove existing toasts of the same type
    document.querySelectorAll(`.toast.${type}`).forEach(existingToast => {
        existingToast.remove();
    });
    
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    
    document.body.appendChild(toast);
    
    // Trigger animation
    setTimeout(() => toast.classList.add('show'), 10);
    
    // Remove after duration
    toastTimeout = setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            if (document.body.contains(toast)) {
                document.body.removeChild(toast);
            }
            activeToasts.delete(message);
        }, 300);
    }, duration);
}

function showDismissibleBanner(message, type = 'warning') {
    // Remove any existing banner first
    const existingBanner = document.getElementById('dismissible-banner');
    if (existingBanner) existingBanner.remove();
    
    const banner = document.createElement('div');
    banner.id = 'dismissible-banner';
    banner.className = `dismissible-banner ${type}`;
    banner.innerHTML = `
        <span>${message}</span>
        <button onclick="this.parentElement.remove()" style="
            background: none;
            border: none;
            color: inherit;
            font-size: 20px;
            cursor: pointer;
            padding: 0 8px;
            margin-left: 12px;
        ">×</button>
    `;
    
    // Insert at the top of main-app
    const mainApp = document.getElementById('main-app');
    mainApp.insertBefore(banner, mainApp.firstChild);
}

        // Utility functions
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showLoading(show) {
            document.getElementById('loading').classList.toggle('hidden', !show);
        }

        function showError(message) {
            const errorEl = document.getElementById('connection-error');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function hideError() {
            document.getElementById('connection-error').style.display = 'none';
        }

        function copyToClipboard(text) {
    // Prevent rapid double-clicks
    const button = event.target;
    if (button.disabled) return;
    
    // Disable button temporarily
    button.disabled = true;
    
    navigator.clipboard.writeText(text).then(function() {
        // Store original state
        const originalText = button.textContent;
        const originalBg = button.style.background;
        
        // Show success state with the button's current theme color
        button.textContent = 'Copied!';
        // Get the actual computed background color of the button (accounts for all themes)
        const computedBg = window.getComputedStyle(button).backgroundColor;
        button.style.background = computedBg;
        
        // Reset after 1 second (reduced from 1.5s for snappier feel)
        setTimeout(() => {
            button.textContent = originalText;
            button.style.background = originalBg;
            button.disabled = false; // Re-enable button
            
            // Force remove any stuck focus/active states
            button.blur();
        }, 1000);
    }).catch(function(err) {
        console.error('Could not copy text: ', err);
        showToast('Copy failed. Please select and copy manually.', 'error');
        button.disabled = false; // Re-enable on error
    });
}

function triggerFileImport() {
    document.getElementById('import-file').click();
}



async function handleFileImport(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const fileName = file.name.toLowerCase();
    
    try {
        const content = await file.text();
        
        if (fileName.endsWith('.json')) {
            await importFromJSON(content);
        } else {
            showToast('Only JSON files are supported for import', 'error');
        }
    } catch (error) {
        console.error('Import error:', error);
        showToast('Error reading file: ' + error.message, 'error');
    }
    
    // Reset file input
    event.target.value = '';
}

async function importFromJSON(jsonContent) {
    try {
        const data = JSON.parse(jsonContent);
        
        // Validate the JSON structure
        if (!data.notes || !Array.isArray(data.notes)) {
            throw new Error('Invalid JSON format - missing notes array');
        }
        
        let importedCount = 0;
        let archivesToCreate = new Set();
        let notesToArchive = [];
        
        // Process each note from the import
        // Process each note from the import with debugging
let foundById = 0;
let foundByContent = 0;
let notFound = 0;
let archivedTrue = 0;
let archivedFalse = 0;

data.notes.forEach(importedNote => {
    const existingNote = allNotes.find(note => 
    note.id === importedNote.id
    // Temporarily comment out content matching
    // || note.content.replace(/\s+/g, ' ').trim() === importedNote.content.replace(/\s+/g, ' ').trim()
);
    
    if (existingNote) {
        if (existingNote.id === importedNote.id) foundById++;
        else foundByContent++;
        
        if (importedNote.archived || importedNote.archiveName) {
    archivedTrue++;
    
    // Use the original archive name from the export
    let archiveName = 'Imported Archive'; // Default fallback
    
    if (data.filter_type && data.filter_type !== 'all-notes') {
        // Use the filter_type from the export
        archiveName = data.filter_type;
    } else if (data.display_name && data.display_name !== 'All Notes') {
        // Or use the display_name if filter_type is generic
        archiveName = data.display_name.replace('Archive: ', '').replace('Tag: ', '');
    }
    
    archivesToCreate.add(archiveName);
            notesToArchive.push({
                noteId: existingNote.id,
                archiveName: archiveName
            });
            importedCount++;
        } else {
            archivedFalse++;
        }
    } else {
        notFound++;
    }
});
        
        if (importedCount === 0) {
            showToast('No matching notes found to import', 'warning');
            return;
        }
        
        // Create archives if they don't exist
        archivesToCreate.forEach(archiveName => {
            if (!namedArchives[archiveName]) {
                namedArchives[archiveName] = new Set();
            }
        });
        
        // Add notes to archives
        notesToArchive.forEach(({ noteId, archiveName }) => {
            namedArchives[archiveName].add(noteId);
        });
        
        // Save and update UI
        saveArchivedNotes();
        updateArchiveList();
        updateTagFilters();
        renderNotes();
        
        showToast(`Successfully imported ${importedCount} archived notes!`, 'success');
        
    } catch (error) {
        console.error('JSON import error:', error);
        showToast('Error importing JSON: ' + error.message, 'error');
    }
}

function removeFromSpecificArchive(noteId, archiveName) {
    if (!namedArchives[archiveName]) return;
    
    namedArchives[archiveName].delete(noteId);
    saveArchivedNotes();
    updateArchiveList();
    updateTagFilters();
    renderNotes();
    
    showToast(`Removed note from "${archiveName}" archive`, 'success');
}

let isSelecting = false;
let selectionStarted = false;
let selectionMode = null; // 'add' or 'remove'

function startHashtagSelection(tag, event) {
    event.preventDefault();
    event.stopPropagation();
    
    // Detect if this is a touch event or mouse event
    const isTouchEvent = event.type === 'touchstart';
    
    // Store initial position to detect if this is a drag or click
    const startX = isTouchEvent ? event.touches[0].clientX : event.clientX;
    const startY = isTouchEvent ? event.touches[0].clientY : event.clientY;
    const startTime = Date.now();
    
    // Set up temporary move listener to detect drag
    let hasMoved = false;
    const moveHandler = (moveEvent) => {
        const currentX = isTouchEvent ? moveEvent.touches[0].clientX : moveEvent.clientX;
        const currentY = isTouchEvent ? moveEvent.touches[0].clientY : moveEvent.clientY;
        const deltaX = Math.abs(currentX - startX);
        const deltaY = Math.abs(currentY - startY);
        
        // If moved more than 5 pixels, consider it a drag
        if (deltaX > 5 || deltaY > 5) {
            hasMoved = true;
            startDragMode(tag);
        }
    };
    
    // Set up temporary end listener
    const endHandler = (endEvent) => {
        // Remove both touch and mouse listeners
        document.removeEventListener('touchmove', moveHandler);
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('touchend', endHandler);
        document.removeEventListener('mouseup', endHandler);
        
        const timeDiff = Date.now() - startTime;
        
        // If it was a quick tap/click without movement, treat as single click
        if (!hasMoved && timeDiff < 300) {
            handleSingleTagClick(tag);
        }
        
        // End any drag operation
        endHashtagSelection();
    };
    
    // Add listeners for both touch and mouse events
    if (isTouchEvent) {
        document.addEventListener('touchmove', moveHandler);
        document.addEventListener('touchend', endHandler);
    } else {
        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', endHandler);
    }
}

function startDragMode(tag) {
    if (isSelecting) return; // Already in drag mode
    
    isSelecting = true;
    selectionStarted = true;
    
    // Clear any existing archive/filter selections when starting hashtag selection
    currentArchive = 'default';
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Determine selection mode based on current state of clicked tag
    if (selectedTags.has(tag)) {
        selectionMode = 'remove';
        selectedTags.delete(tag);
    } else {
        selectionMode = 'add';
        selectedTags.add(tag);
    }
    
    // Update visuals immediately without full render
    updateHashtagVisualsOnly();
    updateCountOnly();
    setActiveTagButtons();
    
    // Prevent text selection during drag
    document.body.style.userSelect = 'none';
    document.body.style.webkitUserSelect = 'none';
    document.body.style.mozUserSelect = 'none';
    
    // Add visual feedback for drag mode
    document.body.classList.add('hashtag-selecting');
}

function handleSingleTagClick(tag) {
    // This handles normal single-click behavior
    toggleTag(tag);
}

let hashtagUpdateTimeout = null;

function continueHashtagSelection(tag, event) {
    if (isSelecting && selectionStarted && selectionMode) {
        event.preventDefault();
        event.stopPropagation();
        
        let changed = false;
        
        if (selectionMode === 'add') {
            if (!selectedTags.has(tag)) {
                selectedTags.add(tag);
                changed = true;
            }
        } else if (selectionMode === 'remove') {
            if (selectedTags.has(tag)) {
                selectedTags.delete(tag);
                changed = true;
            }
        }
        
        if (changed) {
            // Throttle to 60fps
            if (!hashtagUpdateTimeout) {
                hashtagUpdateTimeout = setTimeout(() => {
                    updateHashtagVisualsOnly();
                    updateCountOnly();
                    setActiveTagButtons();
                    hashtagUpdateTimeout = null;
                }, 16);
            }
        }
    }
}

function endHashtagSelection() {
    if (selectionStarted) {
        isSelecting = false;
        selectionStarted = false;
        selectionMode = null;
        
        // Restore text selection
        document.body.style.userSelect = '';
        document.body.style.webkitUserSelect = '';
        document.body.style.mozUserSelect = '';
        document.body.classList.remove('hashtag-selecting');
        
        // Now do the full render and filter update
        applyFilters();
        renderNotes();
    }
}

function updateHashtagVisualsOnly() {
    const elements = document.querySelectorAll('.hashtag');
    elements.forEach(hashtagElement => {
        const tag = hashtagElement.dataset.tag || hashtagElement.textContent;
        const isSelected = selectedTags.has(tag);
        
        if (isSelected) {
            hashtagElement.setAttribute('data-selected', 'true');
            hashtagElement.style.backgroundColor = 'var(--primary-color)';
            hashtagElement.style.color = 'white';
            hashtagElement.style.borderColor = 'var(--primary-color)';
        } else {
            hashtagElement.removeAttribute('data-selected');
            hashtagElement.style.backgroundColor = '';
            hashtagElement.style.color = '';
            hashtagElement.style.borderColor = '';
        }
    });
}

// Helper function to update count without full render
function updateCountOnly() {
    // Quick filter update without full processing
    let quickCount = 0;
    if (selectedTags.size > 0) {
        const tags = Array.from(selectedTags);
        quickCount = allNotes.filter(note =>
            tags.some(tag => noteMatchesTag(note, tag))
        ).length;
    } else {
        quickCount = allNotes.length;
    }
    
    document.getElementById('notes-count').textContent = `${quickCount} notes`;
}

function extractVideoId(url) {
    const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
        /youtube\.com\/watch\?.*v=([^&\n?#]+)/
    ];
    
    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) return match[1];
    }
    return null;
}

function processYouTubeLinks(content) {
    // More flexible regex that can find YouTube URLs even after "Reposted: " prefix
    const youtubeRegex = /(https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)[^\s"<>]+)/g;
    
    return content.replace(youtubeRegex, (url) => {
        const videoId = extractVideoId(url);
        if (!videoId) return url;
        
        return `<div class="youtube-preview" onclick="loadYouTubeThumbnail(this, '${url}', '${videoId}')" style="
            border: 1px dashed var(--border-color);
            padding: 20px;
            margin: 8px 0;
            border-radius: 6px;
            background: var(--background-color);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        " onmouseover="this.style.borderColor='var(--primary-color)'; this.style.color='var(--primary-color)'" 
           onmouseout="this.style.borderColor='var(--border-color)'; this.style.color='var(--text-muted)'">
            Click to load YouTube video
        </div>`;
    });
}

function processMusicLinks(content) {
    // Match song.link, Spotify (track/album/playlist), YouTube Music, and Apple Music URLs
    const musicRegex = /(https?:\/\/(?:song\.link\/[^\s"<>]+|open\.spotify\.com\/(?:track|album|playlist)\/[^\s"<>]+|music\.youtube\.com\/watch\?v=[^\s"<>]+|music\.apple\.com\/[^\s"<>]+))/g;
    
    return content.replace(musicRegex, (url) => {
        let serviceName = 'Music';
        let embedUrl = '';
        
        if (url.includes('song.link/')) {
            serviceName = 'Song';
            // song.link embeds work with odesli.co
            const songId = url.split('song.link/')[1].split(/[?#]/)[0];
            embedUrl = `https://odesli.co/embed/?url=${encodeURIComponent(url)}&theme=dark`;
        } else if (url.includes('open.spotify.com/')) {
            serviceName = 'Spotify';
            // Handle track, album, or playlist
            const typeMatch = url.match(/spotify\.com\/(track|album|playlist)\/([a-zA-Z0-9]+)/);
            if (typeMatch) {
                const [, type, id] = typeMatch;
                embedUrl = `https://open.spotify.com/embed/${type}/${id}`;
            }
        } else if (url.includes('music.youtube.com/watch')) {
            serviceName = 'YouTube Music';
            const videoId = url.match(/[?&]v=([^&]+)/)?.[1];
            if (videoId) {
                embedUrl = `https://www.youtube.com/embed/${videoId}`;
            }
        } else if (url.includes('music.apple.com/')) {
            serviceName = 'Apple Music';
            embedUrl = url.replace('music.apple.com', 'embed.music.apple.com');
        }
        
        if (!embedUrl) return url;
        
        return `<div class="music-preview" onclick="loadMusicEmbed(this, '${embedUrl}', '${serviceName}')" style="
            border: 1px dashed var(--border-color);
            padding: 20px;
            margin: 8px 0;
            border-radius: 6px;
            background: var(--background-color);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        " onmouseover="this.style.borderColor='var(--primary-color)'; this.style.color='var(--primary-color)'" 
           onmouseout="this.style.borderColor='var(--border-color)'; this.style.color='var(--text-muted)'">
            🎵 Click to load ${serviceName} player
        </div>`;
    });
}

function processImageLinks(content) {
    // Match <a> tags that link to images
    const imageRegex = /<a href="(https?:\/\/[^"]+\.(?:jpg|jpeg|png|gif|webp)(?:\?[^"]*)?)"[^>]*>.*?<\/a>/gi;
    
    return content.replace(imageRegex, (match, url) => {
        return `<div class="image-preview" onclick="loadImage(this, '${url}')" style="
            border: 1px dashed var(--border-color);
            padding: 20px;
            margin: 8px 0;
            border-radius: 6px;
            background: var(--background-color);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        " onmouseover="this.style.borderColor='var(--primary-color)'; this.style.color='var(--primary-color)'" 
           onmouseout="this.style.borderColor='var(--border-color)'; this.style.color='var(--text-muted)'">
            Click to load image
        </div>`;
    });
}

function loadImage(element, url) {
  // render the image
  element.innerHTML = `
    <div style="position: relative; text-align: center; display: flex; justify-content: center;">
      <img class="note-image"
           src="${url}"
           alt="Image"
           loading="lazy"
           onerror="this.style.display='none'"
           style="max-width: 100%; height: auto; border-radius: 8px; display: block;">
    </div>`;
  // make the WHOLE dotted box clickable to close
  element.setAttribute('onclick', `closeImage(this, '${url}')`);
}

function closeImage(element, url) {
  // restore the preview state on the SAME dotted box
  element.innerHTML = `Click to load image`;
  element.setAttribute('onclick', `loadImage(this, '${url}')`);
  // (mouseover/out styles were already on the outer box, so they keep working)
}

function loadYouTubeThumbnail(element, url, videoId) {
  const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
  element.innerHTML = `
    <div style="position: relative; text-align: center; display: flex; justify-content: center;">
      <div class="youtube-thumbnail"
           onclick="event.stopPropagation(); window.open('${url}', '_blank')">
        <img src="${thumbnailUrl}" alt="YouTube Video" loading="lazy"
             onerror="this.src='https://img.youtube.com/vi/${videoId}/hqdefault.jpg'">
        <div class="play-button"></div>
      </div>
    </div>`;
  // make the WHOLE dotted box clickable to close
  element.setAttribute('onclick', `closeYouTube(this, '${url}', '${videoId}')`);
}

function closeYouTube(element, url, videoId) {
  // restore the preview state on the SAME dotted box
  element.innerHTML = `Click to load YouTube video`;
  element.setAttribute('onclick', `loadYouTubeThumbnail(this, '${url}', '${videoId}')`);
}

function loadMusicEmbed(element, embedUrl, serviceName) {
  element.innerHTML = `
    <div style="position: relative; width: 100%; max-width: 100%;">
      <iframe src="${embedUrl}"
              width="100%"
              height="152"
              frameborder="0"
              allow="encrypted-media; autoplay; clipboard-write; picture-in-picture"
              loading="lazy"
              style="border-radius: 8px; max-width: 100%;">
      </iframe>
    </div>`;
  element.setAttribute('onclick', `closeMusicEmbed(this, '${embedUrl}', '${serviceName}')`);
}

function closeMusicEmbed(element, embedUrl, serviceName) {
  element.innerHTML = `🎵 Click to load ${serviceName} player`;
  element.setAttribute('onclick', `loadMusicEmbed(this, '${embedUrl}', '${serviceName}')`);
}

function makeLinksClickable(content) {
    // Match all URLs (http, https)
    const urlRegex = /(https?:\/\/[^\s<>"]+)/gi;
    
    return content.replace(urlRegex, (url) => {
        // Skip YouTube URLs (they're handled by processYouTubeLinks)
        const youtubeRegex = /(youtube\.com\/watch\?v=|youtu\.be\/)/i;
        if (youtubeRegex.test(url)) {
            return url;
        }
        
        // Skip music URLs - they'll be handled by processMusicLinks
        if (url.includes('song.link/') || 
            url.includes('open.spotify.com/track/') ||
            url.includes('open.spotify.com/album/') ||
            url.includes('open.spotify.com/playlist/') ||
            url.includes('music.youtube.com/watch') || 
            url.includes('music.apple.com/')) {
            return url;
        }
        
        // Make ALL URLs clickable (INCLUDING images - processImageLinks will handle them later)
        return `<a href="${url}" rel="noopener noreferrer" style="color: var(--primary-color); text-decoration: underline; word-break: break-all;">${url}</a>`;
    });
}


// Enhanced advanced search using smart filter engine
async function performAdvancedSearch(query, filters = {}) {
    try {
        // Initialize smart filter engine
        const chunkStorage = new ChunkedNoteStorage(currentPubkey);
        const ready = await chunkStorage.init();
        
        if (!ready) {
            return performInMemorySearch(query, filters);
        }
        
        const filterEngine = new SmartFilterEngine(chunkStorage);
        
        // Build comprehensive filter object
        const smartFilters = {
            searchText: query,
            hashtags: [],
            dateFrom: filters.dateFrom,
            dateTo: filters.dateTo,
            contentType: filters.contentType,
            hasImages: filters.hasImages,
            hasYouTube: filters.hasYouTube,
            hasLinks: filters.hasLinks,
            hasMusic: filters.hasMusic,
            minLength: filters.minLength,
            maxLength: filters.maxLength
        };
        
        // Add selected hashtags to filter
        if (selectedTags.size > 0) {
            selectedTags.forEach(tag => {
                if (tag.startsWith('#')) {
                    smartFilters.hashtags.push(tag);
                } else if (tag === '__original') {
                    smartFilters.contentType = 'original';
                } else if (tag === '__replies') {
                    smartFilters.contentType = 'replies';
                }
            });
        }
        
        // Get estimated count first
        const estimatedCount = await filterEngine.getEstimatedCount(smartFilters);
        updateStatus(`Estimated ${estimatedCount} matching notes across chunks`);
        
        // Load filtered notes
        const results = await filterEngine.loadFilteredNotes(smartFilters, 50000); // Load up to 50k results
        
        updateStatus(`Found ${results.length} notes matching filters`);
        return results;
        
    } catch (error) {
        console.error('Smart search error:', error);
        return performInMemorySearch(query, filters);
    }
}

function performInMemorySearch(query, filters) {
    let results = allNotes.slice();
    
    // Apply date filters
    if (filters.dateFrom) {
        const fromTimestamp = Math.floor(filters.dateFrom.getTime() / 1000);
        results = results.filter(note => note.created_at >= fromTimestamp);
    }
    
    if (filters.dateTo) {
        const toTimestamp = Math.floor(filters.dateTo.getTime() / 1000);
        results = results.filter(note => note.created_at <= toTimestamp);
    }
    
    // Apply content type filters
    if (filters.contentType === 'original') {
        results = results.filter(note => !note.isReply && !note.isRepost && !note.isQuote);
    } else if (filters.contentType === 'replies') {
        results = results.filter(note => note.isReply);
    } else if (filters.contentType === 'reposts') {
        results = results.filter(note => note.isRepost);
    } else if (filters.contentType === 'quotes') {
        results = results.filter(note => note.isQuote);
    }
    
    // Apply length filters
    if (filters.minLength) {
        results = results.filter(note => note.content.length >= filters.minLength);
    }
    
    if (filters.maxLength) {
        results = results.filter(note => note.content.length <= filters.maxLength);
    }
    
    // Apply image filter
    if (filters.hasImages) {
        const imageRegex = /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp))/gi;
        results = results.filter(note => imageRegex.test(note.content));
    }
    
    // Apply YouTube filter
    if (filters.hasYouTube) {
        const youtubeRegex = /(youtube\.com\/watch\?v=|youtu\.be\/)/gi;
        results = results.filter(note => youtubeRegex.test(note.content));
    }
    
    // Apply links filter
    if (filters.hasLinks) {
        results = results.filter(note => {
            // Match all URLs
            const allUrls = note.content.match(/https?:\/\/[^\s<>"]+/gi) || [];
            
            if (allUrls.length === 0) return false; // No links at all
            
            // If we're ALSO filtering for images or videos, allow those
            if (filters.hasImages || filters.hasYouTube) {
                return true; // Already has links, and we want images/videos
            }
            
            // If links-only filter, exclude notes that ONLY have images/videos
            const imageRegex = /\.(jpg|jpeg|png|gif|webp)(\?[^\s"<>]*)?$/i;
            const youtubeRegex = /(youtube\.com\/watch\?v=|youtu\.be\/)/i;
            
            // Check if there's at least one link that's NOT just an image or video
            return allUrls.some(url => !imageRegex.test(url) && !youtubeRegex.test(url));
        });
    }
    
    // Apply music filter
    if (filters.hasMusic) {
        const musicRegex = /(song\.link\/|open\.spotify\.com\/(track|album|playlist)\/|music\.youtube\.com\/watch|music\.apple\.com\/)/i;
        results = results.filter(note => musicRegex.test(note.content));
    }
    
    // Apply text search
    if (query && query.trim()) {
        const searchTerms = query.toLowerCase().split(/\s+/);
        results = results.filter(note => {
            const searchText = (note.content + ' ' + (note.hashtags || []).join(' ')).toLowerCase();
            
            // Check content and hashtags
            const matchesContent = searchTerms.every(term => searchText.includes(term));
            if (matchesContent) return true;
            
            // NEW: Also check reply target npub
            if (note.isReply) {
                const replyTargetNpub = getReplyTargetNpub(note);
                if (replyTargetNpub) {
                    const matchesNpub = searchTerms.every(term => 
                        replyTargetNpub.toLowerCase().includes(term)
                    );
                    if (matchesNpub) return true;
                }
                
                // Also check hex pubkey
                if (note.tags && Array.isArray(note.tags)) {
                    const pTags = note.tags.filter(tag => tag[0] === 'p' && tag[1]);
                    if (pTags.length > 0) {
                        const targetPubkey = pTags[0][1];
                        const matchesHex = searchTerms.every(term => 
                            targetPubkey.toLowerCase().includes(term)
                        );
                        if (matchesHex) return true;
                    }
                }
            }
            
            return false;
        });
    }
    
    return results;
}

// Track active quick filters
// Track active quick filters
let activeQuickFilters = new Set();

function toggleQuickFilter(type, buttonElement) {
    console.log('toggleQuickFilter called:', type);
    console.log('activeQuickFilters before:', Array.from(activeQuickFilters));
    
    const button = buttonElement || document.querySelector(`[data-filter="${type}"]`);
    
    // Define which filters are date-based (mutually exclusive)
    const dateFilters = ['week', 'month', '6months', 'year'];
    
    if (activeQuickFilters.has(type)) {
    // Remove filter
    activeQuickFilters.delete(type);
    button.classList.remove('active');
    // Force reflow for immediate visual update on mobile
    void button.offsetHeight;
    
    // CHECK: After removing this filter, are there ANY content filters left?
    const hasContentFilters = 
        activeQuickFilters.size > 0 || 
        selectedTags.size > 0 || 
        searchQuery || 
        document.getElementById('date-from').value || 
        document.getElementById('date-to').value ||
        (currentArchive !== 'default' && currentTag.startsWith('__archive_'));
    
    // If NO content filters remain, clear the "most" sort mode
    if (!hasContentFilters && currentSortMode) {
        console.log('No content filters remain - clearing sort mode');
        cancelEngagementFetch = true;
        currentSortMode = null;
        const dropdown = document.getElementById('secondary-filter-dropdown');
        if (dropdown) dropdown.value = '';
    }
    
    // Check what's still active
    if (activeQuickFilters.size === 0 && selectedTags.size === 0 && !searchQuery) {
        if (currentSortMode) {
            // Only sort mode is active - apply it to ALL notes
            applyAllFilters();
        } else {
            // Nothing active at all - back to All Notes
            window.inAdvancedSearchMode = false;
            allNotes.sort((a, b) => b.created_at - a.created_at);
            filteredNotes = allNotes.slice();
            resetPagination();
            renderNotes();
            document.getElementById('notes-title').textContent = 'All Notes';
            document.getElementById('notes-count').textContent = `${allNotes.length} notes`;
            return;
        }
    } else {
        // Other filters still active - reapply everything
        applyAllFilters();
    }
    } else {
    // MOVED TO TOP: Clear "most" filter FIRST when ACTIVATING a quick filter
    currentSortMode = null;
    const dropdown = document.getElementById('secondary-filter-dropdown');
    if (dropdown) dropdown.value = '';
    
    // If this is a date filter, clear other date filters first
    if (dateFilters.includes(type)) {
        dateFilters.forEach(dateFilter => {
            if (dateFilter !== type && activeQuickFilters.has(dateFilter)) {
                activeQuickFilters.delete(dateFilter);
                const otherBtn = document.querySelector(`[data-filter="${dateFilter}"]`);
                otherBtn.classList.remove('active');
                // Force reflow for immediate visual update on mobile
                void otherBtn.offsetHeight;
            }
        });
        
        // Clear manual date inputs when selecting a quick date filter
        document.getElementById('date-from').value = '';
        document.getElementById('date-to').value = '';
    }
    
    // Add filter
    activeQuickFilters.add(type);
    button.classList.add('active');
    // Force reflow for immediate visual update on mobile
    void button.offsetHeight;
}
    
    console.log('activeQuickFilters after toggle:', Array.from(activeQuickFilters));
    
    // Update "All Notes" button state
    document.querySelectorAll('.tag-filter').forEach(btn => {
        if (btn.dataset.tag === '') {
            if (selectedTags.size === 0 && activeQuickFilters.size === 0 && !currentSortMode) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }
    });
    
    // Apply combined filters with debouncing
    clearTimeout(filterDebounceTimeout);
    filterDebounceTimeout = setTimeout(() => {
        applyAllFilters();
    }, 150);
}


async function applyAllFilters() {
    showFilteringIndicator();

    const query = document.getElementById('search-input').value;
    const filters = {};
    
    // CHECK DROPDOWN VALUE and add it to activeQuickFilters temporarily
    const dropdown = document.getElementById('secondary-filter-dropdown');
    const dropdownValue = dropdown ? dropdown.value : '';
    
    // Process quick filters - find the EARLIEST date from all active filters
    let earliestDate = null;
    
    // Combine activeQuickFilters with dropdown value
    const allFilters = new Set(activeQuickFilters);
    if (dropdownValue && !dropdownValue.startsWith('most-')) {
        allFilters.add(dropdownValue);
    }
    
    allFilters.forEach(filterType => {
        const now = new Date();
        
        switch(filterType) {
            case 'week':
                const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                if (!earliestDate || weekAgo < earliestDate) {
                    earliestDate = weekAgo;
                }
                break;
                
            case 'month':
                const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                if (!earliestDate || monthAgo < earliestDate) {
                    earliestDate = monthAgo;
                }
                break;
                
            case '6months':
                const sixMonthsAgo = new Date(now.getTime() - 182 * 24 * 60 * 60 * 1000);
                if (!earliestDate || sixMonthsAgo < earliestDate) {
                    earliestDate = sixMonthsAgo;
                }
                break;
                
            case 'year':
                const yearAgo = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
                if (!earliestDate || yearAgo < earliestDate) {
                    earliestDate = yearAgo;
                }
                break;
                
            case 'images':
                filters.hasImages = true;
                break;
                
            case 'youtube':
                filters.hasYouTube = true;
                break;
                
            case 'long':
                filters.minLength = 500;
                break;

            case 'links':
                filters.hasLinks = true;
                break;
                
            case 'music':
                filters.hasMusic = true;
                break;
        }
    });
    
    // Set the earliest date if any date filters are active
    // Manual date range filters - check these FIRST before quick filters
    const dateFromValue = document.getElementById('date-from').value;
    const dateToValue = document.getElementById('date-to').value;

    if (dateFromValue) {
        // Create date at start of day
        const fromDate = new Date(dateFromValue + 'T00:00:00');
        filters.dateFrom = fromDate;
    } else if (earliestDate) {
        // Only use quick filter dates if no manual date is set
        filters.dateFrom = earliestDate;
    }

    if (dateToValue) {
        // Create date at end of day
        const toDate = new Date(dateToValue + 'T23:59:59');
        filters.dateTo = toDate;
    }
    
    performSearchWithFilters(query, filters);
}

function handleSecondaryFilter() {
    const dropdown = document.getElementById('secondary-filter-dropdown');
    const filterValue = dropdown.value;
    
    if (!filterValue) return;
    
    // Reset dropdown FIRST
    dropdown.value = '';
    
    if (filterValue.startsWith('most-')) {
        // SORT - engagement-based sorting (TOGGLE)
        
        // Check if this sort mode is already active - if so, turn it off
        if (currentSortMode === filterValue) {
            // Turn off engagement sorting - return to chronological
            currentSortMode = null;
            cancelEngagementFetch = true;
            
            // Re-sort to chronological order
            allNotes.sort((a, b) => b.created_at - a.created_at);
            
            // Re-apply any active filters (without engagement sort)
            if (activeQuickFilters.size > 0 || selectedTags.size > 0 || searchQuery) {
                applyAllFilters();
            } else {
                filteredNotes = allNotes.slice();
                resetPagination();
                renderNotes();
                document.getElementById('notes-title').textContent = 'All Notes';
                document.getElementById('notes-count').textContent = `${allNotes.length} notes`;
            }
            
            return; // Exit early
        }
        
        // Otherwise, activate this sort mode
        currentSortMode = filterValue;
        
        // Clear processed events at the START of a new sort operation
        processedEngagementEvents.clear();
        engagementCache.clear();
        
        // Show loading in title
        const title = document.getElementById('notes-title');
        title.textContent = '⏳ Fetching engagement stats...';

        // Fetch engagement stats for ALL notes (show toast for large sets)
const notesToFetch = filteredNotes.length;

if (notesToFetch > 5000) {
    showToast(`Fetching engagement for ${notesToFetch.toLocaleString()} notes - this will take a few minutes...`, 'success', 4000);
}

// Reset cancellation flag before starting
cancelEngagementFetch = false;

const visibleNoteIds = filteredNotes.slice(0, notesToFetch).map(note => note.id);

console.log(`Fetching engagement for ${visibleNoteIds.length} notes...`);
        
        // HELPER FUNCTION: Build filters object (will be called twice)
        const buildFiltersObject = () => {
            const filters = {};
            let earliestDate = null;
            
            // DEBUG: Log what we're building
            console.log('=== BUILDING FILTERS ===');
            console.log('activeQuickFilters:', Array.from(activeQuickFilters));
            console.log('Manual date from:', document.getElementById('date-from').value);
            console.log('Manual date to:', document.getElementById('date-to').value);
            console.log('selectedTags:', Array.from(selectedTags));
            console.log('currentTag:', currentTag);
            console.log('currentArchive:', currentArchive);
            console.log('filteredNotes.length before filters:', filteredNotes.length);
            
            // Build filters from activeQuickFilters
            activeQuickFilters.forEach(filterType => {
                const now = new Date();
                
                switch(filterType) {
                    case 'week':
                        const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        if (!earliestDate || weekAgo < earliestDate) earliestDate = weekAgo;
                        break;
                    case 'month':
                        const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        if (!earliestDate || monthAgo < earliestDate) earliestDate = monthAgo;
                        break;
                    case '6months':
                        const sixMonthsAgo = new Date(now.getTime() - 182 * 24 * 60 * 60 * 1000);
                        if (!earliestDate || sixMonthsAgo < earliestDate) earliestDate = sixMonthsAgo;
                        break;
                    case 'year':
                        const yearAgo = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
                        if (!earliestDate || yearAgo < earliestDate) earliestDate = yearAgo;
                        break;
                    case 'images':
                        filters.hasImages = true;
                        break;
                    case 'youtube':
                        filters.hasYouTube = true;
                        break;
                    case 'long':
                        filters.minLength = 500;
                        break;
                    case 'links':
                        filters.hasLinks = true;
                        break;
                    case 'music':
                        filters.hasMusic = true;
                        break;
                }
            });
            
            if (earliestDate) {
                filters.dateFrom = earliestDate;
            }
            
            // ALSO check manual date inputs
            const dateFromInput = document.getElementById('date-from').value;
            const dateToInput = document.getElementById('date-to').value;
            
            if (dateFromInput) {
                const manualDateFrom = new Date(dateFromInput);
                manualDateFrom.setHours(0, 0, 0, 0);
                
                // Use manual date if no quick filter, or if it's earlier
                if (!filters.dateFrom || manualDateFrom < filters.dateFrom) {
                    filters.dateFrom = manualDateFrom;
                }
            }
            
            if (dateToInput) {
                const manualDateTo = new Date(dateToInput);
                manualDateTo.setHours(23, 59, 59, 999);
                filters.dateTo = manualDateTo;
            }
            
            console.log('Built filters:', filters);
            console.log('=== END BUILDING FILTERS ===');
            
            return filters;
        };
        
        // Check if already cancelled before starting
        if (cancelEngagementFetch) {
            console.log('Engagement fetch cancelled before start');
            currentSortMode = null;
            title.textContent = 'All Notes';
            return;
        }
        
        fetchEngagementStats(visibleNoteIds).then(() => {
            // Check if cancelled while fetching
            if (cancelEngagementFetch) {
                console.log('Engagement fetch cancelled during processing');
                return;
            }
            
            // Wait for ALL relay connections to fully complete (10s max per relay)
            setTimeout(() => {
                // Check again before sorting
                if (cancelEngagementFetch) {
                    console.log('Engagement fetch cancelled before sorting');
                    return;
                }
                
                console.log('Sorting notes by engagement...');
                filteredNotes = sortNotesByEngagement(filteredNotes, currentSortMode);
                
                // Debug: Check top 10 notes
                console.log('Top 10 notes after sorting:');
                filteredNotes.slice(0, 10).forEach((note, i) => {
                    const stats = getEngagementStats(note.id);
                    console.log(`${i+1}. ${note.id.substring(0, 8)}: ${stats.zaps} zaps, ${stats.reactions} reactions, ${stats.reposts} reposts`);
                });
                
                console.log('filteredNotes.length after sort:', filteredNotes.length);
                
                resetPagination();
                
                // Get query and build filters
                const query = document.getElementById('search-input').value;
                console.log('=== FIRST RENDER (11 seconds) ===');
                const filters = buildFiltersObject();
                
                // Rebuild the title with all filters + sort mode
                performSearchWithFilters(query, filters);
                
                console.log('filteredNotes.length after FIRST performSearchWithFilters:', filteredNotes.length);
                
                // Wait for render to complete, THEN update engagement boxes
                setTimeout(() => {
                    if (cancelEngagementFetch) return;
                    
                    const currentlyRenderedIds = filteredNotes.slice(0, 100).map(note => note.id);
                    console.log(`Updating ${currentlyRenderedIds.length} engagement boxes...`);
                    
                    currentlyRenderedIds.forEach(noteId => {
                        const reactionsBox = document.querySelector(`[data-note-id="${noteId}"] .reactions-box`);
                        if (reactionsBox) {
                            const stats = getEngagementStats(noteId);
                            const total = stats.reactions + stats.zaps + stats.reposts + stats.quotes;
                            reactionsBox.textContent = `${total} engagement${total !== 1 ? 's' : ''}`;
                            reactionsBox.classList.remove('loading');
                        }
                    });
                    
                    // RE-SORT AND UPDATE after more data arrives (19 seconds total)
                    setTimeout(() => {
                        if (cancelEngagementFetch) return;
                        
                        console.log('Final update after all data arrived...');
                        
                        // RE-SORT with complete data
                        filteredNotes = sortNotesByEngagement(filteredNotes, currentSortMode);
                        
                        // Debug: Check if order changed
                        console.log('Top 10 after final sort:');
                        filteredNotes.slice(0, 10).forEach((note, i) => {
                            const stats = getEngagementStats(note.id);
                            console.log(`${i+1}. ${note.id.substring(0, 8)}: ${stats.zaps} zaps, ${stats.reactions} reactions, ${stats.reposts} reposts`);
                        });
                        
                        console.log('filteredNotes.length after final sort:', filteredNotes.length);
                        
                        // Re-render with correct sort order
                        resetPagination();
                        
                        // CRITICAL: Rebuild filters again for final render
                        console.log('=== FINAL RENDER (19 seconds) ===');
                        const finalFilters = buildFiltersObject();
                        performSearchWithFilters(query, finalFilters);
                        
                        console.log('filteredNotes.length after FINAL performSearchWithFilters:', filteredNotes.length);
                        
                        // Update boxes one more time after re-render
                        setTimeout(() => {
                            if (cancelEngagementFetch) return;
                            
                            const finalIds = filteredNotes.slice(0, 100).map(note => note.id);
                            finalIds.forEach(noteId => {
                                const reactionsBox = document.querySelector(`[data-note-id="${noteId}"] .reactions-box`);
                                if (reactionsBox) {
                                    const stats = getEngagementStats(noteId);
                                    const total = stats.reactions + stats.zaps + stats.reposts + stats.quotes;
                                    reactionsBox.textContent = `${total} engagement${total !== 1 ? 's' : ''}`;
                                    reactionsBox.classList.remove('loading');
                                }
                            });
                        }, 500);
                    }, 8000); // Wait another 8 seconds for late-arriving data
                }, 1000);
            }, 10000); // Wait 10 seconds for all relay data to arrive
        });
    } else {
        // FILTER - Toggle in activeQuickFilters
        const dateFilters = ['week', 'month', '6months', 'year'];
        
        // Check if this filter is already active
        if (activeQuickFilters.has(filterValue)) {
            // Remove the filter (toggle off)
            activeQuickFilters.delete(filterValue);
            
            // Update button visual state if it exists
            const btn = document.querySelector(`[data-filter="${filterValue}"]`);
            if (btn) btn.classList.remove('active');
        } else {
            // Add the filter (toggle on)
            if (dateFilters.includes(filterValue)) {
                // Clear other date filters first (mutually exclusive)
                dateFilters.forEach(df => {
                    if (df !== filterValue) {
                        activeQuickFilters.delete(df);
                        const btn = document.querySelector(`[data-filter="${df}"]`);
                        if (btn) btn.classList.remove('active');
                    }
                });
                
                // Clear manual date inputs
                document.getElementById('date-from').value = '';
                document.getElementById('date-to').value = '';
            }
            
            // Add the filter
            activeQuickFilters.add(filterValue);
            
            // Update button visual state if it exists
            const btn = document.querySelector(`[data-filter="${filterValue}"]`);
            if (btn) btn.classList.add('active');
        }
        
        // Apply all filters together
        applyAllFilters();
    }
}

function clearAllFilters() {
    // Cancel any ongoing engagement fetch
    cancelEngagementFetch = true;
    currentSortMode = null;
    
    // Clear quick filters
    activeQuickFilters.clear();
    document.querySelectorAll('.quick-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Clear date filters
    document.getElementById('date-from').value = '';
    document.getElementById('date-to').value = '';
    
    // Clear search
    document.getElementById('search-input').value = '';
    searchQuery = '';
    
    // Reset ALL state variables
    selectedTags.clear();
    currentTag = '';
    currentArchive = 'default';
    window.inAdvancedSearchMode = false;
    
    // Clear all UI states
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    document.querySelectorAll('.tag-filter').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.tag === '') {
            btn.classList.add('active');
        }
    });
    
    // Reset dropdown
    const dropdown = document.getElementById('secondary-filter-dropdown');
    if (dropdown) dropdown.value = '';
    
    // Re-sort notes to original chronological order
    allNotes.sort((a, b) => b.created_at - a.created_at);
    
    // CRITICAL: Force reset to exact original count
    filteredNotes = allNotes.slice();
    resetPagination();
    renderNotes();
    
    // Reset title and count to exact original values
    document.getElementById('notes-title').textContent = 'All Notes';
    document.getElementById('notes-count').textContent = `${allNotes.length} notes`;
}

// TEMPORARY: Add this function to debug the cache issue
async function forceResetUserCache() {
    if (!currentPubkey) {
        console.log('No user connected');
        return;
    }
    
    try {
        console.log(`Force resetting cache for user: ${currentPubkey.substring(0, 8)}...`);
        
        // Close database
        if (db && db.isOpen()) {
            await db.close();
        }
        
        // Delete the specific IndexedDB for this user
        const dbName = `nostr-notes-${currentPubkey}`;
        await new Promise((resolve) => {
            const deleteReq = indexedDB.deleteDatabase(dbName);
            deleteReq.onsuccess = () => {
                console.log(`Deleted IndexedDB: ${dbName}`);
                resolve();
            };
            deleteReq.onerror = () => {
                console.log(`Failed to delete IndexedDB: ${dbName}`);
                resolve();
            };
            deleteReq.onblocked = () => {
                console.log(`IndexedDB deletion blocked: ${dbName}`);
                setTimeout(resolve, 2000);
            };
        });
        
        // Clear localStorage entries for this user
        localStorage.removeItem(`nostr-archived-notes-${currentPubkey}`);
        localStorage.removeItem(`nostr-named-archives-${currentPubkey}`);
        localStorage.removeItem(`nostr-cached-notes-${currentPubkey}`);
        localStorage.removeItem(`nostr-cache-updated-at-${currentPubkey}`);
        localStorage.removeItem(`nostr-last-pubkey-${currentPubkey}`);
        
        // Reset database connection
        db = null;
        
        console.log('Cache reset complete - reconnect to fetch fresh data');
        showToast('User cache cleared - please reconnect', 'success');
        
        // Disconnect user to force fresh connection
        disconnect();
        
    } catch (error) {
        console.error('Error resetting cache:', error);
    }
}

async function performSearchWithFilters(query, filters) {
    const results = await performAdvancedSearch(query, filters);
    
    // Apply hashtag filtering AFTER the advanced search results
    let finalResults = results;
    
    // FIRST: Apply archive filter if we're in an archive
    if (currentArchive !== 'default' && currentTag.startsWith('__archive_')) {
        const archiveName = currentTag.replace('__archive_', '');
        if (namedArchives[archiveName]) {
            finalResults = finalResults.filter(note => namedArchives[archiveName].has(note.id));
        }
    }
    
    // SECOND: Apply hashtag/tag filtering if any tags are selected
    if (selectedTags.size > 0) {
        const tags = Array.from(selectedTags);
        finalResults = finalResults.filter(note =>
            tags.some(tag => noteMatchesTag(note, tag))
        );
    }
    
    // CRITICAL FIX: If we're in engagement sort mode, filter but preserve sort order
if (currentSortMode && currentSortMode.startsWith('most-')) {
    // We need to re-sort ALL the filtered results, not filter the old sorted list
    // Sort finalResults by the current engagement mode
    filteredNotes = sortNotesByEngagement(finalResults, currentSortMode);
    console.log('In engagement sort mode - sorted', finalResults.length, 'filtered notes');
} else {
    // Normal mode: replace filteredNotes with filtered results
    filteredNotes = finalResults;
}
    
    searchQuery = query;
    renderNotes();
    
    // Build comprehensive filter description
    const activeFilters = [];
    
    // Add quick filters
    if (activeQuickFilters.has('week')) activeFilters.push('This Week');
    if (activeQuickFilters.has('month')) activeFilters.push('This Month');
    if (activeQuickFilters.has('6months')) activeFilters.push('Last 6 Months');
    if (activeQuickFilters.has('year')) activeFilters.push('This Year');
    if (activeQuickFilters.has('images')) activeFilters.push('Has Images');
    if (activeQuickFilters.has('youtube')) activeFilters.push('Has Videos');
    if (activeQuickFilters.has('long')) activeFilters.push('Long Notes');
    if (activeQuickFilters.has('links')) activeFilters.push('Has Links');
    if (activeQuickFilters.has('music')) activeFilters.push('Has Music');
    
    // Add sorting mode if active
    if (currentSortMode === 'most-liked') activeFilters.push('Most Reactions');
    if (currentSortMode === 'most-zapped') activeFilters.push('Most Zapped');
    if (currentSortMode === 'most-reposted') activeFilters.push('Most Reposted');
    if (currentSortMode === 'most-quoted') activeFilters.push('Most Quoted');
    
    // Add selected hashtags from multi-selection
    selectedTags.forEach(tag => {
        if (tag === '__original') {
            activeFilters.push('Original Notes');
        } else if (tag === '__replies') {
            activeFilters.push('Replies');
        } else if (tag === '__reposts') {
            activeFilters.push('Reposts');
        } else if (tag === '__quotes') {
            activeFilters.push('Quotes');
        } else if (tag === '__archived') {
            activeFilters.push('Archived');
        } else if (tag.startsWith('#')) {
            activeFilters.push(tag);
        }
    });
    
    // Add search terms from text search
    if (query && query.trim()) {
        const searchTerms = query.trim().split(/\s+/);
        searchTerms.forEach(term => {
            if (term.startsWith('#')) {
                // Only add if it's not already in the list from selectedTags
                if (!activeFilters.includes(term)) {
                    activeFilters.push(term);
                }
            } else {
                activeFilters.push(`"${term}"`);
            }
        });
    }
    
    // Manual date filters (only show if no quick date filters)
    if (filters.dateFrom && !activeQuickFilters.has('week') && !activeQuickFilters.has('month') && !activeQuickFilters.has('6months') && !activeQuickFilters.has('year')) {
        activeFilters.push('Date Filtered');
    }
    
    // Update UI
    const title = document.getElementById('notes-title');
    const count = document.getElementById('notes-count');
    
    // Check if we're in an archive context
    if (currentArchive !== 'default' && currentTag.startsWith('__archive_')) {
        const archiveName = currentTag.replace('__archive_', '');
        
        if (activeFilters.length > 0) {
            title.textContent = `Archive: ${archiveName} (${activeFilters.join(' + ')})`;
        } else {
            title.textContent = `Archive: ${archiveName}`;
        }
    } else {
        // Not in an archive
        if (activeFilters.length > 0) {
            title.textContent = `Filtered Notes (${activeFilters.join(' + ')})`;
        } else {
            title.textContent = 'All Notes';
        }
    }
    
    count.textContent = `${filteredNotes.length} notes`;
    
    console.log('=== AFTER performSearchWithFilters ===');
    console.log('filteredNotes.length:', filteredNotes.length);
    console.log('Applied filters:', activeFilters.join(' + '));
    
    // Store that we're in advanced search mode
    window.inAdvancedSearchMode = true;
}

function debugRepostContent(noteId) {
    const note = allNotes.find(n => n.id.startsWith(noteId));
    if (!note) {
        console.log('Note not found');
        return;
    }
    
    console.log('=== REPOST DEBUG ===');
    console.log('isRepost:', note.isRepost);
    console.log('Original content:', note.content);
    console.log('After escapeHtml:', escapeHtml(note.content));
    console.log('After processImageLinks:', processImageLinks(escapeHtml(note.content)));
    console.log('After processYouTubeLinks:', processYouTubeLinks(processImageLinks(escapeHtml(note.content))));
    console.log('After processMusicLinks:', processMusicLinks(processYouTubeLinks(processImageLinks(escapeHtml(note.content)))));
    console.log('Final result:', makeLinksClickable(processMusicLinks(processYouTubeLinks(processImageLinks(escapeHtml(note.content))))));
}

window.debugRepostContent = debugRepostContent;

// Add this diagnostic function
async function diagnoseLoadingIssue() {
    console.log('=== LOADING DIAGNOSTICS ===');
    
    const results = {
        environment: {
            protocol: window.location.protocol,
            hostname: window.location.hostname,
            isHosted: window.location.protocol === 'https:' && window.location.hostname !== 'localhost'
        },
        relayTests: {},
        storage: {},
        currentState: {
            allNotesCount: allNotes.length,
            filteredNotesCount: filteredNotes.length,
            currentPubkey: currentPubkey ? currentPubkey.substring(0, 16) + '...' : 'none'
        }
    };
    
    // Test storage
    if ('storage' in navigator && 'estimate' in navigator.storage) {
        const estimate = await navigator.storage.estimate();
        results.storage = {
            used: `${((estimate.usage || 0) / 1024 / 1024).toFixed(1)}MB`,
            quota: `${((estimate.quota || 0) / 1024 / 1024).toFixed(1)}MB`,
            indexedDB: useIndexedDB ? 'enabled' : 'disabled'
        };
    }
    
    // Test first 3 relays quickly
    const testRelays = RELAYS.slice(0, 3);
    for (const relay of testRelays) {
        try {
            const startTime = Date.now();
            const ws = new WebSocket(relay);
            
            const testResult = await new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    ws.close();
                    resolve({ success: false, error: 'timeout' });
                }, 5000);
                
                ws.onopen = () => {
                    clearTimeout(timeout);
                    ws.close();
                    resolve({ success: true, duration: Date.now() - startTime });
                };
                
                ws.onerror = () => {
                    clearTimeout(timeout);
                    resolve({ success: false, error: 'connection failed' });
                };
            });
            
            results.relayTests[relay] = testResult;
        } catch (error) {
            results.relayTests[relay] = { success: false, error: error.message };
        }
    }
    
    console.log(JSON.stringify(results, null, 2));
    return results;
}

function copyNeventToClipboard(noteId) {
    const note = allNotes.find(n => n.id === noteId);
    if (!note) {
        showToast('Note not found', 'error');
        return;
    }
    
    const nevent = createNevent(note);
    
    navigator.clipboard.writeText(nevent).then(() => {
       showToast('Nevent copied!', 'success', 1500);
    }).catch(err => {
        console.error('Failed to copy:', err);
        showToast('Failed to copy link', 'error');
    });
}


// ==================== ENGAGEMENT STATS SYSTEM ====================

async function fetchEngagementStats(noteIds) {
    if (isFetchingEngagement || noteIds.length === 0) return;
    
    isFetchingEngagement = true;
    
    try {
        // Split into batches of 1000 with proper delays
        const batchSize = 1000;
        const batches = [];
        
        for (let i = 0; i < noteIds.length; i += batchSize) {
            batches.push(noteIds.slice(i, i + batchSize));
        }
        
        console.log(`Fetching engagement in ${batches.length} batches of up to ${batchSize} notes each`);
        
        // Process batches SEQUENTIALLY with longer delays
        for (let i = 0; i < batches.length; i++) {
            // CHECK FOR CANCELLATION AT START OF EACH BATCH
            if (cancelEngagementFetch) {
                console.log(`Engagement fetch cancelled at batch ${i + 1}/${batches.length}`);
                break;
            }
            
            const batch = batches[i];
            console.log(`Processing batch ${i + 1}/${batches.length} (${batch.length} notes)`);
            
            // USE MORE RELAYS - increased from 3 to 6 for better coverage
            const relaysToUse = RELAYS.slice(0, 6);
            
            const promises = relaysToUse.map(relay => 
                fetchEngagementFromRelay(relay, batch)
            );
            
            // Wait for this batch to complete before moving to next
            await Promise.all(promises);
            
            // CHECK FOR CANCELLATION AGAIN AFTER BATCH COMPLETES
            if (cancelEngagementFetch) {
                console.log(`Engagement fetch cancelled after batch ${i + 1}/${batches.length}`);
                break;
            }
            
            // Longer delay for 1000-note batches to let relays recover
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        console.log('All engagement batches fetched');
    } catch (error) {
        console.error('Error fetching engagement stats:', error);
    } finally {
        isFetchingEngagement = false;
        cancelEngagementFetch = false;
    }
}

function fetchEngagementFromRelay(relay, noteIds) {
    return new Promise((resolve) => {
        const ws = new WebSocket(relay);
        const timeout = setTimeout(() => {
            ws.close();
            resolve();
        }, 20000);

        ws.onopen = () => {
            ws.send(JSON.stringify([
                'REQ',
                'engagement-' + Date.now(),
                {
                    kinds: [7, 9735, 6, 1],
                    '#e': noteIds,
                    limit: 5000
                }
            ]));
        };

        ws.onmessage = (event) => {
            const [type, , eventData] = JSON.parse(event.data);
            if (type === 'EVENT') {
                processEngagementEvent(eventData);
            } else if (type === 'EOSE') {
                clearTimeout(timeout);
                ws.close();
                resolve();
            }
        };

        ws.onerror = () => {
            clearTimeout(timeout);
            resolve();
        };
    });
}

function processEngagementEvent(event) {
    if (!event || !event.tags) return;
    
    // DEDUPLICATION: Skip if we've already processed this event
    if (processedEngagementEvents.has(event.id)) {
        return;
    }
    processedEngagementEvents.add(event.id);
    
    const eTags = event.tags.filter(tag => tag[0] === 'e');
    if (eTags.length === 0) return;
    
    // Find which note this engagement is FOR
    let targetNoteId;
    
    if (event.kind === 9735 || event.kind === 6 || event.kind === 7) {
        // For reactions/zaps/reposts, ALWAYS use the LAST e-tag
        // This is the most direct target (the note being reacted to)
        // The "reply" and "root" markers are for threading context only
        targetNoteId = eTags[eTags.length - 1][1];
    } else if (event.kind === 1) {
        const qTags = event.tags.filter(tag => tag[0] === 'q');
        
        if (qTags.length > 0) {
            const quoteTarget = eTags.find(tag => tag[3] === 'reply') || eTags[eTags.length - 1];
            if (quoteTarget) targetNoteId = quoteTarget[1];
        } else {
            return;
        }
    }
    
    if (!targetNoteId) return;
    
    // Initialize cache entry if needed
    if (!engagementCache.has(targetNoteId)) {
        engagementCache.set(targetNoteId, {
            reactions: 0,
            zaps: 0,
            zapAmount: 0,
            reposts: 0,
            quotes: 0
        });
    }
    
    const stats = engagementCache.get(targetNoteId);
    
    // Increment the appropriate counter
    if (event.kind === 7) {
        stats.reactions++;
    } else if (event.kind === 9735) {
        stats.zaps++;
        
        const bolt11Tag = event.tags.find(tag => tag[0] === 'bolt11');
        if (bolt11Tag && bolt11Tag[1]) {
            const invoice = bolt11Tag[1];
            const amountMatch = invoice.match(/lnbc(\d+)([munp]?)/i);
            if (amountMatch) {
                let amount = parseInt(amountMatch[1]);
                const unit = amountMatch[2];
                
                if (unit === 'm') amount = amount * 100000;
                else if (unit === 'u') amount = amount * 100;
                else if (unit === 'n') amount = amount / 10;
                else if (unit === 'p') amount = amount / 10000;
                else amount = amount * 100000000;
                
                stats.zapAmount += Math.floor(amount);
            }
        }
    } else if (event.kind === 6) {
        stats.reposts++;
    } else if (event.kind === 1) {
        stats.quotes++;
    }
}

function getEngagementStats(noteId) {
    if (engagementCache.has(noteId)) {
        return engagementCache.get(noteId);
    }
    
    engagementFetchQueue.add(noteId);
    return { reactions: 0, zaps: 0, zapAmount: 0, reposts: 0, quotes: 0 };
}

function createReactionsBoxHTML(noteId) {
    const stats = getEngagementStats(noteId);
    const total = stats.reactions + stats.zaps + stats.reposts + stats.quotes;
    const formattedSats = (stats.zapAmount || 0).toLocaleString();
    
    return `
        <div class="reactions-container">
            <div class="reactions-box" onclick="toggleReactionsPopup(event, '${noteId}')" title="Click to see engagement">
                ${total} engagement${total !== 1 ? 's' : ''}
            </div>
            <div class="reactions-popup" id="popup-${noteId}">
                <div class="reactions-popup-header">Engagement (${total})</div>
                <div class="reaction-item">
                    <span>Reactions</span>
                    <span class="reaction-count">${stats.reactions}</span>
                </div>
                <div class="reaction-item">
                    <span>Zaps (${formattedSats} sats)</span>
                    <span class="reaction-count">${stats.zaps}</span>
                </div>
                <div class="reaction-item">
                    <span>Reposts</span>
                    <span class="reaction-count">${stats.reposts}</span>
                </div>
                <div class="reaction-item">
                    <span>Quotes</span>
                    <span class="reaction-count">${stats.quotes}</span>
                </div>
            </div>
        </div>
    `;
}

function toggleReactionsPopup(event, noteId) {
    event.stopPropagation();
    
    const popup = document.getElementById('popup-' + noteId);
    if (!popup) return;
    
    // UPDATE popup content with current stats before showing
    const stats = getEngagementStats(noteId);
    const total = stats.reactions + stats.zaps + stats.reposts + stats.quotes;
    
    // Format sats with commas
    const formattedSats = (stats.zapAmount || 0).toLocaleString();
    
    popup.innerHTML = `
        <div class="reactions-popup-header">Engagement (${total})</div>
        <div class="reaction-item">
            <span>Reactions</span>
            <span class="reaction-count">${stats.reactions}</span>
        </div>
        <div class="reaction-item">
            <span>Zaps (${formattedSats} sats)</span>
            <span class="reaction-count">${stats.zaps}</span>
        </div>
        <div class="reaction-item">
            <span>Reposts</span>
            <span class="reaction-count">${stats.reposts}</span>
        </div>
        <div class="reaction-item">
            <span>Quotes</span>
            <span class="reaction-count">${stats.quotes}</span>
        </div>
    `;
    
    document.querySelectorAll('.reactions-popup.show').forEach(p => {
        if (p.id !== 'popup-' + noteId) {
            p.classList.remove('show');
        }
    });
    
    popup.classList.toggle('show');
}

document.addEventListener('click', function(event) {
    if (!event.target.closest('.reactions-box') && !event.target.closest('.reactions-popup')) {
        document.querySelectorAll('.reactions-popup.show').forEach(popup => {
            popup.classList.remove('show');
        });
    }
});

// ==================== SORTING SYSTEM ====================

function sortNotesByEngagement(notes, sortMode) {
    const sortedNotes = [...notes];
    
    console.log(`Sorting by: ${sortMode}`);
    
    switch (sortMode) {
        case 'most-liked':
            const likedSorted = sortedNotes.sort((a, b) => {
                const aStats = getEngagementStats(a.id);
                const bStats = getEngagementStats(b.id);
                return (bStats.reactions || 0) - (aStats.reactions || 0);
            });
            
            console.log('Top 10 most liked notes:');
            likedSorted.slice(0, 10).forEach((note, i) => {
                const stats = getEngagementStats(note.id);
                console.log(`${i+1}. ${note.id.substring(0, 8)}: ${stats.reactions} reactions, ${stats.zaps} zaps, ${stats.reposts} reposts`);
            });
            
            return likedSorted;
            
        case 'most-zapped':
            const zappedSorted = sortedNotes.sort((a, b) => {
                const aStats = getEngagementStats(a.id);
                const bStats = getEngagementStats(b.id);
                return (bStats.zaps || 0) - (aStats.zaps || 0);
            });
            
            console.log('Top 10 most zapped notes:');
            zappedSorted.slice(0, 10).forEach((note, i) => {
                const stats = getEngagementStats(note.id);
                console.log(`${i+1}. ${note.id.substring(0, 8)}: ${stats.zaps} zaps, ${stats.reactions} reactions, ${stats.reposts} reposts`);
            });
            
            return zappedSorted;
            
        case 'most-reposted':
            const repostedSorted = sortedNotes.sort((a, b) => {
                const aStats = getEngagementStats(a.id);
                const bStats = getEngagementStats(b.id);
                return (bStats.reposts || 0) - (aStats.reposts || 0);
            });
            
            console.log('Top 10 most reposted notes:');
            repostedSorted.slice(0, 10).forEach((note, i) => {
                const stats = getEngagementStats(note.id);
                console.log(`${i+1}. ${note.id.substring(0, 8)}: ${stats.reposts} reposts, ${stats.reactions} reactions, ${stats.zaps} zaps`);
            });
            
            return repostedSorted;
            
        case 'most-quoted':
            const quotedSorted = sortedNotes.sort((a, b) => {
                const aStats = getEngagementStats(a.id);
                const bStats = getEngagementStats(b.id);
                return (bStats.quotes || 0) - (aStats.quotes || 0);
            });
            
            console.log('Top 10 most quoted notes:');
            quotedSorted.slice(0, 10).forEach((note, i) => {
                const stats = getEngagementStats(note.id);
                console.log(`${i+1}. ${note.id.substring(0, 8)}: ${stats.quotes} quotes, ${stats.reactions} reactions, ${stats.zaps} zaps`);
            });
            
            return quotedSorted;
            
        default:
            return sortedNotes;
    }
}

function fetchEngagementForVisibleNotes() {
    if (engagementFetchQueue.size === 0) return;
    
    const noteIds = Array.from(engagementFetchQueue);
    engagementFetchQueue.clear();
    
    fetchEngagementStats(noteIds);
}


// Make it globally available
window.copyNeventToClipboard = copyNeventToClipboard;

// Make it globally available
window.diagnoseLoadingIssue = diagnoseLoadingIssue;

window.showThreadView = showThreadView;
window.closeThreadView = closeThreadView;

// Make functions globally available
window.toggleQuickFilter = toggleQuickFilter;
window.applyDateFilters = applyDateFilters;
window.clearAllFilters = clearAllFilters;
window.handleSecondaryFilter = handleSecondaryFilter;
window.toggleReactionsPopup = toggleReactionsPopup;
window.getEngagementStats = getEngagementStats;
window.fetchEngagementStats = fetchEngagementStats;

// Add global event listeners for hashtag selection
document.addEventListener('mouseup', endHashtagSelection);
document.addEventListener('mouseleave', endHashtagSelection);

// Make functions globally available for onclick handlers
// Core functionality
window.filterByTag = filterByTag;
window.toggleArchiveNote = toggleArchiveNote;
window.viewArchive = viewArchive;
window.deleteArchive = deleteArchive;
window.toggleNoteSelection = toggleNoteSelection;
window.showStorageInfo = showStorageInfo;
window.closeStorageInfo = closeStorageInfo;
window.optimizeStorage = optimizeStorage;
window.exportStorageReport = exportStorageReport;

// UI and modals
window.showNoteInfo = showNoteInfo;
window.selectArchiveOption = selectArchiveOption;
window.closeArchiveModal = closeArchiveModal;
window.showAppInfo = showAppInfo;
window.closeAppInfo = closeAppInfo;

// Archive management
window.removeFromSpecificArchive = removeFromSpecificArchive;

// Media loading
window.loadYouTubeThumbnail = loadYouTubeThumbnail;
window.loadImage = loadImage;
window.closeImage = closeImage;
window.closeYouTube = closeYouTube;
window.loadMusicEmbed = loadMusicEmbed;
window.closeMusicEmbed = closeMusicEmbed;

// Utilities
window.copyToClipboard = copyToClipboard;
window.clearAllCache = clearAllCache;
window.showToast = showToast;

// Make hashtag selection functions globally available
window.startHashtagSelection = startHashtagSelection;
window.continueHashtagSelection = continueHashtagSelection;
window.endHashtagSelection = endHashtagSelection;

// Theme functionality - immediate execution when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    const themeSelector = document.getElementById('theme-selector');
    if (!themeSelector) return; // Exit if element doesn't exist yet
    
    // Load saved theme on startup
    const savedTheme = localStorage.getItem('nostr-theme') || 'default';
    
    // IMPORTANT: Always set the data-theme attribute, even for default
    document.body.setAttribute('data-theme', savedTheme);
    themeSelector.value = savedTheme;
    
    themeSelector.addEventListener('change', function(e) {
        document.body.setAttribute('data-theme', e.target.value);
        localStorage.setItem('nostr-theme', e.target.value);
    });
});

// One-time cleanup of old global archives - remove after running once
if (!localStorage.getItem('archives-cleanup-done')) {
    localStorage.removeItem('nostr-archived-notes');
    localStorage.removeItem('nostr-named-archives');
    localStorage.setItem('archives-cleanup-done', 'true');
}
    </script>
</body>
</html>