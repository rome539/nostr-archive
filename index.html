<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dexie/3.2.4/dexie.min.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr Notes Archive</title>
   <script type="module">
  import * as NostrTools from 'https://cdn.jsdelivr.net/npm/nostr-tools@2.7.1/+esm';
  window.NostrTools = NostrTools;
</script>
    <style>
        /* CSS Variables for Theme Colors */
:root {
    /* Default Theme */
    --primary-color: #3498db;
    --primary-hover: #2980b9;
    --success-color: #27ae60;
    --danger-color: #e74c3c;
    --purple-color: #9b59b6;
    --background-color: #f5f5f5;
    --card-background: white;
    --text-color: #333;
    --text-muted: #666;
    --border-color: #ddd;
}

/* Nostr Purple – stronger + primary=purple */
[data-theme="nostr-purple"] {
  --primary-color: #7c3aed;      /* purple used by non-reply cards */
  --primary-hover: #6d28d9;
  --secondary-color: #f59e0b;
  --secondary-hover: #d97706;
  --success-color: #059669;
  --danger-color: #dc2626;
  --purple-color: #7c3aed;       /* replies & accents */
  --background-color: #f3e8ff;
  --card-background: #f3e8ff;
  --text-color: #3b0764;
  --text-muted: #6d28d9;
  --border-color: #c084fc;
}


/* INTENSE Dark Nostr */
[data-theme="dark-nostr"] {
  --primary-color: #8b5cf6;      /* vivid purple */
  --primary-hover: #7c3aed;      /* deeper hover */
  --secondary-color: #f59e0b;    /* warm gold */
  --secondary-hover: #d97706;
  --success-color: #22c55e;
  --danger-color:  #ef4444;
  --purple-color:  #a78bfa;      /* soft lavender for replies */
  --background-color: #070712;   /* near-black */
  --card-background: #0f1020;    /* darker cards */
  --text-color: #e6edf7;         /* bright but not pure white */
  --text-muted: #8b82aa; 
  --border-color: #232742;       /* strong edge */
}

/* Dark theme input fixes - higher specificity */
[data-theme="dark-nostr"] #search-input::placeholder,
[data-theme="dark-nostr"] #keyword-input::placeholder,
[data-theme="dark-nostr"] #new-archive-name::placeholder {
    color: #cbd5e1 !important;
}

[data-theme="dark-nostr"] #search-input,
[data-theme="dark-nostr"] #keyword-input,
[data-theme="dark-nostr"] #new-archive-name {
    border-color: #64748b;
    color: #e2e8f0;
}

/* INTENSE Bitcoin Gold */
[data-theme="bitcoin-gold"] {
  --primary-color: #f7931a;      /* official Bitcoin orange */
  --primary-hover: #c76a00;      /* deeper hover shade */
  --secondary-color: #6b4e16;    /* coin bronze */
  --secondary-hover: #4a3410;
  --success-color: #2e8b57;      /* strong green */
  --danger-color: #b22222;       /* vivid red */
  --purple-color: #9b59b6;       /* royal purple accent */
  --background-color: #1a1208;   /* dark brown/black backdrop */
  --card-background: #2b1b0b;    /* warm dark card tone */
  --text-color: #fef3c7;         /* pale gold text */
  --text-muted: #d97706;         /* amber-muted for secondary text */
  --border-color: rgba(247, 147, 26, 0.5); /* semi-transparent Bitcoin orange */
}

/* neon-green Neon Green Theme */
[data-theme="neon-green"] {
  --primary-color: #00ff00;
  --primary-hover: #33ff33;
  --secondary-color: #00ff00;
  --secondary-hover: #33ff33;
  --success-color: #00ff00;
  --danger-color: #ff3333;
  --purple-color: #00ff00;
  --background-color: #000000;
  --card-background: #0a0a0a;
  --text-color: #00ff00;
  --text-muted: #00ff00;
  --border-color: #00aa00;

  /* NEW soft tokens for toned surfaces */
  --accent: #00ff00;
  --accent-border: #00aa00;
  --accent-weak: color-mix(in srgb, var(--accent) 18%, #000);
  --accent-weak-2: color-mix(in srgb, var(--accent) 10%, #000);
}

/* Hide emojis for neon-green theme only - MORE SPECIFIC */
[data-theme="neon-green"] .emoji,
[data-theme="neon-green"] button .emoji,
[data-theme="neon-green"] .tag-filter .emoji {
    display: none !important;
}

/* But keep them visible in other themes */
.emoji {
    display: inline !important;
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

     body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--background-color);
    color: var(--text-color);
    line-height: 1.6;
    font-size: 15px; /* Slightly larger base font */
}

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

     .header h1 {
    font-size: 2.8em;
    margin-bottom: 15px;
    color: var(--primary-color);
    font-weight: 600;
    letter-spacing: -0.02em;
}

        .connection-box {
    background: var(--card-background);
    padding: 40px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    max-width: 500px;
    margin: 0 auto;
}

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }

      .form-group input {
    width: 100%;
    padding: 12px;
    border: 2px solid var(--border-color);
    border-radius: 5px;
    font-size: 14px;
    font-family: monospace;
    background: var(--card-background);
    color: var(--text-color);
}

.form-group input:focus {
    border-color: var(--primary-color);
    outline: none;
}

   /* Loading and transition improvements */
.btn {
    background: var(--primary-color);
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 15px;
    font-weight: 500;
    width: 100%;
    margin-bottom: 12px;
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
}

.btn.loading::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
    0% { left: -100%; }
    100% { left: 100%; }
}

.fade-in {
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.slide-up {
    animation: slideUp 0.2s ease-out;
}

/* Toast notifications */
.toast {
    position: fixed;
    top: 20px;
    right: 20px;
    background: var(--card-background);
    color: var(--text-color);
    padding: 16px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    border-left: 4px solid var(--success-color);
    z-index: 1001;
    transform: translateX(400px);
    transition: transform 0.3s ease;
}

.toast.show {
    transform: translateX(0);
}

.toast.error {
    border-left-color: var(--danger-color);
}

.toast.warning {
    border-left-color: #f39c12;
}

@keyframes slideUp {
    from { transform: translateY(5px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}


.btn:hover {
    background: var(--primary-hover);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

        .btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }

        .btn-small {
    padding: 8px 14px;
    font-size: 13px;
    width: auto;
    margin: 0 4px;
    font-weight: 500;
}

.btn-secondary {
    background: var(--text-muted);
    color: white;
}

.btn-secondary:hover {
    background: var(--text-color);
}



        .btn-tiny {
            padding: 2px 6px;
            font-size: 11px;
            min-width: auto;
            width: auto;
            margin: 0;
        }

 /* Better delete button styling for all themes */
.btn-delete {
    background: var(--danger-color) !important;
    color: white !important;
    border: none !important;
    width: 24px !important;
    height: 24px !important;
    border-radius: 50% !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    font-size: 14px !important;
    font-weight: bold !important;
    line-height: 1 !important;
}

/* Neon-green delete button */
[data-theme="neon-green"] .btn-delete {
    background: var(--accent) !important;
    color: #000 !important;
    box-shadow: 0 0 6px rgba(0, 255, 0, 0.4) !important;
}

        .btn-delete:hover {
            background: #c0392b;
        }

        .error {
            background: #e74c3c;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            display: none;
        }

        .success {
            background: #27ae60;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }

        .btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.btn:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
}

.btn-small:hover {
    transform: translateY(-1px);
}

.btn-small:active {
    transform: translateY(0);
}

.quick-filter-btn.active {
    background: var(--primary-color) !important;
    color: white !important;
    transform: translateY(-1px);
    box-shadow: 0 3px 8px rgba(52, 152, 219, 0.3);
}

/* Theme-specific active states */
[data-theme="dark-nostr"] .quick-filter-btn.active {
    background: var(--primary-color) !important;
    box-shadow: 0 3px 8px rgba(139, 92, 246, 0.4);
}

[data-theme="bitcoin-gold"] .quick-filter-btn.active {
    background: var(--primary-color) !important;
    box-shadow: 0 3px 8px rgba(247, 147, 26, 0.4);
}

[data-theme="nostr-purple"] .quick-filter-btn.active {
    background: var(--primary-color) !important;
    box-shadow: 0 3px 8px rgba(124, 58, 237, 0.4);
}

[data-theme="neon-green"] .quick-filter-btn.active {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.6) !important;
}
        
        /* Fix layout so tabs (Original Notes / Replies) don’t overflow */
.app-layout {
  display: grid;
  grid-template-columns: 300px 1fr;
  gap: 20px;
  margin-top: 20px;
}


      .sidebar h4 {
    font-size: 14px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
    margin: 25px 0 12px 0;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}

.sidebar h4:first-of-type {
    margin-top: 0;
}

.sidebar {
    background: var(--card-background);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    height: fit-content;
}

.sidebar-section {
    margin-bottom: 32px;
    padding-bottom: 24px;
    border-bottom: 1px solid rgba(0,0,0,0.08);
}

.sidebar-section:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

.main-content {
    background: var(--card-background);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.note-card {
    background: var(--card-background);
    padding: 24px;
    margin-bottom: 18px;
    border-radius: 12px;
    position: relative;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    transition: all 0.2s ease;
    border: 1px solid rgba(0,0,0,0.06);
    /* Default: Blue border for original notes */
    border-left: 4px solid var(--primary-color);
}

.note-card:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 16px rgba(0,0,0,0.12);
}

/* High specificity rules to override everything */
.note-card.reply-card:not(.archived) {
    border-left: 4px solid var(--purple-color) !important;
}

.note-card:not(.reply-card):not(.archived) {
    border-left: 4px solid var(--primary-color) !important;
}

.note-card.archived {
    border-left: 4px solid var(--success-color) !important;
}

     .note-header {
    font-size: 12px;
    color: var(--text-muted);
    margin-bottom: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

        .note-actions {
            display: flex;
            gap: 5px;
        }

     .note-content {
    white-space: pre-wrap;
    line-height: 1.6;
    margin-bottom: 16px;
    font-size: 14px;
    color: var(--text-color);
}

        .hashtags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

/* Hashtag pills — follow current theme */
/* Unified hashtag styling - follows primary theme color */
.hashtag {
  background: color-mix(in srgb, var(--primary-color) 18%, var(--card-background)) !important;
  border: 1px solid color-mix(in srgb, var(--primary-color) 40%, var(--card-background)) !important;
  color: var(--primary-color) !important;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.15s ease;
  user-select: none;
}

.hashtag:hover {
  background: color-mix(in srgb, var(--primary-color) 32%, var(--card-background)) !important;
  border-color: var(--primary-hover) !important;
  color: #fff !important;
  transform: translateY(-1px);
}

/* Active hashtag styling */
.hashtag[data-selected="true"] {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Override for neon-green theme */
[data-theme="neon-green"] .hashtag[data-selected="true"] {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 6px rgba(0, 255, 0, 0.3) !important;
    text-shadow: 0 0 3px var(--accent) !important;
}

/* Remove ALL the old reply/archived specific rules */
.note-card.reply-card .hashtag,
.note-card.archived .hashtag {
  background: color-mix(in srgb, var(--primary-color) 18%, var(--card-background)) !important;
  border-color: color-mix(in srgb, var(--primary-color) 40%, var(--card-background)) !important;
  color: var(--primary-color) !important;
}

.note-card.reply-card .hashtag:hover,
.note-card.archived .hashtag:hover {
  background: color-mix(in srgb, var(--primary-color) 32%, var(--card-background)) !important;
  border-color: var(--primary-hover) !important;
  color: #fff !important;
}

/* Hashtags in archived cards = success theme */
.note-card.archived .hashtag {
  background: color-mix(in srgb, var(--success-color) 18%, var(--card-background));
  border-color: color-mix(in srgb, var(--success-color) 40%, var(--card-background));
  color: var(--success-color);
}
.note-card.archived .hashtag:hover {
  background: color-mix(in srgb, var(--success-color) 32%, var(--card-background));
  border-color: var(--success-color);
  color: #fff;
}

       .tag-filter {
    display: block;
    width: 100%;
    padding: 8px;
    margin-bottom: 5px;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    text-align: left;
    color: var(--text-color);
}


.tag-filter.active {
    background: var(--primary-color);
    color: white;
}

.tag-filter:hover {
  background: color-mix(in srgb, var(--primary-color) 24%, #fff);
  border-color: var(--primary-color);
}

/* Active state */
.tag-filter.active {
  background: var(--primary-color);
  border-color: var(--primary-color);
  color: #fff;
}

/* Special pills that match your theme variables */
.tag-filter[data-tag="__original"] {
  background: var(--primary-color);
  border-color: var(--primary-color);
  color: #fff;
}
.tag-filter[data-tag="__replies"] {
  background: var(--purple-color);
  border-color: var(--purple-color);
  color: #fff;
}
.tag-filter[data-tag="__replies"].active {
  background: var(--purple-color);
}
.tag-filter[data-tag="__archived"],
.tag-filter[data-tag^="__archive_"] {
  background: var(--success-color);
  border-color: var(--success-color);
  color: #fff;
}


 .archive-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    margin-bottom: 8px;
    background: var(--background-color);
    border-radius: 8px;
    border: 1px solid var(--border-color);
    transition: all 0.2s ease;
}

.archive-item:hover:not(.active) {
    background: var(--card-background);
    border-color: var(--primary-color);
}

.archive-item.active {
    background: var(--success-color);
    border-color: var(--success-color);
    color: white;
}

.archive-name {
    cursor: pointer;
    flex: 1;
    font-size: 14px;
}

.archive-count {
    font-size: 12px;
    color: var(--text-muted);
    margin-right: 8px;
}

        .archive-actions {
            display: flex;
            gap: 5px;
        }

      .loading {
    text-align: center;
    padding: 50px;
    color: var(--text-muted);
}

        .hidden { display: none;
        }

    .search-box {
    width: 100%;
    padding: 12px 16px;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    margin-bottom: 18px;
    background: var(--card-background);
    color: var(--text-color);
    font-size: 14px;
    transition: border-color 0.2s ease;
}

.search-box:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

       .keyword-input {
    width: 100%;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    margin-bottom: 10px;
    font-size: 14px;
    background: var(--card-background);
    color: var(--text-color);
}

        .info-box {
    background: var(--background-color);
    padding: 15px;
    border-radius: 5px;
    margin: 15px 0;
    font-size: 13px;
    border-left: 3px solid var(--primary-color);
}

       .progress-bar {
  width: 100%;
  height: 20px;
  background: color-mix(in srgb, var(--primary-color) 12%, #ecf0f1);
  border: 1px solid color-mix(in srgb, var(--primary-color) 35%, #ecf0f1);
  border-radius: 10px;
  overflow: hidden;
  margin: 10px 0;
}

.progress-fill {
  height: 100%;
  background: var(--primary-color);             /* follows theme */
  transition: width 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-size: 12px;
}

.archive-options {
    margin: 20px 0;
}

.archive-option {
    padding: 12px 16px;
    margin: 8px 0;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.archive-option:hover {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

/* neon-green archive options */
[data-theme="neon-green"] .archive-option {
    background: var(--accent-weak-2) !important;
    border-color: var(--accent-border) !important;
    color: var(--accent) !important;
}

[data-theme="neon-green"] .archive-option:hover {
    background: var(--accent-weak) !important;
    border-color: var(--accent) !important;
}

        .note-checkbox {
            margin-right: 10px;
            transform: scale(1.2);
        }

       .bulk-controls {
    background: var(--background-color);
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    border: 1px solid var(--border-color);
}

        .bulk-controls.hidden {
            display: none;
        }

    .status-info {
    font-size: 12px;
    color: var(--text-muted);
    margin: 5px 0;
}

/* Prevent sideways scroll caused by long strings */
#pubkey-display,
.note-content,
.note-header,
.archive-name {
  overflow-wrap: anywhere;   /* allow breaks anywhere */
  word-break: break-word;    /* fallback */
  max-width: 100%;
}

/* Keep panels from exceeding container width */
.sidebar,
.main-content {
  max-width: 100%;
}

.archive-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    margin-bottom: 8px;
    background: var(--background-color);
    border-radius: 8px;
    border: 1px solid var(--border-color);
    transition: all 0.2s ease;
    cursor: pointer;
    position: relative;
}

.archive-name {
    flex: 1;
    font-size: 14px;
    pointer-events: none;
}

.archive-count {
    font-size: 12px;
    color: var(--text-muted);
    margin-right: 8px;
    pointer-events: none;
}

.archive-actions {
    display: flex;
    gap: 5px;
    z-index: 10;
}

.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(4px);
    animation: fadeIn 0.2s ease;
}

.modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    padding: 32px;
    border-radius: 12px;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    border: 1px solid var(--border-color);
    transform: scale(0.9);
    animation: modalSlideIn 0.2s ease forwards;
}

@keyframes modalSlideIn {
    to {
        transform: scale(1);
    }
}

.modal-close {
    float: right;
    background: var(--primary-color) !important;
    color: white !important;
    border: none !important;
    padding: 10px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s ease;
}

.modal-close:hover {
    background: var(--primary-hover) !important;
    transform: translateY(-1px);
}

/* Stack on small screens */
@media (max-width: 768px) {
  .app-layout {
    grid-template-columns: 1fr;
  }
}
/* Consistent spacing system */
.mb-1 { margin-bottom: 8px; }
.mb-2 { margin-bottom: 16px; }
.mb-3 { margin-bottom: 24px; }
.mb-4 { margin-bottom: 32px; }

.mt-1 { margin-top: 8px; }
.mt-2 { margin-top: 16px; }
.mt-3 { margin-top: 24px; }
.mt-4 { margin-top: 32px; }

kbd {
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 3px;
    padding: 1px 4px;
    font-size: 11px;
    font-family: monospace;
    color: var(--text-color);
}

.copy-btn {
  border: none;
  padding: 4px 8px;
  border-radius: 3px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.2s ease;
}

/* Default theme */
.copy-btn {
  background: var(--primary-color);
  color: white;
  border: 1px solid var(--primary-color);
}

.copy-btn:hover {
  background: var(--primary-hover);
  transform: translateY(-1px);
}

/* Dark themes */
[data-theme="dark-nostr"] .copy-btn,
[data-theme="bitcoin-gold"] .copy-btn {
  background: var(--primary-color);
  color: white;
  border: 1px solid var(--primary-color);
}

[data-theme="dark-nostr"] .copy-btn:hover,
[data-theme="bitcoin-gold"] .copy-btn:hover {
  background: var(--primary-hover);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

/* Nostr Purple theme */
[data-theme="nostr-purple"] .copy-btn {
  background: var(--primary-color);
  color: white;
  border: 1px solid var(--primary-color);
}

[data-theme="nostr-purple"] .copy-btn:hover {
  background: var(--primary-hover);
}

/* Neon Green theme */
[data-theme="neon-green"] .copy-btn {
  background: var(--accent-weak-2) !important;
  border: 1px solid var(--accent-border) !important;
  color: var(--accent) !important;
  text-shadow: 0 0 3px var(--accent);
}

[data-theme="neon-green"] .copy-btn:hover {
  background: var(--accent-weak) !important;
  box-shadow: 0 0 6px rgba(0,255,0,0.4) !important;
}

/* Stack Import button + hint with tight spacing */
.import-archive-block {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0 !important;                 /* kill any flex gap */
  margin-bottom: 14px;
}

/* ensure the button above doesn't add extra space */
.import-archive-block > .btn {
  margin: 0 !important;              /* some .btn styles add margin-bottom */
}

/* pull the hint closer to the button */
.import-hint {
  color: var(--text-muted);
  font-size: 11px;
  text-align: center;
  margin-top: 4px !important;        /* force a small, tight gap */
  line-height: 1.15;                 /* compact line height */
}

/* if any generic rule targets .sidebar-section .btn + small, override it */
.sidebar-section .btn + .import-hint {
  margin-top: 4px !important;
}

/* Lazy loading styles */
.note-image {
    max-width: 100%;
    height: auto;
    margin: 10px 0;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    cursor: pointer;
    transition: transform 0.2s ease;
}

.note-image:hover {
    transform: scale(1.02);
}

/* Load More button theming */
#load-more-btn {
    background: var(--primary-color) !important;
    color: white !important;
    border: 1px solid var(--primary-color) !important;
}

#load-more-btn:hover {
    background: var(--primary-hover) !important;
    transform: translateY(-1px);
}

/* Neon Green Load More button */
[data-theme="neon-green"] #load-more-btn {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    text-shadow: 0 0 4px var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #load-more-btn:hover {
    background: color-mix(in srgb, var(--accent) 28%, #000) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

.youtube-thumbnail {
    position: relative;
    display: inline-block;
    margin: 10px 0;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    cursor: pointer;
    transition: transform 0.2s ease;
}

.youtube-thumbnail:hover {
    transform: scale(1.02);
}

.youtube-thumbnail img {
    width: 320px;
    height: 180px;
    object-fit: cover;
    display: block;
}

.youtube-thumbnail .play-button {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.8);
    color: white;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
}

.youtube-thumbnail .play-button::before {
    content: "▶";
    margin-left: 3px;
}

[data-theme="dark-nostr"] .modal {
    background: rgba(0, 0, 0, 0.8) !important;
}

[data-theme="dark-nostr"] .modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="dark-nostr"] .modal-close {
    background: var(--primary-color) !important;
    color: white !important;
}

[data-theme="dark-nostr"] .modal-close:hover {
    background: var(--primary-hover) !important;
}

[data-theme="bitcoin-gold"] .modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="bitcoin-gold"] .modal-close {
    background: var(--primary-color) !important;
    color: white !important;
}

[data-theme="bitcoin-gold"] .modal-close:hover {
    background: var(--primary-hover) !important;
}

[data-theme="nostr-purple"] .modal-content {
    background: var(--card-background) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="nostr-purple"] .modal-close {
    background: var(--primary-color) !important;
    color: white !important;
}

[data-theme="nostr-purple"] .modal-close:hover {
    background: var(--primary-hover) !important;
}

/* Search input theming for all themes */
#search-input {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

#search-input::placeholder {
    color: var(--text-muted) !important;
}

#search-input:focus {
    border-color: var(--primary-color) !important;
    outline: none;
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
}

/* Dark themes search input fixes */
[data-theme="dark-nostr"] #search-input,
[data-theme="bitcoin-gold"] #search-input,
[data-theme="nostr-purple"] #search-input {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="dark-nostr"] #search-input::placeholder,
[data-theme="bitcoin-gold"] #search-input::placeholder,
[data-theme="nostr-purple"] #search-input::placeholder {
    color: var(--text-muted) !important;
}

/* Date input theming */
[data-theme="dark-nostr"] input[type="date"],
[data-theme="bitcoin-gold"] input[type="date"],
[data-theme="nostr-purple"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
}

[data-theme="neon-green"] input[type="date"] {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
}

/* More comprehensive date input theming */
input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    border-radius: 4px;
    padding: 6px 8px;
    font-size: 12px;
}

/* Theme-specific date input styling */
[data-theme="dark-nostr"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: dark; /* This helps with native controls */
}

[data-theme="bitcoin-gold"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: dark;
}

[data-theme="nostr-purple"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: dark;
}

[data-theme="neon-green"] input[type="date"] {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    color-scheme: dark;
}

/* Enhanced calendar picker indicator styling */
input[type="date"]::-webkit-calendar-picker-indicator {
    background: transparent;
    bottom: 0;
    cursor: pointer;
    height: auto;
    left: 0;
    position: absolute;
    right: 0;
    top: 0;
    width: auto;
    opacity: 0.8;
}

/* Theme-specific calendar indicators */
[data-theme="dark-nostr"] input[type="date"]::-webkit-calendar-picker-indicator,
[data-theme="bitcoin-gold"] input[type="date"]::-webkit-calendar-picker-indicator,
[data-theme="nostr-purple"] input[type="date"]::-webkit-calendar-picker-indicator {
    filter: invert(1) brightness(0.8);
}

[data-theme="neon-green"] input[type="date"]::-webkit-calendar-picker-indicator {
    filter: invert(1) hue-rotate(120deg) saturate(2) brightness(1.2);
}

/* Focus states */
input[type="date"]:focus {
    border-color: var(--primary-color) !important;
    outline: none;
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary-color) 20%, transparent);
}

[data-theme="neon-green"] input[type="date"]:focus {
    border-color: var(--accent) !important;
    box-shadow: 0 0 0 2px rgba(0, 255, 0, 0.3);
}

/* Fix Nostr Purple theme - should use light color scheme */
[data-theme="nostr-purple"] input[type="date"] {
    background: var(--background-color) !important;
    color: var(--text-color) !important;
    border: 1px solid var(--border-color) !important;
    color-scheme: light; /* Changed from dark to light */
}

[data-theme="nostr-purple"] input[type="date"]::-webkit-calendar-picker-indicator {
    filter: none; /* Remove the invert filter for light theme */
    opacity: 0.7;
}

/* Neon green search input */
[data-theme="neon-green"] #search-input {
    background: var(--accent-weak-2) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
}

[data-theme="neon-green"] #search-input::placeholder {
    color: color-mix(in srgb, var(--accent) 60%, transparent) !important;
}

[data-theme="neon-green"] #search-input:focus {
    border-color: var(--accent) !important;
    box-shadow: 0 0 0 2px rgba(0, 255, 0, 0.3) !important;
}

body[data-theme="nostr-purple"] .note-card .hashtag:hover,
[data-theme="nostr-purple"] .note-card .hashtag:hover {
  background: color-mix(in srgb, var(--purple-color) 28%, #fff) !important;
}

/* neon-green: hashtags inside notes - higher specificity */
body[data-theme="neon-green"] .note-card .hashtag {
background: var(--accent-weak-2) !important;
border: 1px solid var(--accent-border) !important;
color: var(--accent) !important;
border-radius: 12px;
}
body[data-theme="neon-green"] .note-card .hashtag:hover {
background: var(--accent-weak) !important;
}
body[data-theme="neon-green"] .note-card .hashtag[data-selected="true"] {
background: var(--accent-weak) !important;
border-color: var(--accent) !important;
box-shadow: 0 0 6px rgba(0, 255, 0, 0.3) !important;
text-shadow: 0 0 3px var(--accent) !important;
}

/* neon-green: buttons */
[data-theme="neon-green"] .btn {
  background: var(--accent-weak);
  color: var(--accent);
  border: 1px solid var(--accent-border);
  text-shadow: 0 0 4px var(--accent);
}

[data-theme="neon-green"] .btn:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000);
  border-color: var(--accent);
}




/* neon-green: hashtags inside notes */
[data-theme="neon-green"] .hashtag {
background: var(--accent-weak-2);
border: 1px solid var(--accent-border);
color: var(--accent);
border-radius: 12px;
}
[data-theme="neon-green"] .hashtag:hover {
background: var(--accent-weak);
}
/* Add this line for selected state */
[data-theme="neon-green"] .hashtag[data-selected="true"] {
background: var(--accent-weak) !important;
border-color: var(--accent) !important;
box-shadow: 0 0 6px rgba(0, 255, 0, 0.3) !important;
text-shadow: 0 0 3px var(--accent) !important;
}

/* neon-green: tag filters in sidebar */
[data-theme="neon-green"] .tag-filter {
  background: var(--accent-weak-2);
  border-color: var(--accent-border);
  color: var(--accent);
}

[data-theme="neon-green"] .tag-filter:hover,
[data-theme="neon-green"] .tag-filter.active {
  background: var(--accent-weak) !important;
  border-color: var(--accent) !important;
  color: var(--accent) !important;
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.3) !important;
  text-shadow: 0 0 4px var(--accent) !important;
}

/* neon-green: progress bar */
[data-theme="neon-green"] .progress-bar {
  background: var(--accent-weak-2);
  border-color: var(--accent-border);
}
[data-theme="neon-green"] .progress-fill {
  background: var(--accent);
  color: #000;
  text-shadow: none;
}

/* neon-green: utility buttons (refresh, disconnect, clear cache, info, etc.) */
[data-theme="neon-green"] #refresh-btn,
[data-theme="neon-green"] #disconnect-btn,
[data-theme="neon-green"] #clear-cache-btn,
[data-theme="neon-green"] .modal-close {
  background: var(--accent-weak) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 4px var(--accent) !important;
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #refresh-btn:hover,
[data-theme="neon-green"] #disconnect-btn:hover,
[data-theme="neon-green"] #clear-cache-btn:hover,
[data-theme="neon-green"] .modal-close:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000) !important;
  border-color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* neon-green: All remaining buttons - comprehensive fix */
[data-theme="neon-green"] #search-keyword-btn,
[data-theme="neon-green"] #select-all-visible,
[data-theme="neon-green"] #deselect-all,
[data-theme="neon-green"] #select-all-keyword,
[data-theme="neon-green"] #deselect-all-keyword,
[data-theme="neon-green"] #bulk-add-to-archive,
[data-theme="neon-green"] #bulk-remove-from-archive,
[data-theme="neon-green"] #bulk-archive-btn,
[data-theme="neon-green"] #bulk-delete-btn {
  background: var(--accent-weak) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 4px var(--accent) !important;
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #search-keyword-btn:hover,
[data-theme="neon-green"] #select-all-visible:hover,
[data-theme="neon-green"] #deselect-all:hover,
[data-theme="neon-green"] #select-all-keyword:hover,
[data-theme="neon-green"] #deselect-all-keyword:hover,
[data-theme="neon-green"] #bulk-add-to-archive:hover,
[data-theme="neon-green"] #bulk-remove-from-archive:hover,
[data-theme="neon-green"] #bulk-archive-btn:hover,
[data-theme="neon-green"] #bulk-delete-btn:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000) !important;
  border-color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* neon-green: Dropdown selects */
[data-theme="neon-green"] #bulk-archive-dropdown,
[data-theme="neon-green"] #bulk-target-archive {
  background: var(--accent-weak-2) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
}

/* neon-green: Info buttons with inline styles */
[data-theme="neon-green"] button[onclick*="showNoteInfo"] {
  background: var(--accent-weak-2) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 3px var(--accent) !important;
}

/* neon-green: small info buttons */
[data-theme="neon-green"] .btn-small {
background: var(--accent-weak-2) !important;
color: var(--accent) !important;
border: 1px solid var(--accent-border) !important;
text-shadow: 0 0 3px var(--accent) !important;
}
[data-theme="neon-green"] .btn-small:hover {
background: var(--accent-weak) !important;
border-color: var(--accent) !important;
}

/* neon-green: Regular archives (non-active) */
[data-theme="neon-green"] .archive-item {
  background: var(--accent-weak-2) !important;
  border: 1px solid var(--accent-border) !important;
  color: var(--accent) !important;
  box-shadow: none !important;
}

/* neon-green: Only the active archive gets the glow */
[data-theme="neon-green"] .archive-item.active {
  background: var(--accent-weak) !important;
  border: 2px solid var(--accent) !important;
  color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* neon-green: Load More button */
[data-theme="neon-green"] #load-more-btn {
  background: var(--accent-weak) !important;
  color: var(--accent) !important;
  border: 1px solid var(--accent-border) !important;
  text-shadow: 0 0 4px var(--accent) !important;
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] #load-more-btn:hover {
  background: color-mix(in srgb, var(--accent) 28%, #000) !important;
  border-color: var(--accent) !important;
  box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

[data-theme="neon-green"] .modal {
    background: rgba(0, 0, 0, 0.8) !important;
}

[data-theme="neon-green"] .modal-content {
    background: var(--card-background) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    box-shadow: 0 0 20px rgba(0, 255, 0, 0.3) !important;
}

[data-theme="neon-green"] .modal-close {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    text-shadow: 0 0 4px var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] .modal-close:hover {
    background: color-mix(in srgb, var(--accent) 28%, #000) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* Neon green theme override for Import Archive */
[data-theme="neon-green"] #import-btn {
  background: #003300 !important;       /* darker green base */
  border: 1px solid var(--accent-border);
  color: var(--accent);
}

[data-theme="neon-green"] #import-btn:hover {
  background: #006600 !important;       /* brightens on hover */
  box-shadow: 0 0 12px rgba(0,255,0,0.35);
}

/* Hashtag group header hover effects */
.hashtag-group-header:hover {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Fix text color for dark themes */
[data-theme="dark-nostr"] .hashtag-group-header:hover,
[data-theme="bitcoin-gold"] .hashtag-group-header:hover {
    color: var(--card-background) !important;
}

/* Fix hashtag button hover text color for dark themes */
[data-theme="dark-nostr"] .tag-filter:hover,
[data-theme="bitcoin-gold"] .tag-filter:hover {
    color: var(--card-background) !important;
}

/* Neon green theme stays the same */
[data-theme="neon-green"] .hashtag-group-header {
    background: var(--accent-weak-2) !important;
    border-color: var(--accent-border) !important;
    color: var(--accent) !important;
}

[data-theme="neon-green"] .hashtag-group-header:hover {
    background: var(--accent-weak) !important;
    border-color: var(--accent) !important;
    color: var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.3) !important;
}

/* Fix Clear All Filters button theming */
[data-theme="neon-green"] .search-container button[onclick="clearAllFilters()"] {
    background: var(--accent-weak) !important;
    color: var(--accent) !important;
    border: 1px solid var(--accent-border) !important;
    text-shadow: 0 0 4px var(--accent) !important;
    box-shadow: 0 0 8px rgba(0, 255, 0, 0.2) !important;
}

[data-theme="neon-green"] .search-container button[onclick="clearAllFilters()"]:hover {
    background: color-mix(in srgb, var(--accent) 28%, #000) !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 12px rgba(0, 255, 0, 0.4) !important;
}

/* Fix hashtag hover colors for dark themes */
[data-theme="dark-nostr"] .tag-filter:hover {
    color: var(--text-color) !important;
    background: color-mix(in srgb, var(--primary-color) 40%, transparent) !important;
}

[data-theme="bitcoin-gold"] .tag-filter:hover {
    color: var(--text-color) !important;
    background: color-mix(in srgb, var(--primary-color) 40%, transparent) !important;
}

/* Hashtag drag selection styles */
.hashtag-selecting {
    cursor: grabbing !important;
}

.hashtag-selecting .hashtag {
    cursor: grabbing !important;
}

/* Improve hashtag hover states during selection */
.hashtag {
    transition: all 0.15s ease;
    user-select: none;
}

.hashtag:hover {
    transform: translateY(-1px);
}

/* Active hashtag styling */
.hashtag[data-selected="true"] {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}

/* Selected hashtag highlighting for Nostr Purple theme */
body[data-theme="nostr-purple"] .note-card .hashtag[data-selected="true"],
[data-theme="nostr-purple"] .note-card .hashtag[data-selected="true"] {
    background: var(--primary-color) !important;
    color: white !important;
    border-color: var(--primary-color) !important;
}


    </style>
</head>
<body>
    <div class="container">
        <!-- Connection Screen -->
        <div id="connection-screen">
            <div class="header">
                <h1><span class="emoji">📝</span> Nostr Notes Archive</h1>
                <p>View and organize your Nostr notes</p>
            </div>

            <div class="connection-box">
                <h3 style="text-align: center; margin-bottom: 20px;">Connect Your Account</h3>
                
                <div class="form-group">
               <label>Your Public Key (npub):</label>
<input type="text" id="pubkey-input" placeholder="Enter your npub..." style="font-family:monospace;">
<small style="color: var(--text-muted); font-size:12px;">
                </div>
                
                 <button id="connect-btn" class="btn"><span class="emoji">🔍</span> Load My Notes</button>
                
                <div class="info-box">
                    <strong>How to find your public key:</strong><br>
                    • Damus: Profile → Settings → Account → Public Key<br>
                    • Primal: Settings → Account → Copy public key<br>
                    • Iris: Profile → Copy public key<br>
                    <br>
                    Paste your npub (NIP-19) above.
                </div>

                <div id="connection-error" class="error"></div>
            </div>
        </div>

        <!-- Main App -->
        <div id="main-app" class="hidden">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <div>
                    <h2><span class="emoji">📝</span> My Nostr Archive</h2>
                  <small id="pubkey-display" style="color: var(--text-muted); font-family: monospace;">
                </div>
               <button id="disconnect-btn" style="background: #95a5a6; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
    Disconnect
</button>
            </div>

            <div class="app-layout">
    <div class="sidebar">
        <div class="search-container" style="margin-bottom: 16px;">
    <!-- Main search bar -->
    <div style="margin-bottom: 12px;">
        <input type="text" id="search-input" placeholder="Search notes... (/ to focus)" 
               style="width: 100%; padding: 8px 12px; border: 1px solid var(--border-color); border-radius: 4px;">
    </div>
    
    <!-- Quick filters - now toggleable -->
<div class="quick-filters" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; margin-bottom: 12px;">
    <button class="btn btn-tiny quick-filter-btn" data-filter="week" onclick="toggleQuickFilter('week')">This Week</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="month" onclick="toggleQuickFilter('month')">This Month</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="year" onclick="toggleQuickFilter('year')">This Year</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="images" onclick="toggleQuickFilter('images')">Images</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="youtube" onclick="toggleQuickFilter('youtube')">Videos</button>
    <button class="btn btn-tiny quick-filter-btn" data-filter="long" onclick="toggleQuickFilter('long')">Long</button>
</div>
    
    <!-- Date range filters -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
        <div>
            <label style="font-size: 11px; color: var(--text-muted); margin-bottom: 2px; display: block;">FROM DATE</label>
            <input type="date" id="date-from" onchange="applyDateFilters()" 
                   style="width: 100%; padding: 4px 6px; border: 1px solid var(--border-color); border-radius: 3px; font-size: 12px; background: var(--background-color); color: var(--text-color);">
        </div>
        <div>
            <label style="font-size: 11px; color: var(--text-muted); margin-bottom: 2px; display: block;">TO DATE</label>
            <input type="date" id="date-to" onchange="applyDateFilters()"
                   style="width: 100%; padding: 4px 6px; border: 1px solid var(--border-color); border-radius: 3px; font-size: 12px; background: var(--background-color); color: var(--text-color);">
        </div>
    </div>
    
    <!-- Clear filters button -->
    <button class="btn btn-tiny" onclick="clearAllFilters()" style="width: 100%; background: #95a5a6; color: white; border: none;">
        Clear All Filters
    </button>
</div>
        
        <div class="sidebar-section">
            <h4>My Archives</h4>
            <div id="archive-list">
                <!-- Archives will be populated here -->
            </div>
            <div style="margin-top: 15px;">
                <input type="text" id="new-archive-name" class="keyword-input" placeholder="New archive name..." maxlength="30">
               <button id="create-archive-btn" class="btn" style="font-size: 14px; padding: 8px;"><span class="emoji">🗂</span> Create Archive</button>
              </div>
        </div>

        <div class="sidebar-section">
            <h4>Filter by Tags</h4>
            <div id="tag-filters">
                <button class="tag-filter active" data-tag="">All Notes (0)</button>
               <button class="tag-filter" data-tag="__original" style="background: #3498db; color: white;"><span class="emoji">📝</span> Original Notes (0)</button>
               <button class="tag-filter" data-tag="__replies" style="background: #9b59b6; color: white;"><span class="emoji">💬</span> Replies (0)</button>
            </div>
        </div>

        <div class="sidebar-section">
            <h4>Export</h4>
            <button id="export-json" class="btn" style="font-size: 14px; padding: 8px;">Export JSON</button>
            <button id="export-md" class="btn" style="font-size: 14px; padding: 8px;">Export Markdown</button>
        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
        <input type="file" id="import-file" accept=".json,.md,.txt" style="display: none;">
        <div class="import-archive-block">
  <button id="import-btn" class="btn" style="font-size: 14px; padding: 8px; background: #27ae60;">
    <span class="emoji">📁</span> Import Archive
  </button>
  <small class="import-hint">Supports JSON exports from this app</small>
</div>
    </div>
    
    <button id="clear-cache-btn" class="btn" style="font-size: 14px; padding: 8px; background: #e74c3c;"><span class="emoji">🗑️</span> Clear Cache</button>
</div>

<button id="storage-info-btn" class="btn" style="font-size: 14px; padding: 8px;">
    Storage Info
</button>

        <div class="sidebar-section">
    <h4>Keyboard Shortcuts</h4>
    <div style="font-size: 12px; color: var(--text-muted); line-height: 1.4;">
        <div><kbd>/</kbd> or <kbd>Ctrl+K</kbd> Focus search</div>
        <div><kbd>Esc</kbd> Clear search/selections</div>
        <div><kbd>A</kbd> Select all visible</div>
        <div><kbd>Del</kbd> Remove selected</div>
    </div>
</div>

        <div class="sidebar-section">
            <h4>About</h4>
            <button id="app-info-btn" class="btn" style="font-size: 14px; padding: 8px;">
                App Info
            </button>
        </div>
        
        
    <div class="sidebar-section">
            <h4>Theme</h4>
            <select id="theme-selector" style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--card-background); color: var(--text-color);">
                <option value="default">Default Blue</option>
                <option value="nostr-purple">Nostr Purple</option>
                <option value="dark-nostr">Dark Nostr</option>
                <option value="bitcoin-gold">Bitcoin Gold</option>
                <option value="neon-green">Neon Green</option>
            </select>
    </div>
</div>


    <div class="main-content">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 32px; padding-bottom: 16px; border-bottom: 1px solid var(--border-color);">
    <div>
        <h3 id="notes-title">All Notes</h3>
        <small id="notes-count" style="color: var(--text-muted);">0 notes</small>
    </div>
   <button id="refresh-btn" style="background: #3498db; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
    <span class="emoji">🔄</span> Refresh
</button>
</div>



                    <div id="bulk-controls" class="bulk-controls hidden">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <span id="selected-count" style="font-weight: bold;">0 notes selected</span>
                            <div>
                                <button id="select-all-visible" class="btn btn-small" style="background: #34495e;">Select All Visible</button>
                                <button id="deselect-all" class="btn btn-small" style="background: #7f8c8d;">Deselect All</button>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                           <select id="bulk-archive-dropdown" style="flex: 1; min-width: 150px; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--card-background); color: var(--text-color);">
                                <option value="">Select archive...</option>
                            </select>
                           <button id="bulk-add-to-archive" class="btn btn-small" style="background: #27ae60;"><span class="emoji">📂</span> Add to Archive</button>
                           <button id="bulk-remove-from-archive" class="btn btn-small" style="background: #e74c3c;"><span class="emoji">🗑️</span> Remove from Archive</button>
                        </div>
                    </div>
                  <!-- Loader: ALL loader UI goes inside #loading -->
<div id="loading" class="loading hidden">
<div style="font-size: 24px; margin-bottom: 10px;"><span class="emoji">🔄</span></div>
  <p id="loading-text">Loading your notes...</p>
  <div class="progress-bar">
    <div id="progress-fill" class="progress-fill" style="width: 0%;">0%</div>
  </div>
  <div id="status-info" class="status-info"></div>
</div>


<!-- Notes list lives OUTSIDE the loading box -->
<div id="notes-container"></div>

<div id="load-more-container" class="hidden" style="text-align: center; margin: 20px 0;">
  <button id="load-more-btn" class="btn">Load More Notes</button>
  <div id="pagination-info" style="font-size:14px;">
    Showing 0 of 0 notes
  </div>
</div>


<!-- Empty state also OUTSIDE the loading box -->
<div id="empty-state" class="hidden" style="text-align: center; padding: 50px; color: #666;">
<div style="font-size: 48px; margin-bottom: 20px;"><span class="emoji">📝</span></div>
  <h3>No notes found</h3>
  <p>Make sure you've posted notes to Nostr, or check your public key.</p>
</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentPubkey = null;
        let allNotes = [];
        let filteredNotes = [];
        let archivedNotes = new Set(); // Keep for backward compatibility
        let namedArchives = {}; // New: stores multiple archives { archiveName: Set(noteIds) }
        let currentTag = '';
        let searchQuery = '';
        let currentArchive = 'default'; // Track which archive we're viewing
        let selectedNotes = new Set(); // Track selected notes for bulk operations
        let selectedTags = new Set(); // NEW: multi-select tags
        let notesPerPage = 100;
        let currentPage = 1;

// IndexedDB setup with Dexie
let db = null;

          // ADD THIS FUNCTION HERE:
        function npubToHex(npub) {
            try {
                if (!window.NostrTools || !window.NostrTools.nip19) {
                    throw new Error('NostrTools library not loaded');
                }
                
                const decoded = window.NostrTools.nip19.decode(npub);
                if (decoded.type !== 'npub') {
                    throw new Error('Not a valid npub');
                }
                
                return decoded.data;
            } catch (error) {
                console.error('Error converting npub to hex:', error);
                return null;
            }
        }

// Normalize pasted npub (strip spaces, prefix, hidden chars)
function normalizeNpub(input) {
  let s = (input || '').trim().toLowerCase();

  // remove spaces/newlines
  s = s.replace(/\s+/g, '');

  // remove nostr: URI prefix if present
  s = s.replace(/^nostr:/, '');

  // remove zero-width characters and BOM
  s = s.replace(/[\u200B-\u200D\uFEFF]/g, '');

  // replace “smart quotes” with plain quotes (just in case)
  s = s.replace(/[‘’]/g, "'").replace(/[“”]/g, '"');

  return s;
}

        // Enhanced relay list with better reliability
    const RELAYS = [
    'wss://relay.snort.social',
    'wss://relay.nostrplebs.com',
    'wss://relay.damus.io',
    'wss://relay.primal.net',
    'wss://offchain.pub',
    'wss://nostr.wine',
    'wss://nostr.land',
    'wss://nos.lol',
    'wss://relay.nostr.band'
];

        // Initialize the app
      document.addEventListener('DOMContentLoaded', function () {
    setupEventListeners();
    setupKeyboardShortcuts();
    setupHashtagDragSelection();

  // Auto-login if we have a saved npub
  const savedNpub = localStorage.getItem('nostr-saved-npub');
  if (savedNpub) {
    document.getElementById('pubkey-input').value = savedNpub;
    connectWithPubkey();
  }
});

        function setupEventListeners() {
            document.getElementById('connect-btn').addEventListener('click', connectWithPubkey);
            document.getElementById('disconnect-btn').addEventListener('click', disconnect);
            document.getElementById('storage-info-btn').addEventListener('click', showStorageInfo);

          // Add null check for app-info-btn
            const appInfoBtn = document.getElementById('app-info-btn');
            if (appInfoBtn) {
                appInfoBtn.addEventListener('click', showAppInfo);
            }    

           // Add null checks for import elements
    const importBtn = document.getElementById('import-btn');
    const importFile = document.getElementById('import-file');
    
    if (importBtn) importBtn.addEventListener('click', triggerFileImport);
    if (importFile) importFile.addEventListener('change', handleFileImport);

            // NEW: allow pressing Enter in the npub box to connect
const pubkeyInput = document.getElementById('pubkey-input');
pubkeyInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    connectWithPubkey();
  }
});

           // IMPROVEMENT 3: Debounced search for better performance
let searchTimeout;
document.getElementById('search-input').addEventListener('input', function(e) {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => handleSearch(e), 300);
});
            document.getElementById('refresh-btn').addEventListener('click', refreshNotes);
            document.getElementById('export-json').addEventListener('click', exportAsJSON);
            document.getElementById('export-md').addEventListener('click', exportAsMarkdown);
            document.getElementById('create-archive-btn').addEventListener('click', createNewArchive);
            document.getElementById('new-archive-name').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        createNewArchive();
    }
});
            document.getElementById('clear-cache-btn').addEventListener('click', clearAllCache);
            document.getElementById('load-more-btn').addEventListener('click', loadMoreNotes);
            
            
            // Bulk controls for main view
            document.getElementById('select-all-visible').addEventListener('click', selectAllVisible);
            document.getElementById('deselect-all').addEventListener('click', deselectAll);
            document.getElementById('bulk-add-to-archive').addEventListener('click', bulkAddToArchive);
            document.getElementById('bulk-remove-from-archive').addEventListener('click', bulkRemoveFromArchive);
        }

        function setupHashtagDragSelection() {
    const tagFiltersEl = document.getElementById('tag-filters');
    if (!tagFiltersEl) return;
    
    // Remove any existing listeners to prevent duplicates
    if (tagFiltersEl.__dragSetup) return;
    
    // Handle mousedown on hashtag buttons only
    tagFiltersEl.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return; // Left mouse button only
        
        const btn = e.target.closest('.tag-filter');
        if (!btn) return;
        
        const tag = btn.dataset.tag;
        if (!tag || !tag.startsWith('#')) return; // Only hashtags, not special buttons
        
        startHashtagSelection(tag, e);
    });
    
    // Handle mouseover for dragging
    tagFiltersEl.addEventListener('mouseover', (e) => {
        if (!isSelecting) return;
        
        const btn = e.target.closest('.tag-filter');
        if (!btn) return;
        
        const tag = btn.dataset.tag;
        if (!tag || !tag.startsWith('#')) return;
        
        continueHashtagSelection(tag, e);
    });
    
    tagFiltersEl.__dragSetup = true; // Prevent duplicate setup
}

        function loadArchivedNotes() {
    if (!currentPubkey) return; // Don't load if no user connected
    
    try {
        // Load legacy archive for backward compatibility
        const saved = localStorage.getItem(`nostr-archived-notes-${currentPubkey}`);
        if (saved) {
            archivedNotes = new Set(JSON.parse(saved));
        } else {
            archivedNotes = new Set();
        }
        
        // Load named archives
        const savedArchives = localStorage.getItem(`nostr-named-archives-${currentPubkey}`);
        if (savedArchives) {
            const parsed = JSON.parse(savedArchives);
            namedArchives = {};
            Object.keys(parsed).forEach(name => {
                namedArchives[name] = new Set(parsed[name]);
            });
        } else {
            namedArchives = {};
        }
        
        // Migration logic (only for this specific user)
        if (archivedNotes.size > 0 && !namedArchives['My Archive']) {
            namedArchives['My Archive'] = new Set([...archivedNotes]);
            archivedNotes.clear();
            saveArchivedNotes();
        }
    } catch (error) {
        console.error('Error loading archived notes:', error);
        namedArchives = {};
        archivedNotes = new Set();
    }
}

// IMPROVEMENT: Keyboard shortcuts
function setupKeyboardShortcuts() {
    document.addEventListener('keydown', function(e) {
        // Don't trigger shortcuts when typing in inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            // Exception: Escape should work even in inputs
            if (e.key === 'Escape') {
                e.target.blur();
                if (e.target.id === 'search-input') {
                    e.target.value = '';
                    handleSearch();
                }
            }
            return;
        }

         // NEW: allow Enter to submit npub on the connection screen
  if (e.key === 'Enter') {
    const connectionScreen = document.getElementById('connection-screen');
    const pubkeyInput = document.getElementById('pubkey-input');

    if (
      connectionScreen && pubkeyInput &&
      !connectionScreen.classList.contains('hidden') &&
      (document.activeElement === pubkeyInput || pubkeyInput.value.trim())
    ) {
      e.preventDefault();
      connectWithPubkey();
      return; // handled
    }
  }


        // Prevent default for handled shortcuts
        const handled = true;

        switch(e.key) {
            case '/':
                e.preventDefault();
                document.getElementById('search-input').focus();
                break;
                
            case 'Escape':
    // Always clear everything and go back to "All Notes" state
    const searchInput = document.getElementById('search-input');
    
    // Clear search input
    searchInput.value = '';
    searchQuery = '';
    
    // Clear ALL filters and states
    activeQuickFilters.clear();
    selectedTags.clear();
    currentTag = '';
    currentArchive = 'default';
    
    // Clear all UI active states
    document.querySelectorAll('.quick-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    document.querySelectorAll('.tag-filter').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.tag === '') {
            btn.classList.add('active');
        }
    });
    
    // Clear date filters
    document.getElementById('date-from').value = '';
    document.getElementById('date-to').value = '';
    
    // Clear selections
    deselectAll();
    
    // Force reset to all notes
    filteredNotes = allNotes.slice();
    resetPagination();
    renderNotes();
    
    // Reset title and count
    document.getElementById('notes-title').textContent = 'All Notes';
    document.getElementById('notes-count').textContent = `${allNotes.length} notes`;
    
    // Blur the search input
    searchInput.blur();
    break;
                
            case 'k':
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    document.getElementById('search-input').focus();
                }
                break;
                
            case 'a':
                if (!e.ctrlKey && !e.metaKey) {
                    // Toggle select all visible notes
                    if (selectedNotes.size > 0) {
                        deselectAll();
                    } else {
                        selectAllVisible();
                    }
                }
                break;
                
            case 'Delete':
            case 'Backspace':
                if (selectedNotes.size > 0) {
                    e.preventDefault();
                    if (confirm(`Remove ${selectedNotes.size} selected notes from all archives?`)) {
                        bulkRemoveFromArchive();
                    }
                }
                break;
                
                
            default:
                return; // Don't prevent default for unhandled keys
        }
    });
}

function saveArchivedNotes() {
    if (!currentPubkey) return; // Don't save if no user connected
    try {
        // Save legacy for backward compatibility
        localStorage.setItem(`nostr-archived-notes-${currentPubkey}`, JSON.stringify([...archivedNotes]));

        // Save named archives (convert Sets to arrays for JSON)
        const toSave = {};
        Object.keys(namedArchives).forEach(name => {
            toSave[name] = [...namedArchives[name]];
        });
        localStorage.setItem(`nostr-named-archives-${currentPubkey}`, JSON.stringify(toSave));
    } catch (error) {
        console.error('Error saving archived notes:', error);
    }
}

        function createNewArchive() {
    const name = document.getElementById('new-archive-name').value.trim();
    if (!name) {
        showToast('Please enter an archive name', 'error');
        return;
    }
    
    if (namedArchives[name]) {
        showToast('Archive with this name already exists', 'error');
        return;
    }
    
    namedArchives[name] = new Set();
    saveArchivedNotes();
    updateArchiveList();
    updateTargetArchiveDropdown();
    
    document.getElementById('new-archive-name').value = '';
    showToast(`Archive "${name}" created successfully!`, 'success');
}

        function deleteArchive(archiveName) {
            if (confirm(`Are you sure you want to delete the archive "${archiveName}"? This cannot be undone.`)) {
                delete namedArchives[archiveName];
                saveArchivedNotes();
                updateArchiveList();
                updateTargetArchiveDropdown();
                
                // If we were viewing the deleted archive, switch to all notes
                if (currentArchive === archiveName) {
                    filterByTag('');
                }
            }
        }

       function viewArchive(archiveName) {
    // Check if we're already viewing this archive - if so, go back to All Notes
    if (currentArchive === archiveName) {
        // Reset to All Notes view
        currentArchive = 'default';
        currentTag = '';
        selectedTags.clear(); // ADDED: Clear hashtag selections
        
        // Clear all active states
        document.querySelectorAll('.archive-item').forEach(item => {
            item.classList.remove('active');
        });
        
        // Set "All Notes" as active in tag filters
        document.querySelectorAll('.tag-filter').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.tag === '') {
                btn.classList.add('active');
            }
        });
        
        // Use the existing filterByTag function to properly reset to all notes
        filterByTag('');
        
        return; // Exit early
    }
    
    // Normal archive selection
    currentArchive = archiveName;
    currentTag = '__archive_' + archiveName;
    selectedTags.clear(); // ADDED: Clear hashtag selections when switching to archive
    
    // Clear all active states first
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Clear tag filters active states
    document.querySelectorAll('.tag-filter').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Use the existing filterByTag function
    filterByTag('__archive_' + archiveName);
    
    // Force update the archive list to show correct active state
    updateArchiveList();
}

        function updateArchiveList() {
    const container = document.getElementById('archive-list');
    if (!container) return;
    
    if (Object.keys(namedArchives).length === 0) {
        container.innerHTML = '<div style="color: #666; font-style: italic; font-size: 13px;">No archives created yet</div>';
        return;
    }
    
    container.innerHTML = Object.keys(namedArchives).map(name => {
        const count = namedArchives[name].size;
        const isActive = currentArchive === name;
        
        return `
            <div class="archive-item ${isActive ? 'active' : ''}" onclick="viewArchive('${name}')">
                <div class="archive-name">${escapeHtml(name)}</div>
                <div class="archive-count">(${count})</div>
                <div class="archive-actions" onclick="event.stopPropagation();">
                    <button class="btn btn-tiny btn-delete" onclick="deleteArchive('${name}')">×</button>
                </div>
            </div>
        `;
    }).join('');
}

        function updateTargetArchiveDropdown() {
    const bulkArchiveDropdown = document.getElementById('bulk-archive-dropdown');
    
    const archiveOptions = '<option value="">Select archive...</option>' +
        Object.keys(namedArchives).map(name => 
            `<option value="${name}">${escapeHtml(name)}</option>`
        ).join('');
    
    if (bulkArchiveDropdown) bulkArchiveDropdown.innerHTML = archiveOptions;
}

        function toggleArchiveNote(noteId, archiveName = null) {
            // If no specific archive is provided, show archive selection
            if (!archiveName && Object.keys(namedArchives).length > 0) {
                showArchiveSelectionModal(noteId);
                return;
            }
            
            // Legacy behavior - add to default archive
            if (archivedNotes.has(noteId)) {
                archivedNotes.delete(noteId);
                // Also remove from all named archives
                Object.keys(namedArchives).forEach(name => {
                    namedArchives[name].delete(noteId);
                });
            } else {
                // Add to "My Archive" if it exists, otherwise create it
                if (!namedArchives['My Archive']) {
                    namedArchives['My Archive'] = new Set();
                }
                namedArchives['My Archive'].add(noteId);
            }
            
            saveArchivedNotes();
            renderNotes();
            updateTagFilters();
            updateArchiveList();
        }

        function addToArchive(noteId, archiveName) {
            if (!namedArchives[archiveName]) {
                namedArchives[archiveName] = new Set();
            }
            
            namedArchives[archiveName].add(noteId);
            
            saveArchivedNotes();
            renderNotes();
            updateTagFilters();
            updateArchiveList();
        }

        function showArchiveSelectionModal(noteId) {
    const archiveNames = Object.keys(namedArchives);
    if (archiveNames.length === 0) {
       showToast('Please create an archive first');
        return;
    }
    
    // Create custom modal HTML
    const optionsList = archiveNames.map((name, index) => 
        `<div class="archive-option" data-index="${index}" onclick="selectArchiveOption(${index}, '${noteId}')">
            ${index + 1}. ${escapeHtml(name)}
        </div>`
    ).join('');
    
    const modalHtml = `
        <div class="modal" onclick="closeArchiveModal(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeArchiveModal()">×</button>
                <h3>Select archive for this note:</h3>
                <div class="archive-options">
                    ${optionsList}
                </div>
                <div style="margin-top: 20px; text-align: center;">
                    <button class="btn btn-small" onclick="closeArchiveModal()">Cancel</button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function selectArchiveOption(index, noteId) {
    const archiveNames = Object.keys(namedArchives);
    if (index >= 0 && index < archiveNames.length) {
        addToArchive(noteId, archiveNames[index]);
        showToast(`Note added to "${archiveNames[index]}" archive!`, 'success');
    }
    closeArchiveModal();
}

function closeArchiveModal(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

        // Bulk operations for main view
        function toggleNoteSelection(noteId) {
            if (selectedNotes.has(noteId)) {
                selectedNotes.delete(noteId);
            } else {
                selectedNotes.add(noteId);
            }
            updateSelectionUI();
        }

        function selectAllVisible() {
            filteredNotes.forEach(note => selectedNotes.add(note.id));
            updateSelectionUI();
            renderNotes();
        }

        function deselectAll() {
            selectedNotes.clear();
            updateSelectionUI();
            renderNotes();
        }

        function bulkAddToArchive() {
            const targetArchive = document.getElementById('bulk-archive-dropdown').value;
           if (!targetArchive) {
    showToast('Please select a target archive', 'error');
    return;
}

            if (selectedNotes.size === 0) {
                showToast('Please select some notes first');
                return;
            }

            let addedCount = 0;
            selectedNotes.forEach(noteId => {
                if (!namedArchives[targetArchive].has(noteId)) {
                    namedArchives[targetArchive].add(noteId);
                    addedCount++;
                }
            });

            saveArchivedNotes();
            updateArchiveList();
            updateTagFilters();
            selectedNotes.clear();
            updateSelectionUI();
            renderNotes();

            showToast(`Added ${addedCount} notes to "${targetArchive}" archive`, 'success');
        }

        function bulkRemoveFromArchive() {
            if (selectedNotes.size === 0) {
               showToast('Please select some notes first');
                return;
            }

            let removedCount = 0;
            selectedNotes.forEach(noteId => {
                Object.keys(namedArchives).forEach(archiveName => {
                    if (namedArchives[archiveName].has(noteId)) {
                        namedArchives[archiveName].delete(noteId);
                        removedCount++;
                    }
                });
                archivedNotes.delete(noteId);
            });

            saveArchivedNotes();
            updateArchiveList();
            updateTagFilters();
            selectedNotes.clear();
            updateSelectionUI();
            renderNotes();

            showToast(`Removed ${removedCount} notes from all archives`, 'success');
        }

        function updateSelectionUI() {
            const bulkControls = document.getElementById('bulk-controls');
            const selectedCount = document.getElementById('selected-count');
            
            if (selectedNotes.size > 0) {
                bulkControls.classList.remove('hidden');
                selectedCount.textContent = `${selectedNotes.size} notes selected`;
            } else {
                bulkControls.classList.add('hidden');
            }
        }

       async function connectWithPubkey() {
    // Move these to the very start

     // TEMPORARY: Force fresh fetch
    useIndexedDB = true;
    
    const connectBtn = document.getElementById('connect-btn');
    connectBtn.classList.add('loading');
    connectBtn.disabled = true;
    connectBtn.textContent = 'Connecting...';

    // Check if NostrTools is available
    if (!window.NostrTools) {
        showError('NostrTools library not loaded. Please refresh the page.');
        // Reset button on error
        connectBtn.classList.remove('loading');
        connectBtn.disabled = false;
        connectBtn.textContent = 'Load My Notes';
        return;
    }
    
    const raw = document.getElementById('pubkey-input').value;
    const npub = normalizeNpub(raw);

    if (!npub) {
        showError('Please enter your npub');
      connectBtn.classList.remove('loading');
    connectBtn.disabled = false;
    connectBtn.textContent = 'Load My Notes';
    return;
}
    if (!npub.startsWith('npub1')) {
        showError('Invalid npub (must start with "npub1")');
      connectBtn.classList.remove('loading');
    connectBtn.disabled = false;
    connectBtn.textContent = 'Load My Notes';
    return;
}

    if (!/^npub1[02-9ac-hj-np-z]+$/.test(npub)) {
        showError('Invalid npub format');
       connectBtn.classList.remove('loading');
    connectBtn.disabled = false;
    connectBtn.textContent = 'Load My Notes';
    return;
}

    const hexPubkey = npubToHex(npub);
    if (!hexPubkey || hexPubkey.length !== 64) {
        showError('Invalid npub format - could not convert to hex');
       connectBtn.classList.remove('loading');
    connectBtn.disabled = false;
    connectBtn.textContent = 'Load My Notes';
    return;
}

    currentPubkey = hexPubkey.toLowerCase();

// Clear any previous data when switching users
allNotes = [];
filteredNotes = [];
selectedTags.clear();
currentTag = '';

// Clear all filters when switching users
activeQuickFilters.clear();
document.querySelectorAll('.quick-filter-btn').forEach(btn => {
    btn.classList.remove('active');
});

// Clear date filters
document.getElementById('date-from').value = '';
document.getElementById('date-to').value = '';

// Clear search
document.getElementById('search-input').value = '';
searchQuery = '';

// Clear hashtag active states
document.querySelectorAll('.tag-filter').forEach(btn => {
    btn.classList.remove('active');
});

// Reset archive states
currentArchive = 'default';
document.querySelectorAll('.archive-item').forEach(item => {
    item.classList.remove('active');
});

    document.getElementById('tag-filters').innerHTML = '<button class="tag-filter active" data-tag="">Loading...</button>';

    // Load archives for this specific user
loadArchivedNotes();
updateArchiveList();

    // Save the npub for next time
localStorage.setItem('nostr-saved-npub', npub);

document.getElementById('connection-screen').classList.add('hidden');
document.getElementById('main-app').classList.remove('hidden');

    document.getElementById('pubkey-display').textContent = 
   npub.substring(0, 12) + '...' + npub.substring(npub.length - 8);
    
    updateArchiveList();
    updateTargetArchiveDropdown();
    
    await loadNotes(false, false); // false = not silent, false = not refresh (initial load)

   // Reset button after success
connectBtn.classList.remove('loading');
connectBtn.disabled = false;
connectBtn.textContent = 'Load My Notes';
}
    

        function disconnect() {
    // Store the old pubkey before clearing
    const oldPubkey = currentPubkey;
    
    // Reset all variables
    currentPubkey = null;
    allNotes = [];
    filteredNotes = [];
    currentArchive = 'default';
    selectedTags.clear();
    currentTag = '';
    selectedNotes.clear();
    searchQuery = '';

    // Clear all filters on disconnect
activeQuickFilters.clear();
document.querySelectorAll('.quick-filter-btn').forEach(btn => {
    btn.classList.remove('active');
});
document.getElementById('date-from').value = '';
document.getElementById('date-to').value = '';
document.getElementById('search-input').value = '';
searchQuery = '';
    
    // Clear ONLY cache data, NOT user archives
    localStorage.removeItem('nostr-last-pubkey');
    localStorage.removeItem('nostr-cached-notes'); 
    localStorage.removeItem('nostr-cache-updated-at');
    localStorage.removeItem('nostr-saved-npub');
    // DO NOT clear: nostr-archived-notes-* and nostr-named-archives-*
    
    // Clear the UI immediately
    document.getElementById('notes-container').innerHTML = '';
    document.getElementById('tag-filters').innerHTML = '<button class="tag-filter active" data-tag="">All Notes (0)</button>';
    document.getElementById('notes-count').textContent = '0 notes';
    document.getElementById('archive-list').innerHTML = '<div style="color: #666; font-style: italic; font-size: 13px;">No archives created yet</div>';

    // Clear pagination state when switching users
    document.getElementById('load-more-container').classList.add('hidden');
    document.getElementById('pagination-info').textContent = 'Showing 0 of 0 notes';
    
    document.getElementById('main-app').classList.add('hidden');
    document.getElementById('connection-screen').classList.remove('hidden');
    document.getElementById('pubkey-input').value = '';

    hideError();
}

// IndexedDB fallback handler
let useIndexedDB = true;

function disableIndexedDB(error) {
    console.warn('IndexedDB disabled due to error:', error);
    useIndexedDB = false;
    showToast('Storage limitation detected - using memory-only mode', 'warning');
    
    // Log the error type for debugging
    if (error.name === 'QuotaExceededError') {
        showToast('Storage quota exceeded - consider clearing old data', 'warning');
    } else if (error.name === 'InvalidStateError') {
        console.log('Database state error - likely corruption or version mismatch');
    }
}

async function initDatabase(pubkey) {
    if (!useIndexedDB) return null;
    
    try {
        const dbName = `nostr-notes-${pubkey}`;
        
        if (db && db.isOpen()) {
            db.close();
        }
        
        db = new Dexie(dbName);
        db.version(1).stores({
            notes: 'id, pubkey, created_at, content, *hashtags, isReply',
            settings: 'key, value'
        });
        
        await db.open();
        return db;
    } catch (error) {
        disableIndexedDB(error);
        return null;
    }
}

function clearLegacyCache(pubkey) {
    try {
        localStorage.removeItem(`nostr-last-pubkey-${pubkey}`);
        localStorage.removeItem(`nostr-cached-notes-${pubkey}`);
        localStorage.removeItem(`nostr-cache-updated-at-${pubkey}`);
    } catch (error) {
        console.warn('Could not clear legacy cache:', error);
    }
}

async function fetchNotesFromRelays(pubkey) {
    const allEvents = [];
    const completedRelays = [];
    
    console.log('=== STARTING RELAY FETCH ===');
    
    // Better progress feedback with relay status tracking
    const relayStatuses = new Map();
    const relayPromises = RELAYS.map(async (relay, index) => {
        const relayName = relay.replace('wss://', '');
        relayStatuses.set(relay, 'connecting');
        
        try {
            updateStatus(`<span class="emoji">🔄</span> ${relayName}: Connecting.`);
            
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => {
                    relayStatuses.set(relay, 'timeout');
                    reject(new Error('Timeout after 60s'));
                }, 60000);
            });
            
            const fetchPromise = fetchAllNotesFromRelay(relay, pubkey, (progress, status) => {
                relayStatuses.set(relay, 'fetching');
                const completedCount = Array.from(relayStatuses.values()).filter(s => s === 'completed' || s === 'failed').length;
                updateProgress(
                    20 + ((completedCount / RELAYS.length) * 60), 
                    `${relayName}: ${status} | ${completedCount}/${RELAYS.length} relays done`
                );
            });
            
            const events = await Promise.race([fetchPromise, timeoutPromise]);
            
            relayStatuses.set(relay, 'completed');
            const completedCount = Array.from(relayStatuses.values()).filter(s => s === 'completed').length;
            updateStatus(`<span class="emoji">✅</span> ${relayName}: ${events.length} notes (${completedCount}/${RELAYS.length} relays completed)`);
            
            completedRelays.push(relay);
            return { relay, events, success: true };
            
        } catch (error) {
            relayStatuses.set(relay, 'failed');
            const failedCount = Array.from(relayStatuses.values()).filter(s => s === 'failed').length;
            updateStatus(`❌ ${relayName}: ${error.message} (${failedCount} failed)`);
            return { relay, events: [], success: false, error: error.message };
        }
    });
    
    // Wait for ALL relays to finish
    const results = await Promise.allSettled(relayPromises);
    
    // Collect all events with logging
    results.forEach((result, index) => {
        if (result.status === 'fulfilled' && result.value.success) {
            console.log(`Adding ${result.value.events.length} events from ${result.value.relay}`);
            allEvents.push(...result.value.events);
        }
    });
    
    console.log(`=== TOTAL EVENTS COLLECTED: ${allEvents.length} ===`);
    updateProgress(80, `Deduplicating ${allEvents.length} notes...`);

    // MEMORY-SAFE DEDUPLICATION for image-heavy accounts
    console.log('Starting memory-safe deduplication...');
    const uniqueEvents = await memoryEfficientDeduplication(allEvents);
    
    console.log(`=== DEDUPLICATION COMPLETE: ${uniqueEvents.length} unique notes ===`);
    updateStatus(`✅ Deduplication complete: ${uniqueEvents.length} unique notes (removed ${allEvents.length - uniqueEvents.length} duplicates)`);

    return uniqueEvents;
}

// NEW: Memory-efficient deduplication for image-heavy accounts
async function memoryEfficientDeduplication(allEvents) {
    console.log(`Starting deduplication of ${allEvents.length} events`);
    
    const uniqueEventsMap = new Map();
    const chunkSize = 2000; // Process in smaller chunks for image-heavy accounts
    let duplicatesFound = 0;
    
    for (let startIndex = 0; startIndex < allEvents.length; startIndex += chunkSize) {
        const endIndex = Math.min(startIndex + chunkSize, allEvents.length);
        const chunk = allEvents.slice(startIndex, endIndex);
        
        console.log(`Processing chunk ${Math.floor(startIndex/chunkSize) + 1}: events ${startIndex}-${endIndex}`);
        
        chunk.forEach(event => {
            if (!event?.id) return;
            
            const existing = uniqueEventsMap.get(event.id);
            if (!existing) {
                uniqueEventsMap.set(event.id, event);
            } else {
                duplicatesFound++;
                // Keep the event with more complete data
                if ((event.tags?.length || 0) > (existing.tags?.length || 0) || 
                    event.content.length > existing.content.length) {
                    uniqueEventsMap.set(event.id, event);
                }
            }
        });
        
        // Update progress and yield control
        const progress = 80 + ((endIndex / allEvents.length) * 15);
        updateProgress(progress, `Deduplicating: ${endIndex}/${allEvents.length} processed (${duplicatesFound} duplicates found)`);
        
        // Yield control to prevent browser freeze
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Memory cleanup
        if (startIndex % 10000 === 0 && performance.memory) {
            const memoryMB = performance.memory.usedJSHeapSize / 1024 / 1024;
            console.log(`Memory usage: ${memoryMB.toFixed(1)} MB`);
            if (memoryMB > 500) {
                console.log('High memory usage detected, forcing garbage collection pause');
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
    }
    
    const uniqueEvents = Array.from(uniqueEventsMap.values());
    console.log(`Deduplication complete: ${uniqueEvents.length} unique events (${duplicatesFound} duplicates removed)`);
    
    return uniqueEvents;
}

async function fetchNotesFromRelaysSince(pubkey, sinceTimestamp) {
    const allEvents = [];
    const completedRelays = [];
    
    updateStatus('🔄 Checking relays for new notes...');
    
    const relayPromises = RELAYS.map(async (relay, index) => {
        const relayName = relay.replace('wss://', '');
        
        try {
            // Only fetch notes newer than our newest stored note
            const newNotes = await fetchNewNotesFromRelay(relay, pubkey, sinceTimestamp);
            
            updateStatus(`✅ ${relayName}: ${newNotes.length} new notes`);
            return { relay, events: newNotes, success: true };
            
        } catch (error) {
            updateStatus(`❌ ${relayName}: ${error.message}`);
            return { relay, events: [], success: false };
        }
    });
    
    const results = await Promise.allSettled(relayPromises);
    
    // Collect new events
    results.forEach((result) => {
        if (result.status === 'fulfilled' && result.value.success) {
            allEvents.push(...result.value.events);
        }
    });
    
    // Simple deduplication for new notes
    const uniqueEvents = [];
    const seenIds = new Set();
    
    allEvents.forEach(event => {
        if (event.id && !seenIds.has(event.id)) {
            seenIds.add(event.id);
            uniqueEvents.push(event);
        }
    });
    
    return uniqueEvents;
}

async function fetchNewNotesFromRelay(relayUrl, pubkey, sinceTimestamp) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        const events = [];
        let timeoutId;
        
        ws.onopen = function() {
            const filter = {
                kinds: [1],
                authors: [pubkey],
                since: sinceTimestamp + 1, // Only notes newer than this
                limit: 1000 // Reasonable limit for new notes
            };
            
            const subscription = ['REQ', 'incremental-' + Date.now(), filter];
            ws.send(JSON.stringify(subscription));
            
            timeoutId = setTimeout(() => {
                ws.close();
                resolve(events);
            }, 10000); // 10 second timeout
        };
        
        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const [type, subId, eventData] = message;
                
                if (type === 'EVENT') {
                    const note = processNote(eventData);
                    if (note) {
                        events.push(note);
                    }
                } else if (type === 'EOSE') {
                    clearTimeout(timeoutId);
                    ws.close();
                    resolve(events);
                }
            } catch (error) {
                console.error('Error parsing message:', error);
            }
        };
        
        ws.onerror = function() {
            clearTimeout(timeoutId);
            reject(new Error('Connection failed'));
        };
        
        ws.onclose = function() {
            clearTimeout(timeoutId);
            resolve(events);
        };
    });
}

async function fetchAllNotesFromRelay(relayUrl, pubkey, progressCallback) {
    const allEvents = [];
    let until = null;
    let batchNumber = 1;
   const batchSize = 1000
    
    while (true) {
        progressCallback(
            Math.min(95, (batchNumber - 1) * 15), 
            `batch ${batchNumber} (${allEvents.length} notes)`
        );
        
        try {
            
            const batchEvents = await fetchBatchFromRelay(relayUrl, pubkey, until, batchSize);
            
            allEvents.push(...batchEvents);
            
            const oldestEvent = batchEvents[batchEvents.length - 1];
            until = oldestEvent.created_at - 1;
            
            
            batchNumber++;
            
            // Only stop if we get no events or encounter errors
if (batchEvents.length === 0) {
    break;
}

// Rate limiting - longer delay for aggressive fetching
await new Promise(resolve => setTimeout(resolve, 150)); // Increased to 100ms

// Safety check - if we've been fetching for too long, break
if (batchNumber > 100) { // Allow up to 100 batches (200k notes max)
    console.log(`Reached safety limit of ${batchNumber} batches for ${relayUrl}`);
    break;
}
            
        } catch (error) {
            console.error(`Error fetching batch ${batchNumber} from ${relayUrl}:`, error);
            break;
        }
    }
    
    progressCallback(100, `complete (${allEvents.length} notes)`);
    return allEvents;
}

      // Add this function before loadNotes
async function loadNotesHybrid(pubkey, silent = false) {
    try {
        // Try to initialize IndexedDB
        const database = await initDatabase(pubkey);
        
        if (!database || !useIndexedDB) {
            return await fetchNotesFromRelays(pubkey);
        }
        
        // FAILSAFE 1: Check database integrity first
        const isHealthy = await checkDatabaseHealth(pubkey, silent);
        if (!isHealthy) {
            if (!silent) updateStatus('Database unhealthy, rebuilding...');
            return await fetchFreshAndStore(pubkey, silent);
        }
        
        // Check for existing data and last sync time
        const storedCount = await db.notes.count();
        const lastSync = await db.settings.get('last_sync_time');
        
        if (!silent) {
            updateStatus(`Database ready. Found ${storedCount} stored notes.`);
        }
        
        // FAILSAFE 2: Conservative cache validation
        const oneHour = 60 * 60 * 1000;
        const hasFreshCache = lastSync && 
                             (Date.now() - lastSync.value) < oneHour && 
                             storedCount > 50; // Require meaningful amount of data
        
        if (hasFreshCache) {
            if (!silent) {
                updateStatus('Loading from IndexedDB cache...');
            }
            
            try {
                const allStoredNotes = await db.notes
                    .orderBy('created_at')
                    .reverse()
                    .toArray();
                
                // FAILSAFE 3: Validate loaded data quality
                const validation = validateNotesData(allStoredNotes, storedCount);
                if (validation.isValid) {
                    if (!silent) updateStatus(`Cache validated: ${allStoredNotes.length} notes loaded`);
                    return allStoredNotes;
                } else {
                    if (!silent) {
                        updateStatus(`Cache validation failed: ${validation.reason}. Rebuilding...`);
                    }
                    await repairDatabase(pubkey);
                }
            } catch (error) {
                console.error('Error loading from cache:', error);
                if (!silent) updateStatus('Cache read error, rebuilding...');
                await repairDatabase(pubkey);
            }
        }
        
        // Fetch fresh data and store
        return await fetchFreshAndStore(pubkey, silent);
        
    } catch (error) {
        console.error('Critical loading error:', error);
        disableIndexedDB(error);
        return await fetchNotesFromRelays(pubkey);
    }
}

// PRODUCTION FAILSAFE SYSTEM

async function checkDatabaseHealth(pubkey, silent = false) {
    try {
        if (!db || !db.isOpen()) {
            if (!silent) updateStatus('Database connection failed');
            return false;
        }
        
        // Test basic database operations
        const testCount = await db.notes.count();
        const testSettings = await db.settings.toArray();
        
        // Check if we can read a sample note
        if (testCount > 0) {
            const sampleNote = await db.notes.limit(1).first();
            
            // Basic integrity checks
            if (!sampleNote) {
                if (!silent) updateStatus('Database count/data mismatch detected');
                return false;
            }
            
            if (!sampleNote.id || sampleNote.content === undefined || !sampleNote.created_at) {
                if (!silent) updateStatus('Invalid note structure detected');
                return false;
            }
        }
        
        // Test write capability
        try {
            await db.settings.put({ key: 'health_check', value: Date.now() });
            await db.settings.delete('health_check');
        } catch (writeError) {
            if (!silent) updateStatus('Database write test failed');
            return false;
        }
        
        return true;
    } catch (error) {
        console.error('Database health check failed:', error);
        return false;
    }
}

function validateNotesData(notes, expectedCount) {
    // Check we got reasonable amount of data
    const minExpected = Math.max(Math.min(expectedCount * 0.8, expectedCount - 100), 20);
    if (notes.length < minExpected) {
        return { 
            isValid: false, 
            reason: `Got ${notes.length} notes, expected at least ${minExpected}` 
        };
    }
    
    // Check data structure integrity
    const validNotes = notes.filter(note => 
        note && 
        note.id && 
        typeof note.id === 'string' &&
        note.content !== undefined && 
        note.created_at && 
        typeof note.created_at === 'number' &&
        Array.isArray(note.hashtags)
    );
    
    const validRatio = validNotes.length / notes.length;
    if (validRatio < 0.95) {
        return { 
            isValid: false, 
            reason: `${Math.round((1-validRatio)*100)}% of notes have invalid structure` 
        };
    }
    
    // Check for duplicate IDs (corruption indicator)
    const uniqueIds = new Set(validNotes.map(note => note.id));
    if (uniqueIds.size < validNotes.length * 0.98) {
        return { 
            isValid: false, 
            reason: 'Duplicate note IDs detected (data corruption)' 
        };
    }
    
    // Check timestamp sanity (notes can't be from the future)
    const now = Math.floor(Date.now() / 1000);
    const futureNotes = validNotes.filter(note => note.created_at > now + 3600);
    if (futureNotes.length > validNotes.length * 0.01) {
        return { 
            isValid: false, 
            reason: 'Invalid timestamps detected' 
        };
    }
    
    return { isValid: true, reason: 'Data validation passed' };
}

async function repairDatabase(pubkey) {
    try {
        console.log('Repairing database for', pubkey.substring(0, 8) + '...');
        
        // Close current connection
        if (db && db.isOpen()) {
            await db.close();
        }
        
        // Delete corrupted database
        const dbName = `nostr-notes-${pubkey}`;
        await new Promise((resolve) => {
            const deleteReq = indexedDB.deleteDatabase(dbName);
            deleteReq.onsuccess = () => {
                console.log('Corrupted database deleted successfully');
                resolve();
            };
            deleteReq.onerror = () => {
                console.log('Database deletion failed, continuing anyway');
                resolve();
            };
            deleteReq.onblocked = () => {
                console.log('Database deletion blocked, forcing continuation');
                setTimeout(resolve, 2000);
            };
            // Safety timeout
            setTimeout(resolve, 5000);
        });
        
        // Reinitialize fresh database
        db = null;
        await initDatabase(pubkey);
        
        console.log('Database repair completed successfully');
        return true;
    } catch (error) {
        console.error('Database repair failed:', error);
        disableIndexedDB(error);
        return false;
    }
}

async function fetchFreshAndStore(pubkey, silent = false) {
    if (!silent) updateStatus('Fetching fresh data from relays...');
    
    const freshNotes = await fetchNotesFromRelays(pubkey);
    
    if (freshNotes.length > 0 && db && useIndexedDB) {
        try {
            if (!silent) updateStatus('Storing fresh data in IndexedDB...');
            
            await db.notes.clear();
            await db.settings.clear();
            
            // Store in chunks to avoid memory issues
            const chunkSize = 1000;
            for (let i = 0; i < freshNotes.length; i += chunkSize) {
                const chunk = freshNotes.slice(i, i + chunkSize);
                await db.notes.bulkAdd(chunk);
                
                if (!silent && freshNotes.length > chunkSize) {
                    updateStatus(`Stored ${Math.min(i + chunkSize, freshNotes.length)}/${freshNotes.length} notes...`);
                }
            }
            
            await db.settings.put({ key: 'last_sync_time', value: Date.now() });
            await db.settings.put({ key: 'total_notes_stored', value: freshNotes.length });
            
            if (!silent) {
                updateStatus(`Successfully stored ${freshNotes.length} notes in IndexedDB`);
            }
        } catch (storeError) {
            console.error('Failed to store fresh data:', storeError);
            if (!silent) updateStatus('Storage failed, continuing with memory-only mode');
            disableIndexedDB(storeError);
        }
    }
    
    return freshNotes;
}

async function incrementalSync(pubkey, silent = true) {
    if (!db || !useIndexedDB) {
        return await fetchNotesFromRelays(pubkey); // Fallback to full fetch
    }
    
    try {
        // Get the newest note we have stored
        const newestStoredNote = await db.notes
            .orderBy('created_at')
            .reverse()
            .first();
        
        if (!newestStoredNote) {
            // No stored notes, do full fetch
            return await fetchNotesFromRelays(pubkey);
        }
        
        const lastTimestamp = newestStoredNote.created_at;
        
        if (!silent) {
            updateStatus(`Checking for notes newer than ${new Date(lastTimestamp * 1000).toLocaleString()}...`);
        }
        
        // Fetch only newer notes from relays
        const newNotes = await fetchNotesFromRelaysSince(pubkey, lastTimestamp);
        
        if (newNotes.length > 0) {
            // Add new notes to IndexedDB
            await db.notes.bulkAdd(newNotes);
            await db.settings.put({ key: 'last_sync_time', value: Date.now() });
            
            if (!silent) {
                updateStatus(`Found and stored ${newNotes.length} new notes`);
            }
            
            // Return all notes (existing + new) for display
            const allNotes = await db.notes
                .orderBy('created_at')
                .reverse()
                .toArray();
            
            return allNotes;
        } else {
            if (!silent) {
                updateStatus('No new notes found');
            }
            
            // Return existing notes
            return await db.notes
                .orderBy('created_at')
                .reverse()
                .toArray();
        }
        
    } catch (error) {
        console.error('Incremental sync error:', error);
        // Fallback to full fetch
        return await fetchNotesFromRelays(pubkey);
    }
}

async function loadNotes(silent = false, isRefresh = false) {
    const previousNotesCount = allNotes.length; // Track what we had before
    
    if (!silent) {
        showLoading(true);
        updateProgress(0, 'Connecting to relays.');
        updateStatus('Starting fresh load...', true);
    } else {
        // small indicator only
        updateStatus('Refreshing notes…');
    }
            
    try {

        const notes = await loadNotesHybrid(currentPubkey, silent);

// Clear old localStorage cache since we're using IndexedDB now
if (useIndexedDB) {
    clearLegacyCache(currentPubkey);
}
        
        updateStatus(`Sorting ${notes.length} notes by date...`);
        await new Promise(resolve => setTimeout(resolve, 10)); // Brief pause
        
        allNotes = notes.sort((a, b) => b.created_at - a.created_at);
        
        updateStatus('Updating archives list...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        // Initialize archives UI after loading
        updateArchiveList();
        updateTargetArchiveDropdown();
        
        updateStatus('Updating tag filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        updateTagFilters();
        
        updateStatus('Applying filters...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        applyFilters();
        
        updateStatus('Rendering notes...');
        await new Promise(resolve => setTimeout(resolve, 10));
        
        renderNotes();
        
        // FIXED: Calculate what was actually new
        const newNotesCount = allNotes.length - previousNotesCount;
        updateStatus(`✅ Successfully loaded ${allNotes.length} notes!`);
        
        if (!silent && isRefresh === true) {
            if (newNotesCount > 0) {
                showToast(`Refresh complete - ${newNotesCount} new notes loaded (${allNotes.length} total)`, 'success');
            } else {
                showToast(`Refresh complete - no new notes found (${allNotes.length} total)`, 'success');
            }
        } else {
        }
        
    } catch (error) {
        console.error('Error loading notes:', error);
        showError('Failed to load notes: ' + error.message);
    } finally {
    if (!silent) {
        showLoading(false);
        trackLoadTime();
    }
}
}// <-- closes async function loadNotes
      
async function fetchBatchFromRelay(relayUrl, pubkey, until, limit, retryCount = 0) {
    const maxRetries = 3;
    
    try {
        return await fetchBatchFromRelayCore(relayUrl, pubkey, until, limit);
    } catch (error) {
        if (retryCount < maxRetries) {
            const backoffDelay = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s
            console.log(`Retry ${retryCount + 1}/${maxRetries} for ${relayUrl} after ${backoffDelay}ms`);
            await new Promise(resolve => setTimeout(resolve, backoffDelay));
            return fetchBatchFromRelay(relayUrl, pubkey, until, limit, retryCount + 1);
        }
        throw error;
    }
}

function fetchBatchFromRelayCore(relayUrl, pubkey, until, limit) {
    return new Promise((resolve, reject) => {
        const ws = new WebSocket(relayUrl);
        const events = [];
        let timeoutId;
        let isResolved = false;
        let connectionStartTime = Date.now();
        let eventCount = 0;
        let noticeCount = 0;
        
        const cleanup = (reason = 'unknown') => {
            if (timeoutId) clearTimeout(timeoutId);
            if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
                ws.close(1000, 'Batch complete');
            }
        };
        
        const resolveOnce = (result) => {
            if (!isResolved) {
                isResolved = true;
                const duration = Date.now() - connectionStartTime;
                console.log(`[${relayUrl}] COMPLETED: ${result.length} events in ${duration}ms (${eventCount} total received, ${noticeCount} notices)`);
                cleanup(`resolved with ${result.length} events in ${duration}ms`);
                resolve(result);
            }
        };
        
        const rejectOnce = (error) => {
            if (!isResolved) {
                isResolved = true;
                console.error(`[${relayUrl}] FAILED: ${error.message} after ${Date.now() - connectionStartTime}ms`);
                cleanup('error: ' + error.message);
                reject(error);
            }
        };
        
        ws.onopen = function() {
            const filter = {
                kinds: [1],
                authors: [pubkey],
                limit: limit
            };
            
            if (until) {
                filter.until = until;
            }
            
            const subscription = ['REQ', 'batch-' + Date.now(), filter];
            console.log(`[${relayUrl}] CONNECTED: Requesting ${limit} notes${until ? ` until ${new Date(until * 1000).toISOString()}` : ''}`);
            ws.send(JSON.stringify(subscription));
            
            timeoutId = setTimeout(() => {
                console.log(`[${relayUrl}] TIMEOUT: ${events.length} events collected before timeout`);
                resolveOnce(events);
            }, 90000); // 90 second timeout for image-heavy accounts
        };
        
        ws.onmessage = function(event) {
            try {
                const message = JSON.parse(event.data);
                const [type, subId, eventData] = message;
                
                if (type === 'EVENT') {
                    eventCount++;
                    const note = processNote(eventData);
                    if (note) {
                        events.push(note);
                        // Log progress every 200 notes for image-heavy accounts
                        if (events.length % 200 === 0) {
                            console.log(`[${relayUrl}] PROGRESS: ${events.length} valid notes processed (${eventCount} total events received)`);
                        }
                    } else {
                        // Log when notes are rejected by processNote
                        if (eventCount % 100 === 0) {
                            console.log(`[${relayUrl}] FILTERING: ${eventCount - events.length} events filtered out of ${eventCount} total`);
                        }
                    }
                } else if (type === 'EOSE') {
                    console.log(`[${relayUrl}] EOSE: End of stream, ${events.length} notes collected`);
                    resolveOnce(events);
                } else if (type === 'NOTICE') {
                    noticeCount++;
                    if (message[1] && message[1].toLowerCase().includes('error')) {
                        console.warn(`[${relayUrl}] ERROR NOTICE:`, message[1]);
                    } else {
                        console.log(`[${relayUrl}] NOTICE:`, message[1]);
                    }
                } else if (type === 'CLOSED') {
                    console.log(`[${relayUrl}] CLOSED: Subscription closed by relay`);
                    resolveOnce(events);
                } else {
                    console.log(`[${relayUrl}] UNKNOWN MESSAGE TYPE:`, type);
                }
            } catch (error) {
                console.error(`[${relayUrl}] MESSAGE PARSE ERROR:`, error, 'Raw message:', event.data);
            }
        };
        
        ws.onerror = function(error) {
            console.error(`[${relayUrl}] WEBSOCKET ERROR:`, error);
            rejectOnce(new Error('Connection failed'));
        };
        
        ws.onclose = function(event) {
            const reason = event.reason || 'No reason provided';
            const code = event.code;
            console.log(`[${relayUrl}] CONNECTION CLOSED: Code ${code}, Reason: ${reason}, Clean: ${event.wasClean}`);
            if (!isResolved) {
                resolveOnce(events);
            }
        };
    });
}

        function processNote(event) {
    // Remove all console.log calls - they're killing performance
    if (!event || !event.content || !event.id) {
        return null;
    }
    
    const hashtags = extractHashtags(event.content);
    
    // Check if this is a reply by looking for 'e' or 'p' tags in the event
    const isReply = event.tags && event.tags.some(tag => 
        (tag[0] === 'e') || // 'e' tags reference other events (replies)
        (tag[0] === 'p' && tag[1] !== event.pubkey) || // 'p' tags reference other users
        event.content.startsWith('@') || // Content starts with mention
        event.content.includes('nostr:') // Contains nostr references
    );    
    
    return {
        id: event.id,
        pubkey: event.pubkey,
        created_at: event.created_at,
        content: event.content,
        hashtags: hashtags,
        isReply: isReply,
        tags: event.tags || []
    };
}

function setupLazyLoading() {
    // Simple lazy loading for images
    const images = document.querySelectorAll('img[loading="lazy"]');
    
    if ('IntersectionObserver' in window) {
        const imageObserver = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    if (img.dataset.src) {
                        img.src = img.dataset.src;
                        img.removeAttribute('data-src');
                    }
                    observer.unobserve(img);
                }
            });
        });
        
        images.forEach(img => imageObserver.observe(img));
    }
}

// ADD these functions after your clearIndexedDB functions (around line 2500):

// 1. ADD this function to show storage usage information
async function showStorageInfo() {
    try {
        let info = {
            localStorage: 0,
            indexedDB: 0,
            totalNotes: allNotes.length,
            loadedNotes: allNotes.length,
            archives: Object.keys(namedArchives).length,
            totalArchived: 0
        };
        
        // Calculate localStorage usage
        let localStorageSize = 0;
        for (let key in localStorage) {
            if (localStorage.hasOwnProperty(key)) {
                localStorageSize += localStorage[key].length + key.length;
            }
        }
        info.localStorage = (localStorageSize / 1024).toFixed(2); // KB
        
        // Calculate IndexedDB usage and note count
        if (db && useIndexedDB) {
            try {
                const totalInDB = await db.notes.count();
                info.totalNotes = totalInDB;
            } catch (error) {
                console.log('Could not get IndexedDB count:', error);
            }
        }
        
        // Calculate archived notes
        Object.values(namedArchives).forEach(archive => {
            info.totalArchived += archive.size;
        });
        
        // Show storage info modal
        const modalHtml = `
            <div class="modal" onclick="closeStorageInfo(event)">
                <div class="modal-content" onclick="event.stopPropagation()">
                    <button class="modal-close" onclick="closeStorageInfo()">Close</button>
                    <h3>Storage Information</h3>
                    <div style="font-family: monospace; line-height: 1.6;">
                        <p><strong>Notes:</strong></p>
                        <p>  • Total stored: ${info.totalNotes.toLocaleString()}</p>
                        <p>  • Currently loaded: ${info.loadedNotes.toLocaleString()}</p>
                        <p>  • Memory usage: ~${(info.loadedNotes * 0.5).toFixed(1)} KB</p>
                        
                        <p><strong>Archives:</strong></p>
                        <p>  • Number of archives: ${info.archives}</p>
                        <p>  • Total archived notes: ${info.totalArchived}</p>
                        
                        <p><strong>Storage:</strong></p>
                        <p>  • LocalStorage: ${info.localStorage} KB</p>
                        <p>  • IndexedDB: ${useIndexedDB ? 'Active' : 'Not available'}</p>
                        
                        <p><strong>Performance:</strong></p>
                        <p>  • Load time: ${getLastLoadTime()}</p>
                        <p>  • Memory status: ${getMemoryStatus(info.loadedNotes)}</p>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <button class="btn btn-small" onclick="exportStorageReport()" style="background: var(--primary-color); margin-right: 10px;">
    Export Report
</button>
<button class="btn btn-small" onclick="optimizeStorage()" style="background: var(--success-color);">
    Optimize Storage
</button>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
    } catch (error) {
        showToast('Error getting storage info: ' + error.message, 'error');
    }
}

// App info modal function
async function showAppInfo() {
    const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
    
    const modalHtml = `
        <div class="modal" onclick="closeAppInfo(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeAppInfo()">Close</button>
                <h3>${isNeonGreen ? 'Nostr Notes Archive' : '📝 Nostr Notes Archive'}</h3>
                
                <div style="line-height: 1.6; margin-bottom: 24px;">
                    <p><strong>What is this app?</strong></p>
                    <p>This is a browser-based tool for viewing, organizing, and archiving your notes. It connects directly to Nostr relays to fetch your posts and allows you to organize them into custom archives for better management.</p>
                </div>

                <div style="line-height: 1.6; margin-bottom: 24px;">
                    <p><strong>Key Features:</strong></p>
                    <ul style="margin-left: 20px; margin-top: 8px;">
                        <li>View all your original notes and replies</li>
                        <li>Create custom archives to organize notes</li>
                        <li>Search by content, hashtags, and date ranges</li>
                        <li>Filter by images, videos, and note length</li>
                        <li>Export notes as JSON or Markdown</li>
                        <li>Fast IndexedDB caching for better performance</li>
                        <li>Multiple theme options including Neon Green</li>
                        <li>Keyboard shortcuts for power users</li>
                    </ul>
                </div>

                <div style="line-height: 1.6; margin-bottom: 24px;">
                    <p><strong>Privacy & Security:</strong></p>
                    <p>Your data stays in your browser. The app only connects to public Nostr relays to read your posts. No data is sent to external servers except for the relay connections needed to fetch your notes.</p>
                </div>

                <div style="background: var(--background-color); padding: 16px; border-radius: 8px; border-left: 4px solid var(--primary-color); margin-bottom: 24px;">
                    <p><strong>Created by Romeo</strong></p>
                    <p style="font-family: monospace; font-size: 13px; word-break: break-all; margin-top: 8px;">
                        <strong>Npub:</strong> npub12p5753xcjal8034w5czap3fcdvj9qj36h5873g73ea05emw2gznszr0ann
                    </p>
                    <button onclick="copyToClipboard('npub12p5753xcjal8034w5czap3fcdvj9qj36h5873g73ea05emw2gznszr0ann')" 
                            class="copy-btn" style="margin-top: 8px;">
                        Copy NPUB
                    </button>
                </div>

                <div style="text-align: center; font-size: 13px; color: var(--text-muted);">
                    <p>Built with ❤️ for the Nostr community</p>
                    <p style="margin-top: 8px;">Version 1.0 • Open Source • No Tracking</p>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeAppInfo(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

// 2. Helper functions for storage info
function getLastLoadTime() {
    const lastLoad = localStorage.getItem('nostr-last-load-time');
    if (lastLoad) {
        const seconds = (Date.now() - parseInt(lastLoad)) / 1000;
        return seconds < 60 ? `${seconds.toFixed(1)}s ago` : `${(seconds/60).toFixed(1)}m ago`;
    }
    return 'Unknown';
}

function getMemoryStatus(noteCount) {
    if (noteCount < 25000) return 'Excellent';
    if (noteCount < 75000) return 'Good'; 
    if (noteCount < 150000) return 'Fair';
    return 'High';
}

function closeStorageInfo(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

// 3. ADD storage optimization function
async function optimizeStorage() {
    try {
        let optimized = [];
        let freedSpace = 0;
        
        // Clear old localStorage entries from other users
        const keysToCheck = Object.keys(localStorage);
        keysToCheck.forEach(key => {
            if (key.startsWith('nostr-cached-notes-') && key !== `nostr-cached-notes-${currentPubkey}`) {
                const size = localStorage[key]?.length || 0;
                localStorage.removeItem(key);
                freedSpace += size;
                optimized.push('Removed old user cache');
            }
            if (key.startsWith('nostr-last-pubkey-') && key !== `nostr-last-pubkey-${currentPubkey}`) {
                localStorage.removeItem(key);
                optimized.push('Cleaned old pubkey data');
            }
        });
        
        // Clean up empty archives (this is actually useful)
        let emptyArchives = 0;
        Object.keys(namedArchives).forEach(archiveName => {
            if (namedArchives[archiveName].size === 0) {
                delete namedArchives[archiveName];
                emptyArchives++;
            }
        });
        if (emptyArchives > 0) {
            optimized.push(`Removed ${emptyArchives} empty archives`);
        }
        
        // Clear IndexedDB cache to force fresh relay fetch on next load
        if (db && useIndexedDB) {
            await db.settings.delete('last_sync_time');
            optimized.push('Reset sync cache (will fetch fresh data next time)');
        }
        
        if (optimized.length > 0) {
            if (emptyArchives > 0) saveArchivedNotes();
            const spaceSaved = freedSpace > 0 ? ` (freed ${(freedSpace/1024).toFixed(1)} KB)` : '';
            showToast(`Optimized: ${optimized.join(', ')}${spaceSaved}`, 'success');
        } else {
            showToast('Nothing to optimize - storage is clean!', 'success');
        }
        
        closeStorageInfo();
        
    } catch (error) {
        showToast('Error optimizing storage: ' + error.message, 'error');
    }
}

function exportStorageReport() {
    const report = {
        generated_at: new Date().toISOString(),
        user_pubkey: currentPubkey ? currentPubkey.substring(0, 16) + '...' : 'none',
        stats: {
            total_notes_stored: allNotes.length,
            notes_currently_loaded: allNotes.length,
            archives_count: Object.keys(namedArchives).length,
            total_archived_notes: Object.values(namedArchives).reduce((sum, archive) => sum + archive.size, 0),
            hashtags_found: new Set(allNotes.flatMap(note => note.hashtags || [])).size,
            replies_count: allNotes.filter(note => note.isReply).length,
            original_notes_count: allNotes.filter(note => !note.isReply).length
        },
        performance: {
            indexeddb_active: useIndexedDB,
            memory_status: getMemoryStatus(allNotes.length),
            relays_configured: RELAYS.length,
            last_load_time: getLastLoadTime()
        },
        archives: Object.keys(namedArchives).map(name => ({
            name: name,
            note_count: namedArchives[name].size
        }))
    };
    
    downloadFile(
        JSON.stringify(report, null, 2),
        `nostr-storage-report-${new Date().toISOString().split('T')[0]}.json`,
        'application/json'
    );
    
    showToast('Storage report exported!', 'success');
}

// 5. ADD function to track load times
function trackLoadTime() {
    localStorage.setItem('nostr-last-load-time', Date.now().toString());
}

        function extractHashtags(content) {
            const matches = content.match(/#\w+/g);
            return matches ? matches.map(tag => tag.toLowerCase()) : [];
        }

        function updateTagFilters() {
            const tagCounts = {};
            
          // Process hashtags - removed performance-killing logs
allNotes.forEach(note => {
    if (note.hashtags && Array.isArray(note.hashtags)) {
        note.hashtags.forEach(tag => {
            tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        });
    }
});
            
            const archivedCount = allNotes.filter(note => archivedNotes.has(note.id)).length;
            const originalNotesCount = allNotes.filter(note => !note.isReply).length;
            const repliesCount = allNotes.filter(note => note.isReply).length;
            
            const container = document.getElementById('tag-filters');
            if (!container) {
                console.error('tag-filters container not found!');
                return;
            }
            
            container.innerHTML = `
  <button class="tag-filter active" data-tag="">All Notes (${allNotes.length})</button>
  <button class="tag-filter" data-tag="__original"><span class="emoji">📝</span> Original Notes (${originalNotesCount})</button>
  <button class="tag-filter" data-tag="__replies"><span class="emoji">💬</span> Replies (${repliesCount})</button>
`;
            

// Group hashtags alphabetically
const hashtagGroups = {};
Object.keys(tagCounts).sort((a, b) => a.localeCompare(b)).forEach(tag => {
    const firstLetter = tag.charAt(1).toUpperCase(); // Skip the # symbol
    if (!hashtagGroups[firstLetter]) {
        hashtagGroups[firstLetter] = [];
    }
    hashtagGroups[firstLetter].push(tag);
});

// Add grouped hashtags with collapsible sections
Object.keys(hashtagGroups).sort().forEach(letter => {
    const groupCount = hashtagGroups[letter].length;
    
    // Add clickable letter header
    const letterHeader = document.createElement('button');
    letterHeader.className = 'hashtag-group-header';
    letterHeader.style.cssText = `
        width: 100%;
        text-align: left;
        background: var(--background-color);
        border: 1px solid var(--border-color);
        padding: 8px 12px;
        margin: 8px 0 0 0;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        color: var(--text-color);
        font-size: 13px;
        transition: background-color 0.2s ease;
    `;
    letterHeader.textContent = `${letter} (${groupCount} hashtags)`;
    letterHeader.onclick = () => toggleHashtagGroup(letter);
    container.appendChild(letterHeader);
    
    // Add container for hashtags (initially hidden)
const hashtagContainer = document.createElement('div');
hashtagContainer.id = `hashtag-group-${letter}`;
hashtagContainer.style.cssText = `
    display: none;
    margin: 0 0 8px 0;
    padding: 4px 0;
    border-left: 2px solid var(--border-color);
    padding-left: 8px;
`;
    
    hashtagGroups[letter].forEach(tag => {
    const button = document.createElement('button');
    button.className = 'tag-filter';
    button.dataset.tag = tag;
    button.textContent = `${tag} (${tagCounts[tag]})`;
    button.addEventListener('click', () => toggleTag(tag));
    hashtagContainer.appendChild(button);
});
    
    container.appendChild(hashtagContainer);
    
});
            
            // Add click handlers
            const allNotesBtn = container.querySelector('[data-tag=""]');
            const originalBtn = container.querySelector('[data-tag="__original"]');
            const repliesBtn = container.querySelector('[data-tag="__replies"]');
            
           if (allNotesBtn) allNotesBtn.addEventListener('click', () => toggleTag(''));
if (originalBtn) originalBtn.addEventListener('click', () => toggleTag('__original'));
if (repliesBtn)  repliesBtn.addEventListener('click', () => toggleTag('__replies'));

            setActiveTagButtons();
        
            // --- one-time drag-select listeners for tag filters ---
(function initTagDragOnce() {
  const tagFiltersEl = document.getElementById('tag-filters');
  if (!tagFiltersEl || tagFiltersEl.__dragInit) return;

  // Start drag only with LEFT button and only on real hashtags (e.g., "#coffee")
  tagFiltersEl.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return;                         // left click only
    const btn = e.target.closest('.tag-filter');
    if (!btn) return;
    const tag = btn.dataset.tag;
    if (!tag || !tag.startsWith('#')) return;           // ignore All/Original/Replies
    startHashtagSelection(tag, e);                      // decides add/remove mode
  });

  // Continue while holding the button, over real hashtags only
  tagFiltersEl.addEventListener('mouseover', (e) => {
    if (!isSelecting) return;                           // set by startHashtagSelection
    const btn = e.target.closest('.tag-filter');
    if (!btn) return;
    const tag = btn.dataset.tag;
    if (!tag || !tag.startsWith('#')) return;
    continueHashtagSelection(tag, e);
  });

  // End drag anywhere
  document.addEventListener('mouseup', endHashtagSelection);

  tagFiltersEl.__dragInit = true;                       // guard against rebinding
})();
        }
        

        function filterByTag(tag) {
            currentTag = tag;

            document.getElementById('date-from').value = '';
            document.getElementById('date-to').value = '';
            
            // Update active button
            document.querySelectorAll('.tag-filter').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tag === tag) {
                    btn.classList.add('active');
                }
            });
            
            applyFilters();
            renderNotes();
            setActiveTagButtons();
        }

        function toggleHashtagGroup(letter) {
    const container = document.getElementById(`hashtag-group-${letter}`);
    
    if (container.style.display === 'none') {
        container.style.display = 'block';
    } else {
        container.style.display = 'none';
    }
}

function setActiveTagButtons() {
  const buttons = document.querySelectorAll('#tag-filters .tag-filter');
  buttons.forEach(btn => {
    const t = btn.dataset.tag || '';
    
    // Clear existing active state
    btn.classList.remove('active');
    
    // "All Notes" is active only when nothing is selected AND we're not in archive view
    if (t === '' && selectedTags.size === 0 && !currentTag.startsWith('__archive_') && activeQuickFilters.size === 0) {
      btn.classList.add('active');
    } 
    // Hashtag buttons are active when they're in selectedTags
    else if (t !== '' && selectedTags.has(t)) {
      btn.classList.add('active');
    }
    // Special buttons - fix these lines
    else if (t === '__original' && selectedTags.has('__original')) {
      btn.classList.add('active');
    }
    else if (t === '__replies' && selectedTags.has('__replies')) {
      btn.classList.add('active');
    }
  });
}

function applyDateFilters() {
    // Clear archive selection when manually setting dates
    const dateFrom = document.getElementById('date-from').value;
    const dateTo = document.getElementById('date-to').value;
    
    if (dateFrom || dateTo) {
        currentArchive = 'default';
        currentTag = '';
        selectedTags.clear();
        
        // Clear archive active states
        document.querySelectorAll('.archive-item').forEach(item => {
            item.classList.remove('active');
        });
        
        // Clear tag filter active states
        document.querySelectorAll('.tag-filter').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Set "All Notes" as active
        document.querySelector('.tag-filter[data-tag=""]').classList.add('active');
    }
    
    applyAllFilters();
}


// Make it globally available
window.toggleHashtagGroup = toggleHashtagGroup;
        // === Multi-tag selection helpers ===
function toggleTag(tag) {
    // Clear archive active states when selecting any tag (but NOT quick filters)
    currentArchive = 'default';
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Clear date filters when selecting any tag (but NOT quick filters)
    document.getElementById('date-from').value = '';
    document.getElementById('date-to').value = '';
    
    if (!tag) {
        // "All Notes" clears ALL selections including quick filters
        selectedTags.clear();
        currentTag = '';
        activeQuickFilters.clear(); // Clear quick filters only for "All Notes"
        
        // Clear quick filter buttons
        document.querySelectorAll('.quick-filter-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Set "All Notes" as active
        document.querySelectorAll('.tag-filter').forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.tag === '') {
                btn.classList.add('active');
            }
        });
        
        // Use simple filtering for "All Notes"
        window.inAdvancedSearchMode = false;
        filteredNotes = allNotes.slice();
        resetPagination();
        renderNotes();
        return;
    } 
    
    // For hashtag selection, work WITH quick filters, not against them
    if (selectedTags.has(tag)) {
        selectedTags.delete(tag);
        
        // If no tags selected after removal, check if we have quick filters
        if (selectedTags.size === 0 && activeQuickFilters.size > 0) {
            // We still have quick filters active, so use advanced search
            applyAllFilters();
        } else if (selectedTags.size === 0 && activeQuickFilters.size === 0) {
            // Nothing active, go to "All Notes"
            currentTag = '';
            document.querySelectorAll('.tag-filter').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tag === '') {
                    btn.classList.add('active');
                }
            });
            window.inAdvancedSearchMode = false;
            filteredNotes = allNotes.slice();
            resetPagination();
            renderNotes();
        } else {
            // Other tags still selected, continue with advanced search
            applyAllFilters();
        }
    } else {
        selectedTags.add(tag);
        
        // Check if both original and replies are selected
        const hasOriginal = selectedTags.has('__original');
        const hasReplies = selectedTags.has('__replies');
        
        if (hasOriginal && hasReplies && selectedTags.size === 2) {
            // If both are selected, clear them but keep quick filters
            selectedTags.clear();
            currentTag = '';
            
            if (activeQuickFilters.size > 0) {
                // Quick filters are active, use advanced search
                applyAllFilters();
            } else {
                // No filters active, go to "All Notes"
                document.querySelectorAll('.tag-filter').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.dataset.tag === '') {
                        btn.classList.add('active');
                    }
                });
                window.inAdvancedSearchMode = false;
                filteredNotes = allNotes.slice();
                resetPagination();
                renderNotes();
            }
        } else {
            // Normal tag selection - use advanced search to combine with quick filters
            applyAllFilters();
        }
    }
    
    setActiveTagButtons();
}

// Check if a single tag matches a note
function noteMatchesTag(note, tag) {
  if (tag === '__original') return !note.isReply;
  if (tag === '__replies') return note.isReply;
  if (tag === '__archived') return archivedNotes.has(note.id);
  if (tag.startsWith('__archive_')) {
    const name = tag.replace('__archive_', '');
    return namedArchives[name] && namedArchives[name].has(note.id);
  }
  // regular hashtag
  return note.hashtags && note.hashtags.includes(tag);
}

        function handleSearch() {
    searchQuery = document.getElementById('search-input').value.toLowerCase();
    
    // If there are active quick filters, use the advanced search system
    if (activeQuickFilters.size > 0) {
        applyAllFilters();
    } else {
        // Use the simple filter system
        applyFilters();
        renderNotes();
    }
}

      function applyFilters() {
    // If we have active quick filters, delegate to the advanced search system
    if (activeQuickFilters.size > 0) {
        applyAllFilters();
        return;
    }
    
    // Original applyFilters logic continues here...
    filteredNotes = allNotes.slice();

    // If multiple tags are selected, keep notes that match ANY selected tag
    if (selectedTags.size > 0) {
        const tags = Array.from(selectedTags);
        filteredNotes = filteredNotes.filter(note =>
            tags.some(tag => noteMatchesTag(note, tag))
        );
    } else {
        // Fall back to old single-select behavior (currentTag)
        if (currentTag === '__archived') {
            filteredNotes = filteredNotes.filter(note => archivedNotes.has(note.id));
        } else if (currentTag === '__original') {
            filteredNotes = filteredNotes.filter(note => !note.isReply);
        } else if (currentTag === '__replies') {
            filteredNotes = filteredNotes.filter(note => note.isReply);
        } else if (currentTag && currentTag.startsWith('__archive_')) {
            const archiveName = currentTag.replace('__archive_', '');
            if (namedArchives[archiveName]) {
                filteredNotes = filteredNotes.filter(note => namedArchives[archiveName].has(note.id));
            }
        } else if (currentTag) {
            filteredNotes = filteredNotes.filter(note => note.hashtags.includes(currentTag));
        }
    }

    // Text search still applies
    if (searchQuery) {
        const q = searchQuery.toLowerCase();
        filteredNotes = filteredNotes.filter(note =>
            note.content.toLowerCase().includes(q) ||
            (note.hashtags && note.hashtags.some(tag => tag.includes(q)))
        );
    }

    // Reset pagination when filters change
    resetPagination();
}



        function renderNotes() {
    const container = document.getElementById('notes-container');
    const emptyState = document.getElementById('empty-state');
    const loadMoreContainer = document.getElementById('load-more-container');
    const paginationInfo = document.getElementById('pagination-info');
    const title = document.getElementById('notes-title');
    const count = document.getElementById('notes-count');
    
    if (!container) {
        console.error('notes-container not found!');
        return;
    }
    
    // Calculate how many notes to show
    const totalToShow = Math.min(currentPage * notesPerPage, filteredNotes.length);
    const notesToRender = filteredNotes.slice(0, totalToShow);
            
    // Update title and count
if (selectedTags.size > 0) {
    // Check if both original and replies are selected - that's equivalent to "All Notes"
    const hasOriginal = selectedTags.has('__original');
    const hasReplies = selectedTags.has('__replies');
    
    if (hasOriginal && hasReplies && selectedTags.size === 2) {
        // If only original and replies are selected, show "All Notes"
        title.textContent = 'All Notes';
    } else {
        // Multi-tag selection takes priority
        const tagNames = Array.from(selectedTags).map(tag => {
            if (tag === '__original') return 'Original Notes';
            if (tag === '__replies') return 'Replies';
            if (tag === '__archived') return 'Archived';
            return tag;
        });
        title.textContent = tagNames.join(' + ');
    }
} else if (currentTag === '__archived') {
    title.textContent = 'All Archived Notes';
} else if (currentTag === '__original') {
    title.textContent = 'Original Notes';
} else if (currentTag === '__replies') {
    title.textContent = 'Replies';
} else if (currentTag.startsWith('__archive_')) {
    const archiveName = currentTag.replace('__archive_', '');
   // Check if neon-green theme is active
const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';
title.textContent = isNeonGreen ? `Archive: ${archiveName}` : `📂 Archive: ${archiveName}`;
    title.style.color = 'var(--text-muted)';
} else if (currentTag) {
    title.textContent = `Notes tagged ${currentTag}`;
    title.style.color = '';     // Reset color
    title.style.fontWeight = ''; // Reset weight
} else {
    title.textContent = 'All Notes';
    title.style.color = '';     // Reset color
    title.style.fontWeight = ''; // Reset weight
}
            count.textContent = `${filteredNotes.length} notes`;

if (filteredNotes.length === 0) {
    container.innerHTML = '';
    loadMoreContainer.classList.add('hidden');
    if (emptyState) emptyState.classList.remove('hidden');
    updateSelectionUI();
    return;
}

// Update export button text to show what will be exported
const exportJsonBtn = document.getElementById('export-json');
const exportMdBtn = document.getElementById('export-md');
// Define isNeonGreen here so it can be used below
const isNeonGreen = document.body.getAttribute('data-theme') === 'neon-green';

if (currentTag.startsWith('__archive_')) {
  const archiveName = currentTag.replace('__archive_', '');
  if (exportJsonBtn) exportJsonBtn.textContent = `Export "${archiveName}" JSON`;
  if (exportMdBtn)   exportMdBtn.textContent   = `Export "${archiveName}" Markdown`;
} else {
  if (exportJsonBtn) exportJsonBtn.textContent = 'Export JSON';
  if (exportMdBtn)   exportMdBtn.textContent   = 'Export Markdown';
}

if (emptyState) emptyState.classList.add('hidden');

// Only show load more button if we're not currently loading AND there are more notes to show
// Show load more button logic
const hasMoreNotes = totalToShow < filteredNotes.length;

if (hasMoreNotes && filteredNotes.length > 0) {
    loadMoreContainer.classList.remove('hidden');
    paginationInfo.textContent = `Showing ${totalToShow} of ${filteredNotes.length} notes`;
} else {
    loadMoreContainer.classList.add('hidden');
    if (filteredNotes.length > 0) {
        paginationInfo.textContent = `Showing all ${filteredNotes.length} notes`;
    }
}
            
            
            // Render notes in chunks to prevent blocking
            const renderInChunks = async () => {
                const chunkSize = 50; // Smaller chunks for rendering
                let html = '';
                
               for (let i = 0; i < notesToRender.length; i += chunkSize) {
                  const chunk = notesToRender.slice(i, i + chunkSize);
                    
                    chunk.forEach(note => {
    const date = new Date(note.created_at * 1000).toLocaleString();
    const isArchived = archivedNotes.has(note.id);
    const isReply = note.isReply;
    const isSelected = selectedNotes.has(note.id);
    
    const hashtagsHtml = note.hashtags && note.hashtags.length > 0 ? 
note.hashtags.map(tag => {
    const isSelected = selectedTags.has(tag);
    return `<span class="hashtag" 
           onmousedown="startHashtagSelection('${tag}', event)" 
           onmouseenter="continueHashtagSelection('${tag}', event)"
           ontouchstart="startHashtagSelection('${tag}', event)"
           data-tag="${tag}"
           ${isSelected ? 'data-selected="true"' : ''}>${tag}</span>`;
}).join(' ') : '';
    
    // Different styling for replies
    const cardClass = `note-card ${isArchived ? 'archived' : ''} ${isReply ? 'reply-card' : ''}`;
    const replyIndicator = isReply ? '<span class="emoji">💬</span> ' : '<span class="emoji">📄</span> ';
    
    // IMPROVED: Check if we're in a specific archive view
    const isInSpecificArchive = currentTag.startsWith('__archive_');
    const currentArchiveName = isInSpecificArchive ? currentTag.replace('__archive_', '') : '';
    const isNoteInCurrentArchive = isInSpecificArchive && namedArchives[currentArchiveName] && namedArchives[currentArchiveName].has(note.id);
    
    // Create the appropriate archive button
    let archiveButtonHtml = '';
    if (isInSpecificArchive && isNoteInCurrentArchive) {
        // We're viewing a specific archive and this note is in it - show "Remove from [archive]"
        archiveButtonHtml = `
            <button class="btn btn-small" style="background: #e74c3c; color: white;" 
                    onclick="removeFromSpecificArchive('${note.id}', '${currentArchiveName}')">
                <span class="emoji">🗑️</span> Remove
            </button>`;
    } else {
        // Normal archive/unarchive button
        archiveButtonHtml = `
            <button class="btn btn-small btn-archive ${isArchived ? 'archived' : ''}" 
                    onclick="toggleArchiveNote('${note.id}')">
                ${isArchived ? '✓ Archived' : '<span class="emoji">📂</span> Archive'}
            </button>`;
    }
    
    html += `
        <div class="${cardClass}">
            <div class="note-header">
                <div style="display: flex; align-items: center;">
                    <input type="checkbox" class="note-checkbox" ${isSelected ? 'checked' : ''} 
                           onchange="toggleNoteSelection('${note.id}')">
                    <span>${replyIndicator}${date}</span>
                </div>
                <div class="note-actions">
                    ${archiveButtonHtml}
                    <button class="btn btn-small" style="background: #95a5a6;" 
                            onclick="showNoteInfo('${note.id}')">
                        <span class="emoji">ℹ️</span> Info
                    </button>
                </div>
            </div>
            <div class="note-content">${processYouTubeLinks(processImageLinks(escapeHtml(note.content)))}</div>
            ${hashtagsHtml ? `<div class="hashtags">${hashtagsHtml}</div>` : ''}
        </div>
    `;
});

                    
                    // Update progress and yield control
                    if (i % 100 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                container.innerHTML = html;
                setupLazyLoading();
                updateSelectionUI();
                setupHashtagDragSelection();
                
            };
            
            renderInChunks();
        }


        function refreshNotes() {
    if (!currentPubkey) {
        showToast('No user connected - cannot refresh', 'error');
        return;
    }
    
    // Use incremental sync instead of full reload
    loadNotesIncremental(true); // true = is refresh
}

async function loadNotesIncremental(isRefresh = false) {
    const previousNotesCount = allNotes.length;
    
    try {
        if (!isRefresh) {
            showLoading(true);
            updateStatus('Loading notes...', true);
        }
        
        const notes = await incrementalSync(currentPubkey, false);
        
        allNotes = notes.sort((a, b) => b.created_at - a.created_at);
        
        updateArchiveList();
        updateTargetArchiveDropdown();
        updateTagFilters();
        applyFilters();
        renderNotes();
        
        const newNotesCount = allNotes.length - previousNotesCount;
        
        if (isRefresh) {
            if (newNotesCount > 0) {
                showToast(`Found ${newNotesCount} new notes!`, 'success');
            } else {
                showToast('No new notes found', 'success');
            }
        }
        
        updateStatus(`✅ Loaded ${allNotes.length} notes (${newNotesCount} new)`);
        
    } catch (error) {
        showError('Refresh failed: ' + error.message);
    } finally {
        if (!isRefresh) {
            showLoading(false);
        }
    }
}

        function exportAsJSON() {
            const dataToExport = filteredNotes;
            
            let filterType;
let displayName; // Add this to show user-friendly names

if (currentTag.startsWith('__archive_')) {
    const archiveName = currentTag.replace('__archive_', '');
    filterType = archiveName;
    displayName = `Archive: ${archiveName}`;
} else if (currentTag === '__original') {
    filterType = 'original-notes';
    displayName = 'Original Notes';
} else if (currentTag === '__replies') {
    filterType = 'replies';
    displayName = 'Replies';
} else if (currentTag) {
    filterType = currentTag;
    displayName = `Tag: ${currentTag}`;
} else {
    filterType = 'all-notes';
    displayName = 'All Notes';
}
            
            const data = {
                exported_at: new Date().toISOString(),
                filter_type: filterType,
                total_notes: dataToExport.length,
                notes: dataToExport.map(note => ({
                    id: note.id,
                    date: new Date(note.created_at * 1000).toISOString(),
                    content: note.content,
                    hashtags: note.hashtags,
                  archived: Object.values(namedArchives).some(archive => archive.has(note.id)),
                    isReply: note.isReply
                }))
            };
            
            downloadFile(
                JSON.stringify(data, null, 2),
                `nostr-notes-${filterType}-${new Date().toISOString().split('T')[0]}.json`,
                'application/json'
            );
        }

        function exportAsMarkdown() {
            const dataToExport = filteredNotes;
            
            const filterType = currentTag.startsWith('__archive_') 
                ? currentTag.replace('__archive_', '') 
                : currentTag === '__archived' ? 'My Archive' 
                : currentTag || 'All Notes';
            
            let markdown = `# My Nostr Notes\n\n`;
            markdown += `Exported: ${new Date().toISOString()}\n`;
            markdown += `Filter: ${filterType}\n`;
            markdown += `Total Notes: ${dataToExport.length}\n\n---\n\n`;
            
            dataToExport.forEach(note => {
                const date = new Date(note.created_at * 1000).toLocaleString();
                const isArchived = archivedNotes.has(note.id);
                const isReply = note.isReply;
                const noteType = isReply ? '💬' : '📝';
                markdown += `## ${noteType} ${date}${isArchived ? ' 🗂️' : ''}\n\n`;
                markdown += `${note.content}\n\n`;
                if (note.hashtags.length > 0) {
                    markdown += `**Tags:** ${note.hashtags.join(', ')}\n\n`;
                }
                markdown += `---\n\n`;
            });
            
            downloadFile(
                markdown,
                `nostr-notes-${filterType.replace(/[^a-z0-9]/gi, '-').toLowerCase()}-${new Date().toISOString().split('T')[0]}.md`,
                'text/markdown'
            );
        }

        function showNoteInfo(noteId) {
    const note = allNotes.find(n => n.id === noteId);
    if (!note) return;
    
    const date = new Date(note.created_at * 1000);
    const archiveStatus = Object.keys(namedArchives).filter(name => 
        namedArchives[name].has(noteId)
    );
    const nevent = createNevent(note);
    
    const modalHtml = `
        <div class="modal" onclick="closeModal(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <button class="modal-close" onclick="closeModal()">Close</button>
                <h3>Note Information</h3> 
                <p><strong>Nevent:</strong> <button onclick="copyToClipboard('${nevent}')" class="copy-btn">Copy</button><br><small style="word-break: break-all;">${nevent}</small></p>
                <p><strong>ID:</strong><br><small style="word-break: break-all;">${note.id}</small></p>
                <p><strong>Author:</strong><br><small style="word-break: break-all;">${note.pubkey}</small></p>
                <p><strong>Created:</strong> ${date.toLocaleString()}</p>
                <p><strong>Type:</strong> ${note.isReply ? 'Reply' : 'Original Note'}</p>
                <p><strong>Content Length:</strong> ${note.content.length} characters</p>
                <p><strong>Hashtags:</strong> ${note.hashtags.length > 0 ? note.hashtags.join(', ') : 'None'}</p>
                <p><strong>Archives:</strong> ${archiveStatus.length > 0 ? archiveStatus.join(', ') : 'Not archived'}</p>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeModal(event) {
    if (!event || event.target.classList.contains('modal') || event.target.classList.contains('modal-close')) {
        document.querySelector('.modal')?.remove();
    }
}

        function createNevent(note) {
    try {
        if (!window.NostrTools || !window.NostrTools.nip19) {
            return 'NostrTools not available';
        }
        
        // Create nevent data
        const neventData = {
            id: note.id,
            relays: RELAYS.slice(0, 2), // Include first 2 relays
            author: note.pubkey
        };
        
        return window.NostrTools.nip19.neventEncode(neventData);
    } catch (error) {
        console.error('Error creating nevent:', error);
        return 'Error creating nevent';
    }
}

// REPLACE your existing clearAllCache function (around line 2600) with this enhanced version:

async function clearAllCache() {
    if (confirm('This will clear ALL data including cached notes, archives, and IndexedDB. This action cannot be undone. Continue?')) {
        try {
            // Enhanced IndexedDB clearing - clear everything first
            await clearIndexedDBCompletely();
            
            // Only clear data for the current user, not all users
            if (currentPubkey) {
                // Clear cache data for current user
                localStorage.removeItem(`nostr-last-pubkey-${currentPubkey}`);
                localStorage.removeItem(`nostr-cached-notes-${currentPubkey}`);
                localStorage.removeItem(`nostr-cache-updated-at-${currentPubkey}`);
                
                // Clear archives for current user
                localStorage.removeItem(`nostr-archived-notes-${currentPubkey}`);
                localStorage.removeItem(`nostr-named-archives-${currentPubkey}`);
            }
            
            // Clear global settings (theme, etc.) but NOT other users' data
            localStorage.removeItem('nostr-saved-npub');
            localStorage.removeItem('archives-cleanup-done');
            
            // Reset all global variables
            currentPubkey = null;
            allNotes = [];
            filteredNotes = [];
            archivedNotes = new Set();
            namedArchives = {};
            currentTag = '';
            searchQuery = '';
            currentArchive = 'default';
            selectedNotes = new Set();
            selectedTags = new Set();
            
            // Reset memory management variables (if you've added them)
            if (typeof totalNotesCount !== 'undefined') {
                totalNotesCount = 0;
                loadedNotesCount = 0;
                currentChunk = 0;
                hasMoreNotes = true;
                isLoadingChunk = false;
            }
            
            // Clear quick filters
            activeQuickFilters.clear();
            document.querySelectorAll('.quick-filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Clear date filters
            document.getElementById('date-from').value = '';
            document.getElementById('date-to').value = '';
            
            // Clear search
            document.getElementById('search-input').value = '';
            
            // Clear the UI immediately
            document.getElementById('notes-container').innerHTML = '';
            document.getElementById('tag-filters').innerHTML = '<button class="tag-filter active" data-tag="">All Notes (0)</button>';
            document.getElementById('notes-count').textContent = '0 notes';
            document.getElementById('notes-title').textContent = 'All Notes';
            document.getElementById('archive-list').innerHTML = '<div style="color: #666; font-style: italic; font-size: 13px;">No archives created yet</div>';
            
            // Hide bulk controls and other UI elements
            document.getElementById('bulk-controls').classList.add('hidden');
            document.getElementById('load-more-container').classList.add('hidden');
            document.getElementById('empty-state').classList.add('hidden');
            
            // Reset database connection completely
            db = null;
            useIndexedDB = true; // Reset this flag
            
            // Go back to connection screen
            document.getElementById('main-app').classList.add('hidden');
            document.getElementById('connection-screen').classList.remove('hidden');
            document.getElementById('pubkey-input').value = '';
            
            showToast('All data cleared successfully! Please reconnect.', 'success');
            
        } catch (error) {
            console.error('Error clearing data:', error);
            showToast('Error clearing some data: ' + error.message, 'error');
        }
    }
}

// ADD this new function to handle IndexedDB clearing:
async function clearIndexedDBCompletely() {
    try {
        // Close current database connection if open
        if (db && db.isOpen()) {
            // Clear all data before closing
            try {
                await db.notes.clear();
                await db.settings.clear();
            } catch (error) {
                console.log('Error clearing tables before close:', error);
            }
            await db.close();
        }
        
        // Clear the specific database for current user
        if (currentPubkey) {
            const dbName = `nostr-notes-${currentPubkey}`;
            
            // Delete the database entirely
            if (window.indexedDB && window.indexedDB.deleteDatabase) {
                await new Promise((resolve, reject) => {
                    const deleteReq = window.indexedDB.deleteDatabase(dbName);
                    
                    deleteReq.onsuccess = () => {
                        console.log(`IndexedDB ${dbName} deleted successfully`);
                        resolve();
                    };
                    
                    deleteReq.onerror = (event) => {
                        console.error(`Error deleting IndexedDB ${dbName}:`, event.target.error);
                        resolve(); // Don't reject - continue with cleanup
                    };
                    
                    deleteReq.onblocked = () => {
                        console.warn(`IndexedDB ${dbName} deletion blocked`);
                        // Force resolve after delay
                        setTimeout(resolve, 2000);
                    };
                    
                    // Timeout safety
                    setTimeout(() => {
                        console.warn('IndexedDB deletion timeout');
                        resolve();
                    }, 5000);
                });
            }
        }
        
        // Reset database variables completely
        db = null;
        useIndexedDB = true; // Reset this flag so it will try IndexedDB again
        
        console.log('IndexedDB cleared completely');
        
    } catch (error) {
        console.error('Error clearing IndexedDB completely:', error);
        // Reset variables anyway
        db = null;
        useIndexedDB = true;
    }
}

// OPTIONAL: Add a separate "Clear IndexedDB Only" function for debugging
async function clearIndexedDBOnly() {
    if (confirm('Clear IndexedDB cache only? (Archives and settings will be preserved)')) {
        try {
            await clearIndexedDB();
            showToast('IndexedDB cleared. Notes will be refetched from relays on next load.', 'success');
        } catch (error) {
            showToast('Error clearing IndexedDB: ' + error.message, 'error');
        }
    }
}

                function loadMoreNotes() {
            currentPage++;
            renderNotes();
        }

        function resetPagination() {
    currentPage = 1;
}

        function updateProgress(percent, text) {
            const progressFill = document.getElementById('progress-fill');
            const loadingText = document.getElementById('loading-text');
            
            if (progressFill) {
                progressFill.style.width = `${percent}%`;
                progressFill.textContent = `${Math.round(percent)}%`;
            }
            if (loadingText && text) {
                loadingText.textContent = text;
            }
        }

       function updateStatus(text, clearPrevious = false) {
    const statusInfo = document.getElementById('status-info');
    if (statusInfo) {
        if (clearPrevious) {
            statusInfo.innerHTML = text + '<br>';
        } else {
            statusInfo.innerHTML += text + '<br>';
        }
    }
}

// Toast notification system
// Add these variables at the top of your script
let activeToasts = new Set();
let toastTimeout = null;

// Replace your existing showToast function with this:
function showToast(message, type = 'success', duration = 3000) {
    // Prevent duplicate toasts
    if (activeToasts.has(message)) {
        return;
    }
    
    // Clear any pending toast timeout
    if (toastTimeout) {
        clearTimeout(toastTimeout);
    }
    
    // Add to active toasts
    activeToasts.add(message);
    
    // Remove existing toasts of the same type
    document.querySelectorAll(`.toast.${type}`).forEach(existingToast => {
        existingToast.remove();
    });
    
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    
    document.body.appendChild(toast);
    
    // Trigger animation
    setTimeout(() => toast.classList.add('show'), 10);
    
    // Remove after duration
    toastTimeout = setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            if (document.body.contains(toast)) {
                document.body.removeChild(toast);
            }
            activeToasts.delete(message);
        }, 300);
    }, duration);
}

        // Utility functions
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showLoading(show) {
            document.getElementById('loading').classList.toggle('hidden', !show);
        }

        function showError(message) {
            const errorEl = document.getElementById('connection-error');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function hideError() {
            document.getElementById('connection-error').style.display = 'none';
        }

        function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(function() {
        // Show a brief success message
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        button.style.background = '#27ae60';
        
        setTimeout(() => {
            button.textContent = originalText;
            button.style.background = '#3498db';
        }, 1500);
    }).catch(function(err) {
        // Fallback for older browsers
        console.error('Could not copy text: ', err);
       showToast('Copy failed. Please select and copy manually.');
    });
}

function triggerFileImport() {
    document.getElementById('import-file').click();
}



async function handleFileImport(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const fileName = file.name.toLowerCase();
    
    try {
        const content = await file.text();
        
        if (fileName.endsWith('.json')) {
            await importFromJSON(content);
        } else {
            showToast('Only JSON files are supported for import', 'error');
        }
    } catch (error) {
        console.error('Import error:', error);
        showToast('Error reading file: ' + error.message, 'error');
    }
    
    // Reset file input
    event.target.value = '';
}

async function importFromJSON(jsonContent) {
    try {
        const data = JSON.parse(jsonContent);
        
        // Validate the JSON structure
        if (!data.notes || !Array.isArray(data.notes)) {
            throw new Error('Invalid JSON format - missing notes array');
        }
        
        let importedCount = 0;
        let archivesToCreate = new Set();
        let notesToArchive = [];
        
        // Process each note from the import
        // Process each note from the import with debugging
let foundById = 0;
let foundByContent = 0;
let notFound = 0;
let archivedTrue = 0;
let archivedFalse = 0;

data.notes.forEach(importedNote => {
    const existingNote = allNotes.find(note => 
    note.id === importedNote.id
    // Temporarily comment out content matching
    // || note.content.replace(/\s+/g, ' ').trim() === importedNote.content.replace(/\s+/g, ' ').trim()
);
    
    if (existingNote) {
        if (existingNote.id === importedNote.id) foundById++;
        else foundByContent++;
        
        if (importedNote.archived || importedNote.archiveName) {
            archivedTrue++;
            const archiveName = data.filter_type && data.filter_type !== 'all' 
                ? data.filter_type 
                : 'Imported Archive';
            
            archivesToCreate.add(archiveName);
            notesToArchive.push({
                noteId: existingNote.id,
                archiveName: archiveName
            });
            importedCount++;
        } else {
            archivedFalse++;
        }
    } else {
        notFound++;
    }
});
        
        if (importedCount === 0) {
            showToast('No matching notes found to import', 'warning');
            return;
        }
        
        // Create archives if they don't exist
        archivesToCreate.forEach(archiveName => {
            if (!namedArchives[archiveName]) {
                namedArchives[archiveName] = new Set();
            }
        });
        
        // Add notes to archives
        notesToArchive.forEach(({ noteId, archiveName }) => {
            namedArchives[archiveName].add(noteId);
        });
        
        // Save and update UI
        saveArchivedNotes();
        updateArchiveList();
        updateTagFilters();
        renderNotes();
        
        showToast(`Successfully imported ${importedCount} archived notes!`, 'success');
        
    } catch (error) {
        console.error('JSON import error:', error);
        showToast('Error importing JSON: ' + error.message, 'error');
    }
}

function removeFromSpecificArchive(noteId, archiveName) {
    if (!namedArchives[archiveName]) return;
    
    namedArchives[archiveName].delete(noteId);
    saveArchivedNotes();
    updateArchiveList();
    updateTagFilters();
    renderNotes();
    
    showToast(`Removed note from "${archiveName}" archive`, 'success');
}

let isSelecting = false;
let selectionStarted = false;
let selectionMode = null; // 'add' or 'remove'

function startHashtagSelection(tag, event) {
    event.preventDefault();
    event.stopPropagation();
    
    // Store initial mouse position to detect if this is a drag or click
    const startX = event.clientX;
    const startY = event.clientY;
    const startTime = Date.now();
    
    // Set up temporary mouse move listener to detect drag
    let hasMoved = false;
    const mouseMoveHandler = (moveEvent) => {
        const deltaX = Math.abs(moveEvent.clientX - startX);
        const deltaY = Math.abs(moveEvent.clientY - startY);
        
        // If mouse moved more than 5 pixels, consider it a drag
        if (deltaX > 5 || deltaY > 5) {
            hasMoved = true;
            startDragMode(tag);
        }
    };
    
    // Set up temporary mouse up listener
    const mouseUpHandler = (upEvent) => {
        document.removeEventListener('mousemove', mouseMoveHandler);
        document.removeEventListener('mouseup', mouseUpHandler);
        
        const timeDiff = Date.now() - startTime;
        
        // If it was a quick click without movement, treat as single click
        if (!hasMoved && timeDiff < 300) {
            handleSingleTagClick(tag);
        }
        
        // End any drag operation
        endHashtagSelection();
    };
    
    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', mouseUpHandler);
}

function startDragMode(tag) {
    if (isSelecting) return; // Already in drag mode
    
    isSelecting = true;
    selectionStarted = true;
    
    // Clear any existing archive/filter selections when starting hashtag selection
    currentArchive = 'default';
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Determine selection mode based on current state of clicked tag
    if (selectedTags.has(tag)) {
        selectionMode = 'remove';
        selectedTags.delete(tag);
    } else {
        selectionMode = 'add';
        selectedTags.add(tag);
    }
    
    // Update visuals immediately without full render
    updateHashtagVisualsOnly();
    updateCountOnly();
    setActiveTagButtons();
    
    // Prevent text selection during drag
    document.body.style.userSelect = 'none';
    document.body.style.webkitUserSelect = 'none';
    document.body.style.mozUserSelect = 'none';
    
    // Add visual feedback for drag mode
    document.body.classList.add('hashtag-selecting');
}

function handleSingleTagClick(tag) {
    // This handles normal single-click behavior
    toggleTag(tag);
}

function continueHashtagSelection(tag, event) {
    if (isSelecting && selectionStarted && selectionMode) {
        event.preventDefault();
        event.stopPropagation();
        
        let changed = false;
        
        if (selectionMode === 'add') {
            // Add tags that aren't already selected
            if (!selectedTags.has(tag)) {
                selectedTags.add(tag);
                changed = true;
            }
        } else if (selectionMode === 'remove') {
            // Remove tags that are currently selected
            if (selectedTags.has(tag)) {
                selectedTags.delete(tag);
                changed = true;
            }
        }
        
        if (changed) {
            updateHashtagVisualsOnly();
            updateCountOnly();
            setActiveTagButtons();
        }
    }
}

function endHashtagSelection() {
    if (selectionStarted) {
        isSelecting = false;
        selectionStarted = false;
        selectionMode = null;
        
        // Restore text selection
        document.body.style.userSelect = '';
        document.body.style.webkitUserSelect = '';
        document.body.style.mozUserSelect = '';
        document.body.classList.remove('hashtag-selecting');
        
        // Now do the full render and filter update
        applyFilters();
        renderNotes();
    }
}

// Helper function to update only hashtag visuals without full re-render
function updateHashtagVisualsOnly() {
    document.querySelectorAll('.hashtag').forEach(hashtagElement => {
        const tag = hashtagElement.dataset.tag || hashtagElement.textContent;
        if (selectedTags.has(tag)) {
            hashtagElement.setAttribute('data-selected', 'true');
            hashtagElement.style.backgroundColor = 'var(--primary-color)';
            hashtagElement.style.color = 'white';
            hashtagElement.style.borderColor = 'var(--primary-color)';
        } else {
            hashtagElement.removeAttribute('data-selected');
            hashtagElement.style.backgroundColor = '';
            hashtagElement.style.color = '';
            hashtagElement.style.borderColor = '';
        }
    });
}

// Helper function to update count without full render
function updateCountOnly() {
    // Quick filter update without full processing
    let quickCount = 0;
    if (selectedTags.size > 0) {
        const tags = Array.from(selectedTags);
        quickCount = allNotes.filter(note =>
            tags.some(tag => noteMatchesTag(note, tag))
        ).length;
    } else {
        quickCount = allNotes.length;
    }
    
    document.getElementById('notes-count').textContent = `${quickCount} notes`;
}

function extractVideoId(url) {
    const patterns = [
        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
        /youtube\.com\/watch\?.*v=([^&\n?#]+)/
    ];
    
    for (const pattern of patterns) {
        const match = url.match(pattern);
        if (match) return match[1];
    }
    return null;
}

function processYouTubeLinks(content) {
    const youtubeRegex = /(https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)[^\s]+)/g;
    
    return content.replace(youtubeRegex, (url) => {
        const videoId = extractVideoId(url);
        if (!videoId) return url;
        
        return `<div class="youtube-preview" onclick="loadYouTubeThumbnail(this, '${url}', '${videoId}')" style="
            border: 1px dashed var(--border-color);
            padding: 20px;
            margin: 8px 0;
            border-radius: 6px;
            background: var(--background-color);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        " onmouseover="this.style.borderColor='var(--primary-color)'; this.style.color='var(--primary-color)'" 
           onmouseout="this.style.borderColor='var(--border-color)'; this.style.color='var(--text-muted)'">
            Click to load YouTube video
        </div>`;
    });
}

function processImageLinks(content) {
    const imageRegex = /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp)(?:\?[^\s]*)?)/gi;
    
    return content.replace(imageRegex, (url) => {
        return `<div class="image-preview" onclick="loadImage(this, '${url}')" style="
            border: 1px dashed var(--border-color);
            padding: 20px;
            margin: 8px 0;
            border-radius: 6px;
            background: var(--background-color);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            color: var(--text-muted);
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        " onmouseover="this.style.borderColor='var(--primary-color)'; this.style.color='var(--primary-color)'" 
           onmouseout="this.style.borderColor='var(--border-color)'; this.style.color='var(--text-muted)'">
            Click to load image
        </div>`;
    });
}

function loadImage(element, url) {
  // render the image
  element.innerHTML = `
    <div style="position: relative; text-align: center; display: flex; justify-content: center;">
      <img class="note-image"
           src="${url}"
           alt="Image"
           loading="lazy"
           onerror="this.style.display='none'"
           style="max-width: 100%; height: auto; border-radius: 8px; display: block;">
    </div>`;
  // make the WHOLE dotted box clickable to close
  element.setAttribute('onclick', `closeImage(this, '${url}')`);
}

function closeImage(element, url) {
  // restore the preview state on the SAME dotted box
  element.innerHTML = `Click to load image`;
  element.setAttribute('onclick', `loadImage(this, '${url}')`);
  // (mouseover/out styles were already on the outer box, so they keep working)
}

function loadYouTubeThumbnail(element, url, videoId) {
  const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`;
  element.innerHTML = `
    <div style="position: relative; text-align: center; display: flex; justify-content: center;">
      <div class="youtube-thumbnail"
           onclick="event.stopPropagation(); window.open('${url}', '_blank')">
        <img src="${thumbnailUrl}" alt="YouTube Video" loading="lazy"
             onerror="this.src='https://img.youtube.com/vi/${videoId}/hqdefault.jpg'">
        <div class="play-button"></div>
      </div>
    </div>`;
  // make the WHOLE dotted box clickable to close
  element.setAttribute('onclick', `closeYouTube(this, '${url}', '${videoId}')`);
}

function closeYouTube(element, url, videoId) {
  // restore the preview state on the SAME dotted box
  element.innerHTML = `Click to load YouTube video`;
  element.setAttribute('onclick', `loadYouTubeThumbnail(this, '${url}', '${videoId}')`);
}

async function performAdvancedSearch(query, filters = {}) {
    if (!db || !useIndexedDB) {
        // Fallback to in-memory search
        return performInMemorySearch(query, filters);
    }
    
    try {
        let results = db.notes.orderBy('created_at').reverse();
        
        // Date range filtering
        if (filters.dateFrom) {
            const fromTimestamp = Math.floor(filters.dateFrom.getTime() / 1000);
            results = results.filter(note => note.created_at >= fromTimestamp);
        }
        
        if (filters.dateTo) {
            const toTimestamp = Math.floor(filters.dateTo.getTime() / 1000);
            results = results.filter(note => note.created_at <= toTimestamp);
        }
        
        // Content type filtering
        if (filters.contentType === 'original') {
            results = results.filter(note => !note.isReply);
        } else if (filters.contentType === 'replies') {
            results = results.filter(note => note.isReply);
        }
        
        // Length filtering
        if (filters.minLength) {
            results = results.filter(note => note.content.length >= filters.minLength);
        }
        
        if (filters.maxLength) {
            results = results.filter(note => note.content.length <= filters.maxLength);
        }
        
        // Media filtering
        if (filters.hasImages) {
            results = results.filter(note => {
                const imageRegex = /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp))/gi;
                return imageRegex.test(note.content);
            });
        }
        
        if (filters.hasYouTube) {
            results = results.filter(note => {
                const youtubeRegex = /(youtube\.com\/watch\?v=|youtu\.be\/)/gi;
                return youtubeRegex.test(note.content);
            });
        }
        
        const allResults = await results.toArray();
        
        // Text search (full-text)
        if (query && query.trim()) {
            const searchTerms = query.toLowerCase().split(/\s+/);
            return allResults.filter(note => {
                const searchText = (note.content + ' ' + (note.hashtags || []).join(' ')).toLowerCase();
                return searchTerms.every(term => searchText.includes(term));
            });
        }
        
        return allResults;
        
    } catch (error) {
        console.error('Advanced search error:', error);
        return performInMemorySearch(query, filters);
    }
}

function performInMemorySearch(query, filters) {
    let results = allNotes.slice();
    
    // Apply date filters
    if (filters.dateFrom) {
        const fromTimestamp = Math.floor(filters.dateFrom.getTime() / 1000);
        results = results.filter(note => note.created_at >= fromTimestamp);
    }
    
    if (filters.dateTo) {
        const toTimestamp = Math.floor(filters.dateTo.getTime() / 1000);
        results = results.filter(note => note.created_at <= toTimestamp);
    }
    
    // Rest of your existing filter logic...
    if (filters.contentType === 'original') {
        results = results.filter(note => !note.isReply);
    } else if (filters.contentType === 'replies') {
        results = results.filter(note => note.isReply);
    }
    
    if (filters.minLength) {
        results = results.filter(note => note.content.length >= filters.minLength);
    }
    
    if (filters.maxLength) {
        results = results.filter(note => note.content.length <= filters.maxLength);
    }
    
    if (filters.hasImages) {
        const imageRegex = /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp))/gi;
        results = results.filter(note => imageRegex.test(note.content));
    }
    
    if (filters.hasYouTube) {
        const youtubeRegex = /(youtube\.com\/watch\?v=|youtu\.be\/)/gi;
        results = results.filter(note => youtubeRegex.test(note.content));
    }
    
    if (query && query.trim()) {
        const searchTerms = query.toLowerCase().split(/\s+/);
        results = results.filter(note => {
            const searchText = (note.content + ' ' + (note.hashtags || []).join(' ')).toLowerCase();
            return searchTerms.every(term => searchText.includes(term));
        });
    }
    
    return results;
}


// Track active quick filters
let activeQuickFilters = new Set();

function toggleQuickFilter(type) {
    console.log('toggleQuickFilter called:', type);
    console.log('activeQuickFilters before:', Array.from(activeQuickFilters));
    
    const button = document.querySelector(`[data-filter="${type}"]`);
    
    if (activeQuickFilters.has(type)) {
        // Remove filter
        activeQuickFilters.delete(type);
        button.classList.remove('active');
    } else {
        // Add filter
        activeQuickFilters.add(type);
        button.classList.add('active');
    }
    
    console.log('activeQuickFilters after toggle:', Array.from(activeQuickFilters));
    
    // Clear archive selection when ANY quick filter operation happens
    // but DON'T clear hashtag selections (selectedTags)
    currentArchive = 'default';
    currentTag = '';
    
    // Clear archive active states
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // Update "All Notes" button state based on whether we have any selections
    document.querySelectorAll('.tag-filter').forEach(btn => {
        if (btn.dataset.tag === '') {
            // "All Notes" is only active if no hashtags AND no quick filters are selected
            if (selectedTags.size === 0 && activeQuickFilters.size === 0) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }
        // Don't modify hashtag button states here - let setActiveTagButtons handle them
    });
    
    console.log('currentArchive after:', currentArchive);
    console.log('selectedTags preserved:', Array.from(selectedTags));
    
    // Apply combined filters (quick filters + hashtag selections)
    applyAllFilters();
}

async function applyAllFilters() {
    const query = document.getElementById('search-input').value;
    const filters = {};
    
    // Process quick filters - find the EARLIEST date from all active filters
    let earliestDate = null;
    
    activeQuickFilters.forEach(filterType => {
        const now = new Date();
        
        switch(filterType) {
            case 'week':
                const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                if (!earliestDate || weekAgo < earliestDate) {
                    earliestDate = weekAgo;
                }
                break;
                
            case 'month':
                const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                if (!earliestDate || monthAgo < earliestDate) {
                    earliestDate = monthAgo;
                }
                break;
                
            case 'year':
                const yearAgo = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
                if (!earliestDate || yearAgo < earliestDate) {
                    earliestDate = yearAgo;
                }
                break;
                
            case 'images':
                filters.hasImages = true;
                break;
                
            case 'youtube':
                filters.hasYouTube = true;
                break;
                
            case 'long':
                filters.minLength = 500;
                break;
        }
    });
    
    // Set the earliest date if any date filters are active
    if (earliestDate) {
        filters.dateFrom = earliestDate;
    }
    
    // Manual date range filters - these OVERRIDE quick filters if set
    const dateFromValue = document.getElementById('date-from').value;
    const dateToValue = document.getElementById('date-to').value;
    
    if (dateFromValue) {
        // Create date at start of day
        const fromDate = new Date(dateFromValue + 'T00:00:00');
        filters.dateFrom = fromDate;
    }
    
    if (dateToValue) {
        // Create date at end of day
        const toDate = new Date(dateToValue + 'T23:59:59');
        filters.dateTo = toDate;
    }
    
    performSearchWithFilters(query, filters);
}

function clearAllFilters() {
    // Clear quick filters
    activeQuickFilters.clear();
    document.querySelectorAll('.quick-filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Clear date filters
    document.getElementById('date-from').value = '';
    document.getElementById('date-to').value = '';
    
    // Clear search
    document.getElementById('search-input').value = '';
    searchQuery = '';
    
    // Reset ALL state variables
    selectedTags.clear();
    currentTag = '';
    currentArchive = 'default';
    window.inAdvancedSearchMode = false; // Clear advanced search mode
    
    // Clear all UI states
    document.querySelectorAll('.archive-item').forEach(item => {
        item.classList.remove('active');
    });
    
    document.querySelectorAll('.tag-filter').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.tag === '') {
            btn.classList.add('active');
        }
    });
    
    // FORCE reset to all notes (bypass all filtering)
    filteredNotes = allNotes.slice();
    resetPagination();
    renderNotes();
    
    // Reset title and count
    document.getElementById('notes-title').textContent = 'All Notes';
    document.getElementById('notes-count').textContent = `${allNotes.length} notes`;
}

// TEMPORARY: Add this function to debug the cache issue
async function forceResetUserCache() {
    if (!currentPubkey) {
        console.log('No user connected');
        return;
    }
    
    try {
        console.log(`Force resetting cache for user: ${currentPubkey.substring(0, 8)}...`);
        
        // Close database
        if (db && db.isOpen()) {
            await db.close();
        }
        
        // Delete the specific IndexedDB for this user
        const dbName = `nostr-notes-${currentPubkey}`;
        await new Promise((resolve) => {
            const deleteReq = indexedDB.deleteDatabase(dbName);
            deleteReq.onsuccess = () => {
                console.log(`Deleted IndexedDB: ${dbName}`);
                resolve();
            };
            deleteReq.onerror = () => {
                console.log(`Failed to delete IndexedDB: ${dbName}`);
                resolve();
            };
            deleteReq.onblocked = () => {
                console.log(`IndexedDB deletion blocked: ${dbName}`);
                setTimeout(resolve, 2000);
            };
        });
        
        // Clear localStorage entries for this user
        localStorage.removeItem(`nostr-archived-notes-${currentPubkey}`);
        localStorage.removeItem(`nostr-named-archives-${currentPubkey}`);
        localStorage.removeItem(`nostr-cached-notes-${currentPubkey}`);
        localStorage.removeItem(`nostr-cache-updated-at-${currentPubkey}`);
        localStorage.removeItem(`nostr-last-pubkey-${currentPubkey}`);
        
        // Reset database connection
        db = null;
        
        console.log('Cache reset complete - reconnect to fetch fresh data');
        showToast('User cache cleared - please reconnect', 'success');
        
        // Disconnect user to force fresh connection
        disconnect();
        
    } catch (error) {
        console.error('Error resetting cache:', error);
    }
}

async function performSearchWithFilters(query, filters) {
    const results = await performAdvancedSearch(query, filters);
    
    // Apply hashtag filtering AFTER the advanced search results
    let finalResults = results;
    
    // Apply hashtag/tag filtering if any tags are selected
    if (selectedTags.size > 0) {
        const tags = Array.from(selectedTags);
        finalResults = finalResults.filter(note =>
            tags.some(tag => noteMatchesTag(note, tag))
        );
    }
    
    // Store the final filtered results
    filteredNotes = finalResults;
    searchQuery = query;
    renderNotes();
    
    // Build comprehensive filter description
    const activeFilters = [];
    
    // Add quick filters
    if (activeQuickFilters.has('week')) activeFilters.push('This Week');
    if (activeQuickFilters.has('month')) activeFilters.push('This Month');
    if (activeQuickFilters.has('year')) activeFilters.push('This Year');
    if (activeQuickFilters.has('images')) activeFilters.push('Images');
    if (activeQuickFilters.has('youtube')) activeFilters.push('Videos');
    if (activeQuickFilters.has('long')) activeFilters.push('Long');
    
    // Add search terms from text search
    if (query && query.trim()) {
        const searchTerms = query.trim().split(/\s+/);
        searchTerms.forEach(term => {
            if (term.startsWith('#')) {
                activeFilters.push(term);
            } else {
                activeFilters.push(`"${term}"`);
            }
        });
    }
    
    // Add selected hashtags from multi-selection
    selectedTags.forEach(tag => {
        if (tag === '__original') {
            activeFilters.push('Original Notes');
        } else if (tag === '__replies') {
            activeFilters.push('Replies');
        } else if (tag === '__archived') {
            activeFilters.push('Archived');
        } else if (tag.startsWith('#')) {
            // Only add if it's not already in the list from search terms
            if (!activeFilters.includes(tag)) {
                activeFilters.push(tag);
            }
        }
    });
    
    // Manual date filters (only show if no quick date filters)
    if (filters.dateFrom && !activeQuickFilters.has('week') && !activeQuickFilters.has('month') && !activeQuickFilters.has('year')) {
        activeFilters.push('Date Filtered');
    }
    
    // Update UI
    const title = document.getElementById('notes-title');
    const count = document.getElementById('notes-count');
    
    if (activeFilters.length > 0) {
        title.textContent = `Filtered Notes (${activeFilters.join(' + ')})`;
    } else {
        title.textContent = 'All Notes';
    }
    
    count.textContent = `${finalResults.length} notes`;
    
    // Store that we're in advanced search mode
    window.inAdvancedSearchMode = true;
}



// Make functions globally available
window.toggleQuickFilter = toggleQuickFilter;
window.applyDateFilters = applyDateFilters;
window.clearAllFilters = clearAllFilters;


// Add global event listeners for hashtag selection
document.addEventListener('mouseup', endHashtagSelection);
document.addEventListener('mouseleave', endHashtagSelection);


// Make functions globally available for onclick handlers
// Core functionality
window.filterByTag = filterByTag;
window.toggleArchiveNote = toggleArchiveNote;
window.viewArchive = viewArchive;
window.deleteArchive = deleteArchive;
window.toggleNoteSelection = toggleNoteSelection;
window.showStorageInfo = showStorageInfo;
window.closeStorageInfo = closeStorageInfo;
window.optimizeStorage = optimizeStorage;
window.exportStorageReport = exportStorageReport;

// UI and modals
window.showNoteInfo = showNoteInfo;
window.selectArchiveOption = selectArchiveOption;
window.closeArchiveModal = closeArchiveModal;
window.showAppInfo = showAppInfo;
window.closeAppInfo = closeAppInfo;

// Archive management
window.removeFromSpecificArchive = removeFromSpecificArchive;

// Media loading
window.loadYouTubeThumbnail = loadYouTubeThumbnail;
window.loadImage = loadImage;
window.closeImage = closeImage;
window.closeYouTube = closeYouTube;

// Utilities
window.copyToClipboard = copyToClipboard;
window.clearAllCache = clearAllCache;
window.showToast = showToast;

// Make hashtag selection functions globally available
window.startHashtagSelection = startHashtagSelection;
window.continueHashtagSelection = continueHashtagSelection;
window.endHashtagSelection = endHashtagSelection;

          // Theme functionality - add this at the very end of your JavaScript
setTimeout(function() {
    const themeSelector = document.getElementById('theme-selector');
    // Load saved theme on startup
const savedTheme = localStorage.getItem('nostr-theme') || 'default';
if (savedTheme !== 'default') {
    document.body.setAttribute('data-theme', savedTheme);
    themeSelector.value = savedTheme;
}
    if (themeSelector) {
       themeSelector.addEventListener('change', function(e) {
    document.body.setAttribute('data-theme', e.target.value);
    localStorage.setItem('nostr-theme', e.target.value);
});
    }
}, 1000);

// One-time cleanup of old global archives - remove after running once
if (!localStorage.getItem('archives-cleanup-done')) {
    localStorage.removeItem('nostr-archived-notes');
    localStorage.removeItem('nostr-named-archives');
    localStorage.setItem('archives-cleanup-done', 'true');
}

    </script>
</body>
</html>